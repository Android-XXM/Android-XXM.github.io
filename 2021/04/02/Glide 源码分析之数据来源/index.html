<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Glide 源码分析之数据"><meta name="keywords" content="源码分析,Glide"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>Glide 源码分析之数据 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text"> 摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text"> 内存缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#loadfromactiveresources"><span class="toc-number">3.1.</span> <span class="toc-text"> loadFromActiveResources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loadfromcache"><span class="toc-number">3.2.</span> <span class="toc-text"> loadFromCache</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#waitforexistingorstartnewjob"><span class="toc-number">4.</span> <span class="toc-text"> waitForExistingOrStartNewJob</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diskcacheexector"><span class="toc-number">4.0.1.</span> <span class="toc-text"> DiskCacheExector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sourceexecutor"><span class="toc-number">4.0.2.</span> <span class="toc-text"> SourceExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#animationexecutor"><span class="toc-number">4.0.3.</span> <span class="toc-text"> AnimationExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlimitedsourceexecutor"><span class="toc-number">4.0.4.</span> <span class="toc-text"> UnlimitedSourceExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decodejob"><span class="toc-number">4.0.5.</span> <span class="toc-text"> DecodeJob</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#resourcecachegenerator"><span class="toc-number">4.1.</span> <span class="toc-text"> ResourceCacheGenerator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#startnext"><span class="toc-number">4.1.1.</span> <span class="toc-text"> startNext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getchachekeys"><span class="toc-number">4.1.2.</span> <span class="toc-text"> getChacheKeys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getloaddata"><span class="toc-number">4.1.3.</span> <span class="toc-text"> getLoadData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getmodelloaders"><span class="toc-number">4.1.4.</span> <span class="toc-text"> getModelLoaders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getmodelloadersforclass"><span class="toc-number">4.1.5.</span> <span class="toc-text"> getModelLoadersForClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multimodelloaderfactorybuildmodelclass"><span class="toc-number">4.1.6.</span> <span class="toc-text"> multiModelLoaderFactory.build(modelClass)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#modelloaderbuildloaddata"><span class="toc-number">4.1.7.</span> <span class="toc-text"> modelLoader.buildLoadData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getregisteredresourceclasses"><span class="toc-number">4.1.8.</span> <span class="toc-text"> getRegisteredResourceClasses()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dataclass%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.8.1.</span> <span class="toc-text"> DataClass列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resourceclass%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.8.2.</span> <span class="toc-text"> ResourceClass列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transcodeclass%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.8.3.</span> <span class="toc-text"> TranscodeClass列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#disklrucache"><span class="toc-number">4.1.9.</span> <span class="toc-text"> DiskLruCache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#helpergetmodelloaders"><span class="toc-number">4.1.10.</span> <span class="toc-text"> helper.getModelLoaders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetcherloaddata"><span class="toc-number">4.1.11.</span> <span class="toc-text"> fetcher.loadData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resoucrcachegenerator%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.12.</span> <span class="toc-text"> ResoucrCacheGenerator小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#datacachegenerator"><span class="toc-number">4.2.</span> <span class="toc-text"> DataCacheGenerator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sourcegeneator"><span class="toc-number">4.3.</span> <span class="toc-text"> SourceGeneator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#startnextloadloaddata"><span class="toc-number">4.3.1.</span> <span class="toc-text"> startNextLoad(loadData)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text"> 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Glide 源码分析之数据</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">9.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 43 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1>
<p>作为Glide的第二篇，主要分析了Glide请求中数据来源，或者说Glide的缓存机制。Glide构建过程会配置很多注册项，然后在获取数据时，会根据已有的信息，如<code>dataClass</code>等，然后找到合适的<code>ModelLoader</code>、<code>Decoder</code>、<code>Transcoder</code>等，经历了四个缓存历程，没有找到合适的缓存，最终从网络拉取数据。</p>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在上文<a target="_blank" rel="noopener" href="https://xxm-sz.github.io/2021/03/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/">Glide流程分析</a>分析<code>with</code>、<code>load</code>、<code>into</code>函数三步骤时，略过了最重要的步骤：数据获取。本节从<code>into</code>函数中的<code>engile.load</code>函数开始，分析Glide如何从不同的地方加载数据。这里需要记住参数<code>modelClass</code>、<code>resourceClass</code>和<code>transcodeClass</code>的实参分别是<code>String.class</code>、<code>Object.class</code>和<code>Drawable.Class</code>，而<code>model=https://xxm-sz/github.io/test.png</code>。</p>
<p><code>resourceClass</code>通常代表原始数据解码后的资源类型，<code>dataClass</code>代表原始数据类型，<code>transcodeClass</code>代表采样，解码后的资源类型。<code>modelClass</code>代表我们<code>Glide.with(context).load(xxx)</code>函数中<code>load</code>函数参数<code>xxx</code>的类型。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//EngineKey用参数来作为equals和hashCode函数的计算条件</span></span><br><span class="line">  EngineKey key =</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="comment">//步骤1：从内存获取资源（活动资源缓存和内存缓存）</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//步骤2：从本地磁盘或网络获取资源</span></span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="内存缓存"><a class="markdownIt-Anchor" href="#内存缓存"></a> 内存缓存</h1>
<p><code>engile.load</code>函数通过各种信息计算出<code>EngineKey</code>,然后通过<code>loadFromMemory</code>函数从内存获取资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) {</span><br><span class="line">  <span class="keyword">if</span> (!isMemoryCacheable) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>isMemoryCacheable</code>默认情况下等于<code>true</code>，先调用了<code>loadFromActiveResources</code>函数从活动资源获取资源，如果获取不到，再调用<code>loadFromCache</code>函数从内存获取资源。</p>
<h2 id="loadfromactiveresources"><a class="markdownIt-Anchor" href="#loadfromactiveresources"></a> <code>loadFromActiveResources</code></h2>
<p>先分析从<code>loadFromActiveResources</code>资源获取活动资源。这里的活动资源指的已经设置到<code>Target</code>后释放的，没有<code>Target</code>引用到的，垃圾回收器还没有回收的资源的，<code>Glide</code>可以重新获取设置给新的<code>Target</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) {</span><br><span class="line">  EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="keyword">null</span>) {</span><br><span class="line">    active.acquire();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> active;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>ActiveResources</code>对象在<code>Engine</code>引擎被创建时初始化，内部持有一个<code>HashMap</code>类型的``activeEngineResources<code>变量,以</code>Key<code>为键，</code>ResourceWeakReference<code>为值。通过</code>get`函数去获取资源的弱引用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) {</span><br><span class="line">  ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (activeRef == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">  <span class="keyword">if</span> (active == <span class="keyword">null</span>) {</span><br><span class="line">    cleanupActiveReference(activeRef);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> active;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果能获取到活动资源<code>EngineResource</code>,调用其<code>activate</code>函数,并返回该活动资源，然后通过回调设置给<code>Target</code>了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>{</span><br><span class="line">  ResourceWeakReference toPut =</span><br><span class="line">      <span class="keyword">new</span> ResourceWeakReference(</span><br><span class="line">          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">  ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">  <span class="keyword">if</span> (removed != <span class="keyword">null</span>) {</span><br><span class="line">    removed.reset();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>activate</code>只是新建<code>ResourceWeakReference</code>实例，然后放到<code>activeEngineResources</code>中。</p>
<h2 id="loadfromcache"><a class="markdownIt-Anchor" href="#loadfromcache"></a> <code>loadFromCache</code></h2>
<p>从活动缓存获取不到资源，就调用<code>loadFromCache</code>函数从内存缓存获取资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) {</span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) {</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用了<code>getEngineResourceFromCache</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) {</span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="keyword">null</span>) {</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) {</span><br><span class="line">    <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> EngineResource&lt;&gt;(</span><br><span class="line">            cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getEngineResourceFromCache</code>函数的逻辑也是非常易懂，不过多介绍。这里的<code>cache</code>是<code>MemoryCache</code>类型，在<code>GlideBuilder</code>的<code>build</code>函数创建<code>Glide</code>时，会创建<code>MemoryCache</code>的实现类<code>LruResourceCache</code>并传递给<code>Engine</code>实例。<code>LruResourceCache</code>继承自<code>LruCache</code>类，并实现<code>MemoryCache</code>接口。而LruCache内部维护着<code>LinkedHashMap</code>，用于存取缓存。</p>
<p>所以如果从<code>LruChache</code>中能得到缓存，也会回调将资源设置给<code>Target</code>.</p>
<h1 id="waitforexistingorstartnewjob"><a class="markdownIt-Anchor" href="#waitforexistingorstartnewjob"></a> <code>waitForExistingOrStartNewJob</code></h1>
<p>该函数主要是从不同的来源去加载目标资源，有可能是本地磁盘缓存，也有可能是网络资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">    EngineKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> startTime)</span> </span>{</span><br><span class="line">	<span class="comment">//Jobs对象jobs内部持有HashMap类型的jobs和onlyCacheJobs，根据onlyRetrieveFromCache在两者切换</span></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current != <span class="keyword">null</span>) {</span><br><span class="line">    current.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) {</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      decodeJobFactory.build(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          key,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          options,</span><br><span class="line">          engineJob);</span><br><span class="line"></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中<code>jobs</code>是<code>Jobs</code>类对象，<code>Jobs</code>类持有<code>HashMap</code>类型的<code>jobs</code>和<code>onlyCacheJobs</code>，根据<code>onlyRetrieveFromCache</code>在两者切换。<code>HashMap</code>的<code>Value</code>是<code>EngineJob</code>类，是一个<code>Glide</code>请求加载管理类，当加载完成会通过回调通知。如果能获取到<code>EngineJob</code>对象，说明已经有相同的任务在进行中。</p>
<p>如果<code>Jobs</code>对象中获取不到<code>EngineJob</code>，则通过工厂新建一个<code>EngineJob</code>对象和<code>DecodeJob</code>对象，并调用其<code>engineJob.start</code>函数。这里<code>DecodeJob</code>类负责从缓存数据或原始数据解码，转换出目标资源类型。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">  GlideExecutor executor =</span><br><span class="line">      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//DiskCacheStrategy默认情况下decodeCachedResource返回ture,firstStage将返回Stage.RESOURCE_CACHE，所以该方法返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">willDecodeFromCache</span><span class="params">()</span> </span>{</span><br><span class="line">  Stage firstStage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">  <span class="keyword">return</span> firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>start</code>函数通过线程池去执行<code>DecodeJob</code>对象。在看<code>DecodeJob</code>的<code>run</code>函数之前，先看看相关线程池的创建。</p>
<h3 id="diskcacheexector"><a class="markdownIt-Anchor" href="#diskcacheexector"></a> <code>DiskCacheExector</code></h3>
<p><code>GlideBuilder</code>的<code>build</code>函数会将下面提到的线程池都创建，这里先看 <code>diskCacheExecutor</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GlideBuilder#build </span></span><br><span class="line">diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//GlideExector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newDiskCacheExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> newDiskCacheBuilder().build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newDiskCacheBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">true</span>)</span><br><span class="line">      .setThreadCount(DEFAULT_DISK_CACHE_EXECUTOR_THREADS)<span class="comment">//=1</span></span><br><span class="line">      .setName(DEFAULT_DISK_CACHE_EXECUTOR_NAME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlideExecutor <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(name)) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Name must be non-null and non-empty, but given: "</span> + name);</span><br><span class="line">    }</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            <span class="comment">/*keepAliveTime=*/</span> threadTimeoutMillis,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            <span class="keyword">new</span> DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadTimeoutMillis != NO_THREAD_TIMEOUT) {</span><br><span class="line">      executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(executor);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里线程池的核心线程和最大线程数都设置成了1,即单线程线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> GlideExecutor <span class="title">getActiveSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> useUnlimitedSourceGeneratorPool</span><br><span class="line">      ? sourceUnlimitedExecutor</span><br><span class="line">      : (useAnimationPool ? animationExecutor : sourceExecutor);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="sourceexecutor"><a class="markdownIt-Anchor" href="#sourceexecutor"></a> <code>SourceExecutor</code></h3>
<p><code>sourceExecutor</code>的创建：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> newSourceBuilder().build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newSourceBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">false</span>)</span><br><span class="line">      .setThreadCount(calculateBestThreadCount())</span><br><span class="line">      .setName(DEFAULT_SOURCE_EXECUTOR_NAME);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>与磁盘缓存线程池创建的区别是线程数的计算。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateBestThreadCount</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (bestThreadCount == <span class="number">0</span>) {</span><br><span class="line">    bestThreadCount =</span><br><span class="line">        Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bestThreadCount;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>MAXIMUM_AUTOMATIC_THREAD_COUNT=4</code>，所以资源线程池的线程多少取决于设备CPU核心数量，且最多为4。</p>
<h3 id="animationexecutor"><a class="markdownIt-Anchor" href="#animationexecutor"></a> <code>AnimationExecutor</code></h3>
<p><code>animationExecutor</code>线程的创建亦是如此，不过它逻辑是这样，当CPU核心数大于4，线程数设为2，否则设为1.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newAnimationBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> bestThreadCount = calculateBestThreadCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maximumPoolSize = bestThreadCount &gt;= <span class="number">4</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">true</span>)</span><br><span class="line">      .setThreadCount(maximumPoolSize)</span><br><span class="line">      .setName(DEFAULT_ANIMATION_EXECUTOR_NAME);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="unlimitedsourceexecutor"><a class="markdownIt-Anchor" href="#unlimitedsourceexecutor"></a> <code>UnlimitedSourceExecutor</code></h3>
<p>Glide还创建了无限制的线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GlideExecutor.newUnlimitedSourceExecutor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newUnlimitedSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(</span><br><span class="line">      <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          Integer.MAX_VALUE,</span><br><span class="line">          KEEP_ALIVE_TIME_MS,</span><br><span class="line">          TimeUnit.MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">          <span class="keyword">new</span> DefaultThreadFactory(</span><br><span class="line">              DEFAULT_SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, <span class="keyword">false</span>)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里直接创建线程池，线程池容量无限大（<code>Integer.MAX_VALUE</code>）,核心线程为1，10秒存活。</p>
<p>也就是说，默认情况下，Glide会为我们创建四种类型<code>GlideExecutor</code>,它们的主要区别是核心线程数和最大线程数的区别。</p>
<ul>
<li><code>diskCacheExecutor</code>：磁盘缓存线程池：核心和最大线程数都是1。</li>
<li><code>sourceExecutor</code>： 数据来源线程池：核心和最大线程数都最大为4，最小取决CPU核心。</li>
<li><code>animationExecutor</code>：动画线程池：CPU核心数大于4，核心和最大线程数设为2，否则设为1</li>
<li><code>unlimitedSourceExecutor</code>：无限制线程池，核心为，最大无限制。</li>
</ul>
<h3 id="decodejob"><a class="markdownIt-Anchor" href="#decodejob"></a> <code>DecodeJob</code></h3>
<p>了解完线程池的创建，回到<code>DecodeJob</code>类的<code>run</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">    runWrapped();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在创建<code>DecodeJob</code>对象的时候,<code>runReason</code>会被赋值为<code>INITIALIZE</code>，所以<code>runWrapped</code>函数这里走的是<code>INITIALIZE</code>分支。该分支有三个重要函数。</p>
<p><code>getNextStage</code>函数、<code>getNextGenerator</code>函数和<code>runGenerators</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (runReason) {</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getNextStage</code>函数的<code>INITIALIZE</code>分支。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (current) {</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">          ? Stage.RESOURCE_CACHE</span><br><span class="line">          : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">          ? Stage.DATA_CACHE</span><br><span class="line">          : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (stage) {</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，默认情况下<code>DiskCacheStrategy</code>是<code>AUTOMATIC</code>,其<code>decodeCachedResource</code>函数和<code>decodeCachedData</code>函数都是返回<code>true</code>。所有<code>getNextStage</code>函数返回<code>Stage.RESOURCE_CACHE</code>，<code>getNextGenerator</code>函数返回<code>ResourceCacheGenerator</code>对象。</p>
<p>而<code>runGenerators</code>函数主要执行<code>Generator</code>的<code>startNext</code>函数。如果<code>startNext</code>函数返回<code>false</code>，则执行下一个策略和对应的<code>Generator</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>{</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) {</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) {</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {</span><br><span class="line">    notifyFailed();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="resourcecachegenerator"><a class="markdownIt-Anchor" href="#resourcecachegenerator"></a> <code>ResourceCacheGenerator</code></h2>
<p><code>ResourceCacheGenerator</code>是我们碰到第一个<code>Generator</code>,主要缓存采样或转换后的资源，利用<code>DiskLruCache</code>在硬盘上进行存取资源。分析起来会比较吃力，但理解了之后，再看<code>DataCacheGenerator</code>和<code>SourceGenerator</code>就简单多了。</p>
<h3 id="startnext"><a class="markdownIt-Anchor" href="#startnext"></a> <code>startNext</code></h3>
<p>看看<code>ResourceCacheGenerator</code>的<code>startNext</code>函数。<code>startNext</code>函数的工作量非常多，分成几个步骤分析。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">//步骤1</span></span><br><span class="line">  List&lt;Key&gt; sourceIds = helper.getCacheKeys();</span><br><span class="line">  <span class="keyword">if</span> (sourceIds.isEmpty()) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//步骤2</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();</span><br><span class="line">  <span class="keyword">if</span> (resourceClasses.isEmpty()) {</span><br><span class="line">    <span class="keyword">if</span> (File.class.equals(helper.getTranscodeClass())) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Failed to find any load path from "</span></span><br><span class="line">            + helper.getModelClass()</span><br><span class="line">            + <span class="string">" to "</span></span><br><span class="line">            + helper.getTranscodeClass());</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//步骤3</span></span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">    resourceClassIndex++;</span><br><span class="line">    <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) {</span><br><span class="line">      sourceIdIndex++;</span><br><span class="line">      <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">    currentKey =</span><br><span class="line">        <span class="keyword">new</span> ResourceCacheKey( <span class="comment">// NOPMD AvoidInstantiatingObjectsInLoops</span></span><br><span class="line">            helper.getArrayPool(),</span><br><span class="line">            sourceId,</span><br><span class="line">            helper.getSignature(),</span><br><span class="line">            helper.getWidth(),</span><br><span class="line">            helper.getHeight(),</span><br><span class="line">            transformation,</span><br><span class="line">            resourceClass,</span><br><span class="line">            helper.getOptions());</span><br><span class="line">    cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">      sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//步骤4</span></span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(</span><br><span class="line">            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="getchachekeys"><a class="markdownIt-Anchor" href="#getchachekeys"></a> <code>getChacheKeys</code></h3>
<p>步骤1：<code>DecodeHelper.getCacheKeys</code>函数主要工作遍历<code>getLoadData</code>函数获取到的<code>LoadData</code>列表，将每个<code>LoadData</code>中的<code>sourceKeys</code>对象和<code>alternateKeys</code>集合添加到<code>cacheKeys</code>集合(去掉重复的<code>Key</code>)并返回。这里的<code>key</code>对象用于唯一标识缓存数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Key&gt; <span class="title">getCacheKeys</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!isCacheKeysSet) {</span><br><span class="line">    isCacheKeysSet = <span class="keyword">true</span>;</span><br><span class="line">    cacheKeys.clear();</span><br><span class="line">    <span class="comment">//重点，通过modelClass获取所有model配置项符合的ModelLoader</span></span><br><span class="line">    List&lt;LoadData&lt;?&gt;&gt; loadData = getLoadData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = loadData.size(); i &lt; size; i++) {<span class="comment">//将LoadData的key和备选alternateKeys列表添加到cacheKeys列表</span></span><br><span class="line">      LoadData&lt;?&gt; data = loadData.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!cacheKeys.contains(data.sourceKey)) {<span class="comment">//去掉重复的key</span></span><br><span class="line">        cacheKeys.add(data.sourceKey);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.alternateKeys.size(); j++) {</span><br><span class="line">        <span class="keyword">if</span> (!cacheKeys.contains(data.alternateKeys.get(j))) {<span class="comment">//去掉重复的key</span></span><br><span class="line">          cacheKeys.add(data.alternateKeys.get(j));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cacheKeys;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="getloaddata"><a class="markdownIt-Anchor" href="#getloaddata"></a> <code>getLoadData</code></h3>
<p><code>getLocadData</code>函数主要通过<code>glideContext.getRegistry().getModelLoaders(model)</code>函数获取<code>ModelLoader</code>列表<code>modelLoaders</code>，并迭代<code>modelLoaders</code>列表，调用每个<code>ModelLoader</code>的<code>buildLoadData</code>函数创建<code>LoadData</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() {</span><br><span class="line">  <span class="keyword">if</span> (!isLoadDataSet) {</span><br><span class="line">    isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">    loadData.clear();</span><br><span class="line">    <span class="comment">//从注册表获取modelLoaders列表</span></span><br><span class="line">    List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) {</span><br><span class="line">      ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line"></span><br><span class="line">      LoadData&lt;?&gt; current = modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="comment">//并不是所有获取到的ModelLoader都能处理该model，current==null表示该loader或者其持有的loader都不能处理该model</span></span><br><span class="line">      <span class="keyword">if</span> (current != <span class="keyword">null</span>) {</span><br><span class="line">        loadData.add(current);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> loadData;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>glideContext.getRegistry().getModelLoaders(model)</code>函数最终调用到<code>ModelLoaderRegistry.getModelLoaders(model)</code>函数。</p>
<p>在构建Glide的单例时，会创建<code>Register</code>的实例，而<code>Register</code>会创建其他几个注册类，例如这里的<code>ModelLoaderRegistry</code>，Glide通过Register注册的内容会被代理到具体的注册类，这些注册类或者它们的工厂类会持有各自<code>Entry</code>元素的列表，Glide注册的所有内容（注册项）都以<code>Entry</code>实例被保存到对应列表。也就是它们的工作原理都是类似，然后通过<code>modelClass</code>、<code>resourceClass</code>、<code>transcodeClas</code>等去获取相关配置项。我们会把这些配置项整理成Excel文件，方便筛选。</p>
<p>**<code>ModelLoaderRegistry</code>**是注册类之一，主要持有<code>MultiModelLoaderFactory</code>工厂，所有的操作基本代理到工厂上，例如添加配置项到Entry列表。另外就是<code>ModelLoaderCache</code>缓存，毕竟每次寻找迭代所有配置项是昂贵的操作。<code>MultiModelLoaderFactory</code>工厂类主要根据给定的<code>modelClass</code>和<code>dataClass</code>(原始数据类型，例如<code>InputStream.Class</code>)获取一个或多个<code>ModelLoader</code>（这种寻找或者说映射关系就是所谓的配置项）。</p>
<p><code>ModelLoader</code>：是一个接口，有很多具体实现类，表示从不同的来源加载不同类型的资源。其<code>buildLoadData</code>函数返回<code>LoadData</code>对象，<code>handles</code>函数表示当前<code>ModelLoader</code>能否处理该<code>model</code>，通过该类型去加载原始数据。</p>
<p><code>LoadData</code>是<code>ModelLoader</code>的内部类,表示持有一个<code>Key</code>类型变量<code>sourceKey</code>用于标识正在加载的来源（地址）和备选的<code>Key</code>集合<code>alternateKeys</code>指向缓存数据，当没有缓存，通过<code>DataFetcher</code>对象<code>fetcher</code>从来源加载数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> Model model) {</span><br><span class="line">  <span class="keyword">return</span> modelLoaderRegistry.getModelLoaders(model);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="getmodelloaders"><a class="markdownIt-Anchor" href="#getmodelloaders"></a> <code>getModelLoaders</code></h3>
<p><code>getModelLoaders</code>函数调用了<code>getModelLoadersForClass</code>函数获取了<code>ModelLoader</code>列表<code>modelLoaders</code>，并迭代调用每个<code>ModelLoader</code>对象的<code>handles</code>函数过滤掉不能处理该模型具体内容的<code>ModelLoader</code>。例如列表中<code>ModelLoader</code>实例都能处理<code>String.class</code>，但有的<code>ModelLoader</code>能处理<code>http/https</code>开头的<code>String</code>，而有的不行，所以需要<code>ModelLoader</code>的<code>handles</code>函数再进一步过滤。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> A model) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; modelLoaders = getModelLoadersForClass(getClass(model));</span><br><span class="line">  <span class="keyword">if</span> (modelLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; filteredLoaders = Collections.emptyList();</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;A, ?&gt; loader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (loader.handles(model)) {<span class="comment">//过滤掉一些不能处理具体内容的</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty) {</span><br><span class="line">        filteredLoaders = <span class="keyword">new</span> ArrayList&lt;&gt;(size - i);</span><br><span class="line">        isEmpty = <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      filteredLoaders.add(loader);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (filteredLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model, modelLoaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> filteredLoaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="getmodelloadersforclass"><a class="markdownIt-Anchor" href="#getmodelloadersforclass"></a> <code>getModelLoadersForClass</code></h3>
<p><code>getModelLoadersForClass</code>函数根据<code>model</code>，先在缓存<code>ModelLoaderCache</code>(内部持有<code>HashMap</code>)对象<code>cache</code>获取<code>ModelLoader</code>列表<code>loaders</code>，没有的话再通过工厂<code>MultiModelLoaderFactory</code>对象的<code>build</code>函数创建。注意到创建列表后会缓存到<code>cache</code>中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoadersForClass(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;A&gt; modelClass) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; loaders = cache.get(modelClass);</span><br><span class="line">  <span class="keyword">if</span> (loaders == <span class="keyword">null</span>) {</span><br><span class="line">    loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));</span><br><span class="line">    cache.put(modelClass, loaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> loaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="multimodelloaderfactorybuildmodelclass"><a class="markdownIt-Anchor" href="#multimodelloaderfactorybuildmodelclass"></a> <code>multiModelLoaderFactory.build(modelClass)</code></h3>
<p><code>MultiModelLoaderFactory.build</code>函数创建<code>ModelLoader</code>列表。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; build(<span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass) {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    List&lt;ModelLoader&lt;Model, ?&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(modelClass)) {</span><br><span class="line">        alreadyUsedEntries.add(entry);</span><br><span class="line">        loaders.add(<span class="keyword">this</span>.&lt;Model, Object&gt;build(entry));</span><br><span class="line">        alreadyUsedEntries.remove(entry);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> loaders;</span><br><span class="line">  } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">    alreadyUsedEntries.clear();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>遍历<code>Entry</code>集合<code>entries</code>，通过每个<code>Entry</code>实例的<code>handles</code>函数判断是否有能力处理该<code>model</code>，能处理的话通过<code>entry.factory.build(this)</code>创建<code>ModelLoader</code>。</p>
<p><code>Entry</code>类<code>handles</code>函数是判断该<code>Entry</code>能否处理该<code>model</code>，例如，<code>String.class</code>,<code>Uri.class</code>。而<code>ModelLoader</code>子类的<code>handles</code>函数判断是能否处理<code>model</code>类型的内容，例如字符串<code>https://xxm-sz.githuh.io</code>与<code>content://localstorage/data</code>，但有的<code>ModelLoader</code>直接返回<code>true</code>,在<code>buildLoadData</code>函数交给自身持有的<code>ModelLoader</code>或<code>ModelLoader</code>列表去处理。</p>
<p>贴一下到这里的<strong>调用图</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210323173012.png" alt="resouceCacheGenerator"></p>
<p>接下来，就涉及到<code>Entry</code>集合<code>entries</code>怎么来，以及<code>Entry</code>怎么创建<code>ModelLoader</code>。</p>
<p><code>ModelLoaderRegistry</code>在<code>Register</code>创建的时候被实例化，而在<code>GlideBuilder</code>构建建的过程中，会给<code>Register</code>设置超多的配置，这些配置中的<code>Loader</code>配置都会设置给<code>ModelLoaderRegistry</code>，每个配置都会封装成Entry保存到工厂类<code>MultiModelLoaderFactory</code>的<code>entries</code>列表中。而我们例子匹配到下面四个配置项。<img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331145147.png" alt="image-20210331145140795"></p>
<p>看看<code>MultiModelLoaderFactory</code>的<code>build</code>函数如何创建<code>ModelLoader</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiModelLoaderFactory的build函数中的代码</span></span><br><span class="line">loaders.add(<span class="keyword">this</span>.&lt;Model, Data&gt;build(entry));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> Entry&lt;?, ?&gt; entry)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (ModelLoader&lt;Model, Data&gt;) Preconditions.checkNotNull(entry.factory.build(<span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>Entry</code>对象持有的<code>Factory</code>对象的<code>build</code>函数来创建<code>ModelLoader</code>实例。<code>Model</code>为<code>String.class</code>对应的<code>factory</code>为上面提到的4种<code>Factory</code>。</p>
<ul>
<li><code>DataUrlLoader.StreamFactory</code>：</li>
</ul>
<p><code>DataUrlLoader.StreamFacotry</code>的<code>build</code>函数是直接创建了<code>DataUrlLoader</code>对象，并将自身的<code>DataDecoder</code>对象<code>opener</code>作为参数传递给了<code>DataUrlLoader</code>构造函数。<code>DataUrlLoader</code>的<code>decode</code>函数对<code>String</code>进行合法检测，是否符合<code>base64 Image</code>的规范。</p>
<ul>
<li><code>StringLoader.StreamFactory()</code></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelLoader&lt;String, InputStream&gt; <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> MultiModelLoaderFactory multiFactory)</span> </span>{</span><br><span class="line">    <span class="comment">//StringLoader会将String转换成Uri,在代理给后面创建的Loader</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringLoader&lt;&gt;(multiFactory.build(Uri.class, InputStream.class));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>StringLoader.StreamFactory().build</code>又调用<code>MultiModelLoaderFactory</code>的<code>build</code>重载函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass, <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    List&lt;ModelLoader&lt;Model, Data&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> ignoredAnyEntries = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) {</span><br><span class="line">        ignoredAnyEntries = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(modelClass, dataClass)) {</span><br><span class="line">        alreadyUsedEntries.add(entry);</span><br><span class="line">        loaders.add(<span class="keyword">this</span>.&lt;Model, Data&gt;build(entry));</span><br><span class="line">        alreadyUsedEntries.remove(entry);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (loaders.size() &gt; <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> factory.build(loaders, throwableListPool);<span class="comment">//返回MutilModelLoader</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (loaders.size() == <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> loaders.get(<span class="number">0</span>);<span class="comment">//返回单独的ModelLoader</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (ignoredAnyEntries) {</span><br><span class="line">        <span class="keyword">return</span> emptyModelLoader();</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(modelClass, dataClass);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">    alreadyUsedEntries.clear();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，又是一个从<code>Entry</code>列表中查找<code>Entry</code>对象的过程，只不过这时的<code>modelClass</code>是<code>Uri.Class</code>,<code>dataClass</code>是<code>InputStream.Class</code>。会调用<code>Entry</code>的<code>handles</code>函数表示能否处理该类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150606.png" alt="image-20210331150606495"></p>
<p>所以这里返回的将是<code>StringLoader</code>实例，但该实例包含<code>MultiModelLoader</code>对象，该对象持有其他<code>ModelLoader</code>的列表。</p>
<ul>
<li><code>StringLoader.FileDescriptorFactory()</code></li>
</ul>
<p>这里的<code>FileDescriptorFactory</code>最终也在注册项中匹配到<code>model</code>是<code>Uri.class,data</code>是<code>ParcelFileDescriptor.class</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150852.png" alt="image-20210331150852806"></p>
<p>所以这里返回的也是<code>StringLoader</code>实例，该实例也包含包含<code>MultiModelLoader</code>对象，该对象持有其他<code>ModelLoader</code>的列表。</p>
<ul>
<li><code>StringLoader.AssetFileDescriptorFactory()</code></li>
</ul>
<p>这里的<code>FileDescriptorFactory</code>最终也在注册项中选择<code>model</code>是<code>Uri.class</code>,<code>data</code>是<code>AssetFileDescriptor.class</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150929.png" alt="image-20210331150929807"></p>
<p>所以这里返回的也是<code>StringLoader</code>实例，但该实例只包含<code>UriLoader</code>。</p>
<p><code>ModelLoader</code>小结一下:</p>
<p>在Glide创建时，会将Glide能处理的<code>modelClass</code>，<code>dataClass</code>，以及创建<code>Loader</code>的<code>Factory</code>封装成<code>Entry</code>保存<code>ModelLoaderRegistry</code>的工厂类<code>MultiModelLoaderFactory</code>中。在后面发起的Glide请求，根据<code>modelClass</code>去找到合适的<code>ModelLoader</code>,会通过<code>Entry</code>和<code>ModelLoader</code>的<code>handles</code>函数过滤掉不匹配的类型和不能处理具体内容的<code>ModelLoader</code>。</p>
<h3 id="modelloaderbuildloaddata"><a class="markdownIt-Anchor" href="#modelloaderbuildloaddata"></a> <code>modelLoader.buildLoadData</code></h3>
<p>再回到<code>ModelLoaderRegister</code>的<a href="#%60getModelLoaders%60"><code>getModelLoaders</code></a>函数中，获取到能处理<code>String.class</code>类型的<code>ModelLoaders</code>列表后，迭代列表，调用每个<code>ModelLoader</code>的<code>handles</code>函数，由于<code>StringLoader</code>都返回<code>true</code>,而<code>DataUrlLoader</code>需要判断String以<code>data:image</code>开头，所以这里返回的<code>ModelLoader</code>只有三个。再回到上层函数<code>getLoadData</code>中，迭代<code>modelLoaders</code>列表并调用<code>modelLoader.buildLoadData</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> String model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  Uri uri = parseUri(model);</span><br><span class="line">  <span class="keyword">if</span> (uri == <span class="keyword">null</span> || !uriLoader.handles(uri)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> uriLoader.buildLoadData(uri, width, height, options);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于<code>StringLoader</code>中<code>uriLoader</code>是<code>UriLoader</code>类型的实例，其<code>handles</code>函数判断条件，显然与我们的例子不符。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> Uri model)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> SCHEMES.contains(model.getScheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SCHEMES =</span><br><span class="line">    Collections.unmodifiableSet(</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(</span><br><span class="line">                ContentResolver.SCHEME_FILE,</span><br><span class="line">                ContentResolver.SCHEME_ANDROID_RESOURCE,</span><br><span class="line">                ContentResolver.SCHEME_CONTENT)))</span><br></pre></td></tr></tbody></table></figure>
<p>对于<code>StringLoader</code>中<code>uriLoader</code>是<code>MultiModelLoader</code>对象的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  Key sourceKey = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  List&lt;DataFetcher&lt;Data&gt;&gt; fetchers = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;Model, Data&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (modelLoader.handles(model)) {</span><br><span class="line">      LoadData&lt;Data&gt; loadData = modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="keyword">null</span>) {</span><br><span class="line">        sourceKey = loadData.sourceKey;</span><br><span class="line">        fetchers.add(loadData.fetcher);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> !fetchers.isEmpty() &amp;&amp; sourceKey != <span class="keyword">null</span></span><br><span class="line">      ? <span class="keyword">new</span> LoadData&lt;&gt;(sourceKey, <span class="keyword">new</span> MultiFetcher&lt;&gt;(fetchers, exceptionListPool))</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>即调用<code>MultiModelLoader</code>对象中<code>ModeLoader</code>列表中每个<code>modelLoader</code>的<code>handles</code>函数。返回的将是一个包含<code>MultiFetcher</code>的<code>LoadData</code>。而这里符合我们例子的是<code>StringLoader.StreamFactory()</code>对象<code>build</code>生成的<code>MultiModelLoader</code>对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150606.png" alt="image-20210331150606495"></p>
<p>在<code>MultiModelLoader</code>对象中<code>modelLoader</code>列表最后一项工厂<code>UrlUriLoader.StreamFactory</code>。看看<code>factory.build</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelLoader&lt;Uri, InputStream&gt; <span class="title">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UrlUriLoader&lt;&gt;(multiFactory.build(GlideUrl.class, InputStream.class));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>返回的是<code>UrlUriLoader</code>对象，其<code>handles</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> Uri uri)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> SCHEMES.contains(uri.getScheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SCHEMES =</span><br><span class="line">    Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"http"</span>, <span class="string">"https"</span>)));</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说可以处理我们的URL地址。看看其参数，又是找匹配的注册项，生成<code>ModelLoader</code>对象并赋值给<code>UrlUriLoader</code>对象的<code>urlLoader</code>变量。<code>UrlUriLoader</code>的<code>buildLoadData</code>函数是委托给<code>urlLoader</code>对象的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public LoadData&lt;Data&gt; buildLoadData(</span><br><span class="line">    @NonNull Uri uri, int width, int height, @NonNull Options options) {</span><br><span class="line">  GlideUrl glideUrl = new GlideUrl(uri.toString());</span><br><span class="line">  return urlLoader.buildLoadData(glideUrl, width, height, options);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见<code>LoadData</code>的<code>sourceKey</code>的值就是<code>mode</code>的值，这时是我们的<code>url</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331161732.png" alt="image-20210331161732384"></p>
<p>可见这里匹配到的<code>Loader</code>是<code>HttpGlideUrlLoader</code>。其<code>buildLoadData</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  <span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">  <span class="comment">// spent parsing urls.</span></span><br><span class="line">  GlideUrl url = model;</span><br><span class="line">  <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) {</span><br><span class="line">    url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br><span class="line">      modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">      url = model;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以<code>getLoadData</code>函数最终返回只有一个<code>LoadData</code>对象的列表。该对象的<code>DataFetcher</code>是<code>MultiFetcher</code>。<code>MultiFetcher</code>对象列表中只有<code>HttpUrlFetcher</code>对象。</p>
<p>所以步骤1，<code>getCacheKeys</code>函数返回的是是一个<code>GlideUrl</code>。回到<code>startNext</code>函数的步骤2。</p>
<h3 id="getregisteredresourceclasses"><a class="markdownIt-Anchor" href="#getregisteredresourceclasses"></a> <code>getRegisteredResourceClasses()</code></h3>
<p>接着<a href="#"><code>startNext</code></a>函数的<code>getRegisteredResourceClasses()</code>函数。</p>
<p><code>getRegisteredResourceClasses</code>函数先在缓存中获取，获取不到的话通过类似<code>getChacheKeys</code>函数的步骤去步骤获取。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Model, TResource, Transcode&gt; List&lt;Class&lt;?&gt;&gt; getRegisteredResourceClasses(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass) {</span><br><span class="line">  <span class="comment">//获取缓存结果</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; result =</span><br><span class="line">      modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">    result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取dataClass列表</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; dataClasses = modelLoaderRegistry.getDataClasses(modelClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; dataClass : dataClasses) {</span><br><span class="line">     	<span class="comment">//遍历每个dataClass对应的ResouceClass列表</span></span><br><span class="line">      List&lt;? extends Class&lt;?&gt;&gt; registeredResourceClasses =</span><br><span class="line">          decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">        <span class="comment">//迭代resourceClass列表去获取transcodeClassess</span></span><br><span class="line">        List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">            transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">         <span class="comment">//返回的transcodeClass列表有数据的resourceClass才添加在结果列表中。</span></span><br><span class="line">        <span class="keyword">if</span> (!registeredTranscodeClasses.isEmpty() &amp;&amp; !result.contains(registeredResourceClass)) {</span><br><span class="line">          result.add(registeredResourceClass);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    modelToResourceClassCache.put(</span><br><span class="line">        modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>ModelToResourceClassCache</code>类持持有<code>ArrayMap</code>类型的<code>registeredResourceClassCache</code>的变量，键值对为&lt;<code>MultiClassKey``List&lt;Class&gt;</code>&gt;，存取内容都是操作该变量的元素。而<code>MutilClassKey</code>则是以<code>modelClass</code>,<code>resourceClass</code>,<code>TranscodeClass</code>来作为<code>hash</code>,<code>equeas</code>函数计算的条件。</p>
<p>在没有缓存的情况，通过一下步骤获取：</p>
<h4 id="dataclass列表"><a class="markdownIt-Anchor" href="#dataclass列表"></a> <code>DataClass</code>列表</h4>
<ol>
<li>获取<code>DataClasses</code>列表</li>
</ol>
<p>通过<code>modelLoaderRegistry.getDataClasses</code>函数获取<code>dataClass</code>列表。<code>ModelLoaderRegistry</code>和<code>MultiModelLoaderFactory</code>在前面已经分析过了，这里快速过一遍。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelLoaderRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;Class&lt;?&gt;&gt; getDataClasses(<span class="meta">@NonNull</span> Class&lt;?&gt; modelClass) {</span><br><span class="line">  <span class="keyword">return</span> multiModelLoaderFactory.getDataClasses(modelClass);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//MultiModelLoaderFactory</span></span><br><span class="line"><span class="keyword">synchronized</span> List&lt;Class&lt;?&gt;&gt; getDataClasses(<span class="meta">@NonNull</span> Class&lt;?&gt; modelClass) {</span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">    <span class="keyword">if</span> (!result.contains(entry.dataClass) &amp;&amp; entry.handles(modelClass)) {</span><br><span class="line">      result.add(entry.dataClass);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是遍历<code>Entry</code>列表，判断<code>entry</code>能否处理<code>modelClass</code>，能的话加到列表<code>result</code>，迭代结束后返回<code>result</code>。按照我们的列子，返回的<code>dataClass</code>列表应该只有<code>InputStream.class</code>、<code>ParcelFileDescriptor.class</code>、<code>AssetFileDescriptor.class</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324110101.png" alt="image-20210324110054330"></p>
<h4 id="resourceclass列表"><a class="markdownIt-Anchor" href="#resourceclass列表"></a> <code>ResourceClass</code>列表</h4>
<ol start="2">
<li>获取<code>resourceClass</code>列表</li>
</ol>
<p>在<code>Registry</code>的构造函数中，创建<code>ResourceDecoderRegistry</code>对象之后，会调用<code>setResourceDecoderBucketPriorityList</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setResourceDecoderBucketPriorityList(</span><br><span class="line">  Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setBucketPriorityList</span><span class="params">(<span class="meta">@NonNull</span> List&lt;String&gt; buckets)</span> </span>{</span><br><span class="line">  List&lt;String&gt; previousBuckets = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketPriorityList);</span><br><span class="line">  bucketPriorityList.clear();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : buckets) {</span><br><span class="line">    bucketPriorityList.add(bucket);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (String previousBucket : previousBuckets) {</span><br><span class="line">    <span class="keyword">if</span> (!buckets.contains(previousBucket)) {</span><br><span class="line">      bucketPriorityList.add(previousBucket);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时<code>modifiedBuckets</code>列表的内容应该是[<code>BUCKET_PREPEND_ALL</code>,<code>BUCKET_GIF</code>, <code>BUCKET_BITMAP</code>, <code>BUCKET_BITMAP_DRAWABLE</code>,<code>BUCKET_APPEND_ALL</code>]，都是String元素，然后调用<code>ResourceDecoderRegistry</code>对象的<code>setBucketPriorityList</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ResourceDecoderRegistry#setBucketPriorityList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setBucketPriorityList</span><span class="params">(<span class="meta">@NonNull</span> List&lt;String&gt; buckets)</span> </span>{</span><br><span class="line">  List&lt;String&gt; previousBuckets = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketPriorityList);</span><br><span class="line">  bucketPriorityList.clear();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : buckets) {</span><br><span class="line">    bucketPriorityList.add(bucket);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (String previousBucket : previousBuckets) {</span><br><span class="line">    <span class="keyword">if</span> (!buckets.contains(previousBucket)) {</span><br><span class="line">      bucketPriorityList.add(previousBucket);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样就把<code>modifiedBuckets</code>列表的内容按序添加到了<code>bucketPriorityList</code>。这里主要在于添加顺序，从而更改不同的优先级。而在创建Glide时，也会将一些配置也会以<code>Entry</code>的形式注册到<code>ResourceDecoderRegistry</code>中。<code>ResourceDecoderRegistry</code>持有下面两个属性,<code>bucketPriorityList</code>用于保存前面提到的<code>String</code>类型的<code>BUCKET</code>，而<code>decoders</code>用于保存<code>Glide</code>的对<code>ResourceDecoderRegistry</code>的注册项。<code>Entry</code>持有的<code>Class</code>类型的<code>dataClass</code>,<code>resourceClass</code>和<code>ResourceDecoder</code>类型的<code>decoder</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;String&gt; bucketPriorityList = new ArrayList&lt;&gt;();</span><br><span class="line">private final Map&lt;String, List&lt;Entry&lt;?, ?&gt;&gt;&gt; decoders = new HashMap&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p>通过Excel文件来看看<code>ResourceCacheRegister</code>中的注册项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324205219.png" alt="image-20210324205014589"></p>
<p><code>resourceClass</code>只有<code>Bitmap.class</code>、<code>BitmapDrawable.class</code> 、<code>GifDrawable.class</code>，<code>Drawable.class</code>四种类型。</p>
<p>回到<code>getRegisteredResourceClasses()</code>函数，在获取<code>dataClass</code>列表后，调用了<code>decoderRegistry.getResourceClasses</code>函数获取<code>resourceClass</code>列表。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T, R&gt; List&lt;Class&lt;R&gt;&gt; getResourceClasses(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;T&gt; dataClass, <span class="meta">@NonNull</span> Class&lt;R&gt; resourceClass) {</span><br><span class="line">  List&lt;Class&lt;R&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : bucketPriorityList) {</span><br><span class="line">    List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket);</span><br><span class="line">    <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(dataClass, resourceClass)</span><br><span class="line">          &amp;&amp; !result.contains((Class&lt;R&gt;) entry.resourceClass)) {</span><br><span class="line">        result.add((Class&lt;R&gt;) entry.resourceClass);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getResourceClasses</code>函数中的<code>bucketPriorityList</code>的元素为key，遍历Entry列表，判断每个<code>Entry</code>实例能否处理该<code>dataClass</code>和<code>resourceClass</code>，能的话添加到<code>result</code>列表，并返回<code>result</code>。按照我们的列子，因为<code>dataClass</code>有<code>InputStream.class</code>、<code>ParcelFileDescriptor.class</code>、<code>AssetFileDescriptor.class</code>，而<code>resourceClass</code>是默认的<code>Object.class</code>。按照前面的注册项，再按key排序，这里返回<code>resourceClass</code>列表有[<code>GifDrawable.class</code>,<code>Bitmap.class</code>,<code>BitmapDrawable.class</code> ]</p>
<h4 id="transcodeclass列表"><a class="markdownIt-Anchor" href="#transcodeclass列表"></a> <code>TranscodeClass</code>列表</h4>
<ol start="3">
<li>获取<code>transcodeClass</code>列表</li>
</ol>
<p>同样``TranscoderRegistry<code>注册类会在</code>Registry<code>构造函数中被创建，在</code>Glide<code>构造函数中被装配。</code>TranscoderRegistry<code>只持有一个</code>Entry<code>的列表。</code>Entry<code>持有</code>Class<code>类型的</code>fromClass<code>,</code>toClass<code>和</code>ResourceTransocder<code>类型的</code>transcoder`。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Entry&lt;?, ?&gt;&gt; transcoders = new ArrayList&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p><code>Glide</code>构建过程会对``TranscoderRegistry`实例的注册项进行装配，通过Excel文件筛选。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324212620.png" alt="image-20210324212620640"></p>
<p>回到<code>getRegisteredResourceClasses()</code>函数，在获取<code>resourceClass</code>列表后通过<code>getTranscodeClasses</code>函数获取<code>transcodeClass</code>列表。函数参数<code>transcodeClass</code>可能是<code>Drawable.class</code>、<code>Bitmap.class</code>、<code>GifDrawable.class</code>，<code>File.class</code>。而在我们的例子中是默认的<code>Drawable.class</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Z, R&gt; List&lt;Class&lt;R&gt;&gt; getTranscodeClasses(<span class="meta">@NonNull</span> Class&lt;Z&gt; resourceClass, <span class="meta">@NonNull</span> Class&lt;R&gt; transcodeClass{</span><br><span class="line">  List&lt;Class&lt;R&gt;&gt; transcodeClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// transcodeClass是resourceClass的父类、父接口或者相同</span></span><br><span class="line">  <span class="keyword">if</span> (transcodeClass.isAssignableFrom(resourceClass)) {</span><br><span class="line">    transcodeClasses.add(transcodeClass);</span><br><span class="line">    <span class="keyword">return</span> transcodeClasses;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//遍历Entry列表,判断Entry能否处理转换，可以的话返回transcodeClass</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : transcoders) {</span><br><span class="line">    <span class="keyword">if</span> (entry.handles(resourceClass, transcodeClass)) {</span><br><span class="line">      transcodeClasses.add(transcodeClass);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> transcodeClasses;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>回到<code>Registry</code>的<code>getRegisteredResourceClasses</code>函数中获取<code>transcodeClass</code>列表之后，判断并添加到<code>result</code>列表中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">  				<span class="comment">//registeredResourceClass有Bitmap.class、BitmapDrawable.class、GifDrawable.class</span></span><br><span class="line">  				<span class="comment">//transcodeClass是Drawable.class</span></span><br><span class="line">         List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">             transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">         <span class="keyword">if</span> (!registeredTranscodeClasses.isEmpty() &amp;&amp; !result.contains(registeredResourceClass)) {</span><br><span class="line">           result.add(registeredResourceClass);</span><br><span class="line">         }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>
<p>所以<code>startNext</code>函数中返回的最终<code>resourceClass</code>列表是[<code>Bitmap.class</code>、<code>BitmapDrawable.class</code>、<code>GifDrawable.class</code>]</p>
<p>回到<a href="#%60startNext%60"><code>startNext</code></a>函数的步骤4。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">  resourceClassIndex++;</span><br><span class="line">  <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) {</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">  Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">  Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">  currentKey =</span><br><span class="line">      <span class="keyword">new</span> ResourceCacheKey( <span class="comment">// NOPMD AvoidInstantiatingObjectsInLoops</span></span><br><span class="line">          helper.getArrayPool(),</span><br><span class="line">          sourceId,</span><br><span class="line">          helper.getSignature(),</span><br><span class="line">          helper.getWidth(),</span><br><span class="line">          helper.getHeight(),</span><br><span class="line">          transformation,</span><br><span class="line">          resourceClass,</span><br><span class="line">          helper.getOptions());</span><br><span class="line">  cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">   <span class="comment">//找到了缓存文件后，且获取modelLoaders不为null，表明找到了最终合适的缓存，退出循环</span></span><br><span class="line">  <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">    sourceKey = sourceId;</span><br><span class="line">    modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">    modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>尝试遍历步骤1获取到的<code>Key</code>列表和步骤2获取到<code>resourceClass</code>列表的每个元素，以及其他元素，计算出<code>ResourceCacheKey</code>对象，然后通过</p>
<p><code>helper.getDiskCache().get(currentKey)</code>在磁盘缓存获取。</p>
<h3 id="disklrucache"><a class="markdownIt-Anchor" href="#disklrucache"></a> <code>DiskLruCache</code></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DiskCache <span class="title">getDiskCache</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> diskCacheProvider.getDiskCache();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过追溯<code>diskCacheProvider</code>来源，在<code>Engine</code>的<code>build</code>函数有如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DecodeJob&lt;R&gt; result = Preconditions.checkNotNull((DecodeJob&lt;R&gt;) pool.acquire());</span><br></pre></td></tr></tbody></table></figure>
<p>而<code>pool</code>则是Engine的静态内部类<code>DecodeJobFactory</code>的一个对象池。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Pools.Pool&lt;DecodeJob&lt;?&gt;&gt; pool =</span><br><span class="line">  FactoryPools.threadSafe(</span><br><span class="line">      JOB_POOL_SIZE,</span><br><span class="line">      <span class="keyword">new</span> FactoryPools.Factory&lt;DecodeJob&lt;?&gt;&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> DecodeJob&lt;?&gt; create() {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DecodeJob&lt;&gt;(diskCacheProvider, pool);</span><br><span class="line">        }</span><br><span class="line">      });</span><br></pre></td></tr></tbody></table></figure>
<p><code>DecodeJobFactory</code>的创建追溯到<code>Engine</code>的构造器中</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.diskCacheProvider = <span class="keyword">new</span> LazyDiskCacheProvider(diskCacheFactory)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decodeJobFactory == <span class="keyword">null</span>) {</span><br><span class="line">    decodeJobFactory = <span class="keyword">new</span> DecodeJobFactory(diskCacheProvider);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位到GlideBuider的build函数</span></span><br><span class="line"><span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) {</span><br><span class="line">  diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所有这里<code>diskCacheProvider</code>定位到时<code>LazyDiskCacheProvider</code>的实例，而factory是<code>InternalCacheDiskCacheFactory</code>。再查看其<code>getDiskCache</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LazyDiskCacheProvider</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiskCache <span class="title">getDiskCache</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">      <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">        diskCache = factory.build();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">        diskCache = <span class="keyword">new</span> DiskCacheAdapter();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> diskCache;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>先通过<code>factory.build</code>函数创建<code>diskCache</code>，创建失败则创建<code>DiskCacheAdapter</code>实例。定位到<code>InternalCacheDiskCacheFactory</code>类的父类<code>DiskLruCacheFactory</code>的<code>build</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DiskCache <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">  File cacheDir = cacheDirectoryGetter.getCacheDirectory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheDir.isDirectory() || cacheDir.mkdirs()) {</span><br><span class="line">    <span class="keyword">return</span> DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里<code>cacheDirectoryGetter</code>在<code>InternalCacheDiskCacheFactory</code>创建时被实例化，提供一个缓存文件，用于存取缓存资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName, <span class="keyword">long</span> diskCacheSize)</span> </span>{</span><br><span class="line">  <span class="keyword">super</span>(</span><br><span class="line">      <span class="keyword">new</span> CacheDirectoryGetter() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>{</span><br><span class="line">          File cacheDirectory = context.getCacheDir();</span><br><span class="line">          <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      diskCacheSize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是<code>factory.build</code>函数需要获取到<code>/data/data/&lt;application package&gt;/cache</code>目录才能进一步通过<code>DiskLruCacheWrapper.create(cacheDir, diskCacheSize)</code>创建<code>CacheFile</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DiskLruCacheWrapper</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.directory = directory;</span><br><span class="line">  <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">  <span class="keyword">this</span>.safeKeyGenerator = <span class="keyword">new</span> SafeKeyGenerator();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到这里，那么``getDiskCache<code>返回的就是</code>DiskLruCacheWrapper<code>对象，看看其</code>getDiskCache`函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DiskLruCache <span class="title">getDiskCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  <span class="keyword">if</span> (diskLruCache == <span class="keyword">null</span>) {</span><br><span class="line">    diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> diskLruCache;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，利用了<code>DisLruChache</code>来缓存资源。</p>
<p>假如<code>factory.build</code>返回是<code>null</code>,那么<code>getDiskCache</code>返回的是<code>DiskCacheAdapter</code>。</p>
<h3 id="helpergetmodelloaders"><a class="markdownIt-Anchor" href="#helpergetmodelloaders"></a> <code>helper.getModelLoaders</code></h3>
<p>假设获取到了<code>cacheFile</code>，看看<code>helper.getModelLoaders(cacheFile)</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeHelper</span></span><br><span class="line">List&lt;ModelLoader&lt;File, ?&gt;&gt; getModelLoaders(File file)</span><br><span class="line">    <span class="keyword">throws</span> Registry.NoModelLoaderAvailableException {</span><br><span class="line">  <span class="keyword">return</span> glideContext.getRegistry().getModelLoaders(file);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Register</span></span><br><span class="line"><span class="keyword">public</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> Model model) {</span><br><span class="line">  <span class="keyword">return</span> modelLoaderRegistry.getModelLoaders(model);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//ModelLoaderRegister</span></span><br><span class="line"><span class="keyword">public</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> A model) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; modelLoaders = getModelLoadersForClass(getClass(model));</span><br><span class="line">  <span class="keyword">if</span> (modelLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; filteredLoaders = Collections.emptyList();</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;A, ?&gt; loader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (loader.handles(model)) {</span><br><span class="line">      <span class="keyword">if</span> (isEmpty) {</span><br><span class="line">        filteredLoaders = <span class="keyword">new</span> ArrayList&lt;&gt;(size - i);</span><br><span class="line">        isEmpty = <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      filteredLoaders.add(loader);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (filteredLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model, modelLoaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> filteredLoaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>helper.getModelLoaders(cacheFile)</code>函数最终还是调用了<code>ModelLoaderRegister.getModelLoaders</code>函数，和前面分析得<code>getChacheKeys</code>是一致的，只是这里<code>model</code>是<code>File.class</code>。所以直接找到相关注册项。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.append(File.class, ByteBuffer.class, <span class="keyword">new</span> ByteBufferFileLoader.Factory())</span><br><span class="line">.append(File.class, InputStream.class, <span class="keyword">new</span> FileLoader.StreamFactory())</span><br><span class="line">.append(File.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileLoader.FileDescriptorFactory())</span><br><span class="line"><span class="comment">// Compilation with Gradle requires the type to be specified for UnitModelLoader here.</span></span><br><span class="line">.append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance())</span><br></pre></td></tr></tbody></table></figure>
<p>所以步骤3得到的<code>modelLoaders</code>列表为[<code>ByteBufferFileLoader</code>,<code>FileLoader&lt;InputStream&gt;</code>,<code>FileLoader&lt;ParcelFileDescriptor&gt;</code>,<code>UnitModelLoader</code>]</p>
<p>接下来步骤4，根据遍历<code>modelLoaders</code>列表的每个<code>ModelLoader</code>对象,尝试加载数据，直到找到第一个能处理该Glide请求的<code>ModelLoader</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loadData = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">  ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">  loadData =</span><br><span class="line">      modelLoader.buildLoadData(</span><br><span class="line">          cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">  <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">    loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>看一下四个匹配到的<code>ModelLoader</code>的<code>buildLoadData</code>函数返回的<code>LoadData</code>对象中的<code>DataFetcher</code>对象<code>fetcher</code>。</p>
<ul>
<li>
<p><code>ByteBufferFileLoader</code></p>
<p>返回的<code>LoadDadata</code>中的是<code>ByteBufferFetcher(file)</code>,其<code>getDataClass</code>函数返回<code>ByteBuffer.class</code>。</p>
</li>
<li>
<p><code>FileLoader.StreamFactory()</code></p>
<p>返回的<code>LoadDadata</code>中的是<code>FileFetcher&lt;&gt;(model, fileOpener)</code>,<code>fileOpener</code>是<code>FileOpener&lt;InputStream&gt;</code>类型，其<code>getDataClass</code>函数返回<code>InputStream.class</code></p>
</li>
<li>
<p><code>FileLoader.FileDescriptorFactory()</code></p>
<p>返回的<code>LoadDadata</code>中的是<code>FileFetcher&lt;&gt;(model, fileOpener))</code>,<code>fileOpener</code>是<code>FileOpener&lt;ParcelFileDescriptor&gt;</code>类型，其<code>getDataClass</code>函数返回<code>ParcelFileDescriptor.class</code></p>
</li>
<li>
<p><code>UnitModelLoader</code></p>
<p>返回的<code>LoadDadata</code>中的是<code>UnitFetcher(file)</code>,其<code>getDataClass</code>函数返回<code>File.class</code>。</p>
</li>
</ul>
<p>接下来看看<code>helper.hasLoadPath(loadData.fetcher.getDataClass())</code>这个函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeHelper</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLoadPath</span><span class="params">(Class&lt;?&gt; dataClass)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> getLoadPath(dataClass) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;Data&gt; LoadPath&lt;Data, ?, Transcode&gt; getLoadPath(Class&lt;Data&gt; dataClass) {</span><br><span class="line">  <span class="keyword">return</span> glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Register</span></span><br><span class="line"><span class="keyword">public</span> &lt;Data, TResource, Transcode&gt; <span class="function">LoadPath&lt;Data, TResource, Transcode&gt; <span class="title">getLoadPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass)</span> </span>{</span><br><span class="line">  <span class="comment">//先从缓存获取</span></span><br><span class="line">  LoadPath&lt;Data, TResource, Transcode&gt; result =</span><br><span class="line">      loadPathCache.get(dataClass, resourceClass, transcodeClass);</span><br><span class="line">  <span class="keyword">if</span> (loadPathCache.isEmptyLoadPath(result)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果LoadPath是NO_PATHS_SIGNAL</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="keyword">null</span>) {<span class="comment">//缓存没有，则创建</span></span><br><span class="line">    List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths =</span><br><span class="line">        getDecodePaths(dataClass, resourceClass, transcodeClass);</span><br><span class="line">    <span class="keyword">if</span> (decodePaths.isEmpty()) {</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      result =</span><br><span class="line">          <span class="keyword">new</span> LoadPath&lt;&gt;(</span><br><span class="line">              dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);</span><br><span class="line">    }</span><br><span class="line">    loadPathCache.put(dataClass, resourceClass, transcodeClass, result);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以主要看下<code>getDecodePath</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> &lt;Data, TResource, Transcode&gt; List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; getDecodePaths(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass) {</span><br><span class="line">  List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;Class&lt;TResource&gt;&gt; registeredResourceClasses =</span><br><span class="line">      decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Class&lt;TResource&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">    List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">        transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;Transcode&gt; registeredTranscodeClass : registeredTranscodeClasses) {</span><br><span class="line"></span><br><span class="line">      List&lt;ResourceDecoder&lt;Data, TResource&gt;&gt; decoders =</span><br><span class="line">          decoderRegistry.getDecoders(dataClass, registeredResourceClass);</span><br><span class="line">      ResourceTranscoder&lt;TResource, Transcode&gt; transcoder =</span><br><span class="line">          transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);</span><br><span class="line">      <span class="meta">@SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")</span></span><br><span class="line">      DecodePath&lt;Data, TResource, Transcode&gt; path =</span><br><span class="line">          <span class="keyword">new</span> DecodePath&lt;&gt;(</span><br><span class="line">              dataClass,</span><br><span class="line">              registeredResourceClass,</span><br><span class="line">              registeredTranscodeClass,</span><br><span class="line">              decoders,</span><br><span class="line">              transcoder,</span><br><span class="line">              throwableListPool);</span><br><span class="line">      decodePaths.add(path);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> decodePaths;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getDecodePaths</code>函数中几个函数已经分析过了，说一下大概逻辑，<code>resourceClass=Object.class</code>、<code>transcodeClass=Drawable.class</code>。从<code>ModelLoader</code>列表开始，第一个<code>dataClass</code>取<code>ByteBufferFileLoader</code>的<code>ByteBuffer.class</code>。</p>
<ol>
<li>
<p>先通过<code>dataClass</code>和<code>resourceClass</code>去获取<code>registerResourceClass</code>列表。利用前面整理的Excel文件，筛选一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324205726.png" alt="image-20210324205726342"></p>
<p>去掉重复的，再根据<code>Key</code>的优先级排序，那么得到的<code>registerResourceClass</code>=[<code>GifDrawable.class</code>，<code>Bitmap.class</code>、<code>BitmapDrawable.class</code>]</p>
</li>
<li>
<p>遍历<code>registerResourceClass</code>列表，通过<code>registeredResourceClass</code>和<code>transcodeClass</code>获取<code>registeredTranscodeClasses</code>列表。</p>
<p>由于是遍历<code>registerResourceClass</code>列表，将会生成三个<code>registeredTranscodeClasses</code>列表。根据<code>transcoderRegistry.getTranscodeClasses</code>函数内容的处理规则，这个三个列表是相同的，且只持有一个<code>Drawable.class</code>元素。</p>
</li>
<li>
<p>然后再迭代每个<code>registeredTranscodeClasses</code>列表。</p>
<p>根据<code>dataClass</code>和<code>registeredResourceClass</code>获取<code>decoders</code>列表。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T, R&gt; List&lt;ResourceDecoder&lt;T, R&gt;&gt; getDecoders(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;T&gt; dataClass, <span class="meta">@NonNull</span> Class&lt;R&gt; resourceClass) {</span><br><span class="line">  List&lt;ResourceDecoder&lt;T, R&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : bucketPriorityList) {</span><br><span class="line">    List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket);</span><br><span class="line">    <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(dataClass, resourceClass)) {</span><br><span class="line">        result.add((ResourceDecoder&lt;T, R&gt;) entry.decoder);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>根据<code>registeredResourceClass</code>和<code>registeredTranscodeClass</code>获取<code>transcoder</code>列表</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Z, R&gt; <span class="function">ResourceTranscoder&lt;Z, R&gt; <span class="title">get</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Z&gt; resourceClass, <span class="meta">@NonNull</span> Class&lt;R&gt; transcodedClass)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (transcodedClass.isAssignableFrom(resourceClass)) {</span><br><span class="line">    <span class="keyword">return</span> (ResourceTranscoder&lt;Z, R&gt;) UnitTranscoder.get();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : transcoders) {</span><br><span class="line">    <span class="keyword">if</span> (entry.handles(resourceClass, transcodedClass)) {</span><br><span class="line">      <span class="keyword">return</span> (ResourceTranscoder&lt;Z, R&gt;) entry.transcoder;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">      <span class="string">"No transcoder registered to transcode from "</span> + resourceClass + <span class="string">" to "</span> + transcodedClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>ResourceRegister.getDecoders</code>函数和<code>TranscodeRegister.get</code>函数逻辑，再加上整理出的Excel表格，可以得出<code>decoders</code>列表和<code>transcoders</code>列表内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324223542.png" alt="image-20210324223542318"></p>
<p>然后包装成<code>DecodePath</code>元素，添加到<code>decodePaths</code>列表中。最后将<code>decodePaths</code>列表返回。也就是图中三条横线边框就是三条<code>DecodePath</code>,这个方框就是<code>decodePaths</code>。</p>
</li>
</ol>
<p>回到<code>startNext</code>函数的步骤4中的<code>helper.hasLoadPath(loadData.fetcher.getDataClass())</code>返回true，然后调用<code>fetcher.loadData</code>函数加载数据。</p>
<h3 id="fetcherloaddata"><a class="markdownIt-Anchor" href="#fetcherloaddata"></a> <code>fetcher.loadData</code></h3>
<p>这里的<code>fetcher</code>通过上面的分析就是<code>ByteBufferFetcher</code>。查看<code>loadData</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> ByteBuffer&gt; callback)</span> </span>{</span><br><span class="line">  ByteBuffer result;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    result = ByteBufferUtil.fromFile(file);</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to obtain ByteBuffer for file"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>ByteBufferUtil.fromFile(file)</code>正常的文件读取操作获取<code>ByteBuffer</code>数据。然后通过<code>callback.onDataReady(result)</code>回调。<code>ResourceCacheGenerator.startNext</code>函数也到此结束，完结撒花。</p>
<h3 id="resoucrcachegenerator小结"><a class="markdownIt-Anchor" href="#resoucrcachegenerator小结"></a> <code>ResoucrCacheGenerator</code>小结</h3>
<p><code>ResoucrCacheGenerator</code>主要通过<code>DataFetcher</code>从缓存文件获取采样和转化的数据资源。其<code>startNext</code>函数主要是通过<code>modelClass</code>和<code>resourceClass</code>、<code>transcodeClass</code>去获取合适的<code>modelLoader</code>、<code>decoder</code>和<code>transcoder</code>，并构成<code>DecodePaths</code>。这样在回调中，就可以通过这些<code>Paths</code>寻找到合适的去加载数据并采样，转化资源。</p>
<h2 id="datacachegenerator"><a class="markdownIt-Anchor" href="#datacachegenerator"></a> <code>DataCacheGenerator</code></h2>
<p>初始加载，那么<code>ResoucrCacheGenerator.startNext</code>函数将返回<code>false</code>,回到<code>DecodeJob</code>的<code>runGenerators</code>函数。此时获取到下一个Stage是<code>Stage.DATA_CACHE</code>，Generator是<code>DataCacheGenerator</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void runGenerators() {</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  boolean isStarted = false;</span><br><span class="line">  while (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != null</span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) {</span><br><span class="line">    stage = getNextStage(stage);//这里返回将是Stage.DATA_CACHE</span><br><span class="line">    currentGenerator = getNextGenerator();//这里返回的将是DataCacheGenerator</span><br><span class="line"></span><br><span class="line">    if (stage == Stage.SOURCE) {</span><br><span class="line">      reschedule();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {</span><br><span class="line">    notifyFailed();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void reschedule() {</span><br><span class="line">  runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">  callback.reschedule(this);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>查看<code>DataCacheGenerator</code>的<code>startNext</code>函数。由于前面分析了<code>ResourceCacheGenerator</code>，所以下接下来回轻松很多。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">    Key originalKey = <span class="keyword">new</span> DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">    <span class="comment">//获取缓存文件</span></span><br><span class="line">    cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(</span><br><span class="line">            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>ResourceCacheGenerator</code>查找到的<code>cacheKeys</code>会保存在<code>DecodeHelper</code>中，避免每次都需要重新寻找。<code>DataCacheGenerator</code>的主要作用从缓存资源中获取原始数据，其<code>startNext</code>函数与ResocurceCacheGenerator非常相似，这里不作展开。</p>
<h2 id="sourcegeneator"><a class="markdownIt-Anchor" href="#sourcegeneator"></a> <code>SourceGeneator</code></h2>
<p>回到<code>DecodeJob</code>的<code>runGenerators</code>函数，那么将执行<code>SourceGenerator</code>函数，从数据来源获取数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) {</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      startNextLoad(loadData);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在前面分析中，<code>helper.getLoadData()</code>这里返回的是<code>LoadData</code>列表只有一个<code>LoadData</code>元素，而且其<code>DataFetcher</code>是<code>MultiFetcher</code>对象。且<code>MultiFetcher</code>对象持有<code>HttpUrlFetcher</code>对象。</p>
<p>再看上面代码，<code>helper.getDiskCacheStrategy().isDataCacheable</code>函数，默认情况下<code>DiskCacheStrategy</code>是<code>AUTOMATIC</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataCacheable</span><span class="params">(DataSource dataSource)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> dataSource == DataSource.REMOTE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再看<code>MultiFetcher</code>的<code>getDataSource</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> fetchers.get(<span class="number">0</span>).getDataSource();</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>HttpUrlFetcher</code>的<code>getDataSource</code>函数，其返回的也是<code>DataSource.REMOTE</code>,所以该条件成立。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> DataSource.REMOTE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而<code>getDataClass</code>返回的是<code>InputStream.class</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;InputStream&gt; <span class="title">getDataClass</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> InputStream.class;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="startnextloadloaddata"><a class="markdownIt-Anchor" href="#startnextloadloaddata"></a> <code>startNextLoad(loadData)</code></h3>
<p>查看<code>startNextLoad(loadData)</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> </span>{</span><br><span class="line">  loadData.fetcher.loadData(</span><br><span class="line">      helper.getPriority(),</span><br><span class="line">      <span class="keyword">new</span> DataCallback&lt;Object&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> </span>{</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) {</span><br><span class="line">            onDataReadyInternal(toStart, data);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>{</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) {</span><br><span class="line">            onLoadFailedInternal(toStart, e);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>MultiFetcher</code>的<code>loadData</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> Data&gt; callback)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.priority = priority;</span><br><span class="line">  <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  exceptions = throwableListPool.acquire();</span><br><span class="line">  fetchers.get(currentIndex).loadData(priority, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isCancelled) {</span><br><span class="line">    cancel();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>HttpUrlFetcher</code>的<code>loadData</code>函数。在<code>loadData</code>函数中，获取输入流无论成功与败将通过<code>callback</code>回掉通知。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>{</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {</span><br><span class="line">      Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见调用了<code>loadDataWithRedirects</code>函数并返回了数据。<code>loadDataWithRedirects</code>函数主要是通过<code>HttpURLConnection</code>来进行网络请求，并获取数据。同时也允许重定向，但次数不能超过5次。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    URL url, <span class="keyword">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  <span class="comment">//重定向次数大于5抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Too many (&gt; "</span> + MAXIMUM_REDIRECTS + <span class="string">") redirects!"</span>, INVALID_STATUS_CODE);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">//步骤1：创建HttpUrlConnection</span></span><br><span class="line">  urlConnection = buildAndConfigureConnection(url, headers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//连接网络并获取输入流</span></span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Failed to connect or obtain data"</span>, getHttpStatusCodeOrInvalid(urlConnection), e);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCancelled) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = getHttpStatusCodeOrInvalid(urlConnection);</span><br><span class="line">  <span class="keyword">if</span> (isHttpOk(statusCode)) {<span class="comment">//连接成功回调</span></span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) {<span class="comment">//重定向</span></span><br><span class="line">    String redirectUrlString = urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Received empty or null redirect url"</span>, statusCode);</span><br><span class="line">    }</span><br><span class="line">    URL redirectUrl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">    } <span class="keyword">catch</span> (MalformedURLException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Bad redirect url: "</span> + redirectUrlString, statusCode, e);</span><br><span class="line">    }</span><br><span class="line">    cleanup();</span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == INVALID_STATUS_CODE) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Failed to get a response message"</span>, statusCode, e);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>步骤1：通过<code>connectionFactory.build</code>函数创建了<code>HttpURLConenction</code>实例，并配置了相关信息。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HttpURLConnection <span class="title">buildAndConfigureConnection</span><span class="params">(URL url, Map&lt;String, String&gt; headers)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  HttpURLConnection urlConnection;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"URL.openConnection threw"</span>, <span class="comment">/*statusCode=*/</span> <span class="number">0</span>, e);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {</span><br><span class="line">    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">  }</span><br><span class="line">  urlConnection.setConnectTimeout(timeout);</span><br><span class="line">  urlConnection.setReadTimeout(timeout);</span><br><span class="line">  urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">  urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">  urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> urlConnection;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的<code>ConnectionFactory</code>实例我们使用了默认的<code>DefaultHttpUrlConnectionFactory</code>。其<code>build</code>函数通过<code>Url.openConnection</code>返回了一个网络连接。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpURLConnection <span class="title">build</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  <span class="keyword">return</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在判断请求成功，通过<code>getStreamForSuccessfulRequest</code>函数去获取输入流。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">getStreamForSuccessfulRequest</span><span class="params">(HttpURLConnection urlConnection)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(urlConnection.getContentEncoding())) {</span><br><span class="line">      <span class="keyword">int</span> contentLength = urlConnection.getContentLength();</span><br><span class="line">      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">        Log.d(TAG, <span class="string">"Got non empty content encoding: "</span> + urlConnection.getContentEncoding());</span><br><span class="line">      }</span><br><span class="line">      stream = urlConnection.getInputStream();</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Failed to obtain InputStream"</span>, getHttpStatusCodeOrInvalid(urlConnection), e);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到这里，也就从网络获取到图片的输入流，我们到此告一段落。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>把Glide数据来源整理一下，也是Glide的缓存机制。接下来的章节也将继续分析下图的问号？</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210402165140.png" alt="未命名绘图"></p>
<p>缓存总的来说应该只有内存缓存和硬盘缓存。而Glide在两个缓存上再各细分出两个缓存，总得来说就有四个缓存了。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a class="post-meta__tags" href="/tags/Glide/">Glide</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/06/EventBus%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>EventBus 源码分析</span></a></div><div class="next-post pull-right"><a href="/2021/03/29/Glide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/"><span>Glide 源码分析之流程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>