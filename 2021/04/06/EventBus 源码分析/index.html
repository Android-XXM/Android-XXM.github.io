<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="EventBus 源码分析"><meta name="keywords" content="源码分析,EventBus"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>EventBus 源码分析 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text"> 摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eventbusgetdefault"><span class="toc-number">3.</span> <span class="toc-text"> EventBus.getDefault</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#register"><span class="toc-number">4.</span> <span class="toc-text"> register</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#findsubscribermethods"><span class="toc-number">4.0.1.</span> <span class="toc-text"> findSubscriberMethods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findusinginfo"><span class="toc-number">4.0.2.</span> <span class="toc-text"> findUsingInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getsubscriberinfo"><span class="toc-number">4.0.3.</span> <span class="toc-text"> getSubscriberInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findusingreflectioninsingleclass"><span class="toc-number">4.0.4.</span> <span class="toc-text"> findUsingReflectionInSingleClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movetosuperclass"><span class="toc-number">4.0.5.</span> <span class="toc-text"> moveToSuperclass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subscribe"><span class="toc-number">4.0.6.</span> <span class="toc-text"> subscribe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unregister"><span class="toc-number">5.</span> <span class="toc-text"> unregister</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#post"><span class="toc-number">6.</span> <span class="toc-text"> Post</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#posttosubscription"><span class="toc-number">6.1.</span> <span class="toc-text"> postToSubscription</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mainthreadposter"><span class="toc-number">6.2.</span> <span class="toc-text"> MainThreadPoster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handlemessage"><span class="toc-number">6.3.</span> <span class="toc-text"> handleMessage</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%8F%E6%80%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text"> 黏性事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">8.</span> <span class="toc-text"> 优先权</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">9.</span> <span class="toc-text"> 线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#backgroundposter"><span class="toc-number">9.1.</span> <span class="toc-text"> BackgroundPoster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asyncposter"><span class="toc-number">9.2.</span> <span class="toc-text"> AsyncPoster</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">EventBus 源码分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 21 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1>
<p>本文分析Android主流的事件框架<code>EventBus</code>，尤其在不同的界面触发函数的调用，避免层层嵌套回调。通过源码分析，了解<code>EventBus</code>如何查找订阅方法，切换线程，发布事件的原理。</p>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>我们将根据下面的例子来分析<code>EventBus</code>的源码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() {</span><br><span class="line">    <span class="keyword">private</span> val TAG = <span class="string">"MainActivity"</span></span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">        EventBus.getDefault().post(<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line">    <span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function">override fun <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="eventbusgetdefault"><a class="markdownIt-Anchor" href="#eventbusgetdefault"></a> <code>EventBus.getDefault</code></h1>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>{</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) {</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过双重检查单例模式创建<code>EventBus</code>单例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) {</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//通过事件类型获取所有订阅信息</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//通过订阅类获取该订阅类中所有的事件类型</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();<span class="comment">//支持Android主线程</span></span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;<span class="comment">//Handler子类</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">//用于寻找订阅类中的订阅方法</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>DEFAULT_BUILDER</code>是<code>EventBusBuilder</code>的实例，所有配置都采用默认值。这里涉及到几个主要对象的创建，例如<code>HandlerPoster</code>对象<code>mainThreadPoster</code>,其实是用来切换到主线程的。</p>
<h1 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h1>
<p>接着我们看<code>EventBus</code>如何将一个类与订阅事件绑定。查看<code>EventBus</code>的<code>register</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) {</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>register</code>函数通过<code>SubscriberMethodFinder</code>对象<code>findSubscriberMethods</code>函数，获取当前订阅类所有的订阅方法<code>subscriberMethods</code>。然后遍历所有订阅方法<code>SubscriberMethod</code>，然后调用<code>subscribe</code>函数，将当前订阅类和订阅方法进行绑定。</p>
<h3 id="findsubscribermethods"><a class="markdownIt-Anchor" href="#findsubscribermethods"></a> <code>findSubscriberMethods</code></h3>
<p>我们查看<code>SubscriberMethodFinder</code>对象如何通过<code>findSubscriberMethod</code>函数如何寻找当前订阅类中合法的订阅方法，并封装成<code>SubscriberMethod</code>实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">  	<span class="comment">//先通过缓存获取该订阅类是否解析过（例如Activity销毁后，重新进入）</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) {<span class="comment">//默认false</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的<code>METHOD_CACHE</code>是<code>ConcurrentHashMap</code>类型,键值对分别是<code>Class&lt;?&gt;, List&lt;SubscriberMethod&gt;</code>,也就是<code>findSubscriberMethods</code>函数会查找订阅方法，然后缓存到<code>METHOD_CACHE</code>中，下次优先通过通过缓存查找。初次注册，那肯定是没有缓存。<code>ignoreGeneratedIndex</code> 默认情况下是<code>flase</code>，所以会调用<code>findUsingInfo(subscriberClass)</code>查找类中的注册方法。</p>
<h3 id="findusinginfo"><a class="markdownIt-Anchor" href="#findusinginfo"></a> <code>findUsingInfo</code></h3>
<p><code>findUsingInfo</code>函数会将相关的信息封装到<code>FindState</code>对象，最后获取到订阅方法<code>SubscriberMethod</code>列表后释放<code>FindState</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) {</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) {</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) {</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        }</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>prepareFindState</code>函数返回了<code>FindState</code>对象，该函数主要遍历大小为4的<code>FIND_STATE_POOL</code>数组，取第一个不为<code>null</code>的<code>FindState</code>对象,并将数组该位置引用置为<code>null</code>，如果数组不存在元素，则直接新建一个<code>FindState</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            FindState state = FIND_STATE_POOL[i];</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="keyword">null</span>) {</span><br><span class="line">                FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后调用<code>FindState</code>对象的<code>initForSubscriber</code>函数。将当前订阅类类型赋值<code>FindState</code>对象的<code>subscriberClass</code>和<code>clazz</code>变量。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">    skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">    subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>回到<a href="#"><code>findUsingInfo</code></a>函数，由于<code>clazz</code>被赋值为<code>subscriberClass</code>,所以<code>while</code>循环为<code>ture</code>。接着调用了<code>getSubscriberInfo(findState)</code>函数。</p>
<h3 id="getsubscriberinfo"><a class="markdownIt-Anchor" href="#getsubscriberinfo"></a> <code>getSubscriberInfo</code></h3>
<p>在<code>getSubscriberInfo(findState)</code>函数中，由于第一次注册该类，所以<code>FindState</code>对象的<code>subscriberInfo=null</code>。而<code>subscriberInfoIndexes</code>在<code>SubscriberMethodFinder</code>实例创建的时候传递进来。<code>subscriberInfoIndexes</code>是通过<code>EventBusBuilder</code>传递进来的，默认为<code>null</code>。所以<code>getSubscriberInfo</code>函数返回了<code>null</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) {</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) {</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) {</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="findusingreflectioninsingleclass"><a class="markdownIt-Anchor" href="#findusingreflectioninsingleclass"></a> <code>findUsingReflectionInSingleClass</code></h3>
<p>回到[<code>findUsingInfo</code>](#  <code>findUsingInfo</code>)函数中，由于<code>findState.subscriberInfo=null,</code>将执行<code>findUsingReflectionInSingleClass(findState)</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable th) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">        } <span class="keyword">catch</span> (LinkageError error) { </span><br><span class="line">           ...</span><br><span class="line">        }</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;<span class="comment">//该标志位会在moveToSuperclass函数用到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) {</span><br><span class="line">      	<span class="comment">//获取方法修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">      	<span class="comment">//public修饰且非编译器生成</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) {</span><br><span class="line">          	<span class="comment">//获取所有参数类型</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) {<span class="comment">//参数长度为1</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) {<span class="comment">//方法被Subscribe注解</span></span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) {</span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getDeclaredMethods</code>函数是获取订阅类自身声明的所有方法，包括<code>public</code>、<code>protected</code>、<code>private</code>方法,而<code>getMethods</code>函数是类所有公共方法，自身、父类和接口的公共方法。如果前者抛出异常，将采用后者，并设置<code>findState.skipSuperClasses = true</code>。</p>
<p>接着遍历所有获取的方法，访问方法的修饰符。判断条件<code>(modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0</code>表示当前方法是<code>public</code>修饰符且不是编译器生成的。然后通过<code>method.getParameterTypes()</code>函数，获取方法的参数类型列表，这里只是用来判断参数的数量，当参数数量为1才继续下一步。</p>
<p>然后通过<code>method.getAnnotation(Subscribe.class)</code>函数判断方法被<code>Subscribe</code>注解着。然后调用了<code>FindState</code>对象的<code>checkAdd</code>函数，将方法<code>method</code>和事件类型<code>eventType</code>（参数类型）作为参数传递 。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">    Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) {</span><br><span class="line">            <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            }</span><br><span class="line">            anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>anyMethodByEventType</code>是<code>HashMap</code>类型，键值对是<code>&lt;Class, Object&gt;</code>。将注解类型和方法<code>put</code>到<code>anyMethodByEventType</code>，如果返回<code>null</code>，说明该类只有一个参数的类型为该<code>eventType</code>的方法，没有冲突，直接返回<code>ture</code>。如果返回了<code>existing</code>对象不为<code>null</code>，说明类中已经找到了相同参数类型的方法，进一步检查方法签名。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">    String methodKey = methodKeyBuilder.toString();<span class="comment">//methodName&gt;paramTypeName</span></span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass();<span class="comment">//获取方法所在的类</span></span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>checkAddWithMethodSignature</code>函数通过<code>put</code>元素到<code>subscriberClassByMethodKey</code>来判断前面是否有已存在的方法，<code>subscriberClassByMethodKey</code>也是<code>HashMap</code>类型，键值对是<code>Map&lt;String, Class&gt;</code>。其<code>put</code>函数返回<code>null</code>表明前面没有签名（<code>methodName&gt;paramTypeName</code>）相同的方法,或者存在且其值是当前订阅类的父类，父接口或者相同类。</p>
<p>因此<code>checkAdd</code>函数也称为第二层检查<code>EventBus</code>中类的合法注册。<code>checkAdd</code>函数返回<code>true</code>之后，将相关信息封装到<code>SubscriberMethod</code>对象中，并添加到<code>findState.subscriberMethods</code>列表中。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br></pre></td></tr></tbody></table></figure>
<p>**到这里确定了如何注解一个合法的方法： **</p>
<ul>
<li>注解方法必须是<code>public</code>修饰且非编译器生成，只有一个参数,并且<code>Subscribe</code>注解该方法</li>
<li>不存在相同签名（<code>methodName&gt;paramTypeName</code>）</li>
<li>若已存在的注册类则得是方法所在的类或者父类</li>
</ul>
<h3 id="movetosuperclass"><a class="markdownIt-Anchor" href="#movetosuperclass"></a> <code>moveToSuperclass</code></h3>
<p>回到<a href="#"><code>findUsingInfo</code></a>函数。调用了<code>FindState</code>对象的<code>moveToSuperclass</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (skipSuperClasses) {<span class="comment">//findUsingReflectionInsingleClass函数，默认情况getDeclaredMethods函数获取当前类自身声明方法，发生异常情况下调用getMethods函数获取所有方法，会将skipSuperClasses设为true</span></span><br><span class="line">        clazz = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">        String clazzName = clazz.getName();</span><br><span class="line">        <span class="comment">//如果当前类是系统类，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) || clazzName.startsWith(<span class="string">"javax."</span>) ||</span><br><span class="line">                clazzName.startsWith(<span class="string">"android."</span>) || clazzName.startsWith(<span class="string">"androidx."</span>)) {</span><br><span class="line">            clazz = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意到这里还在<code>while</code>循环中，正常情况<code>skipSuperClasses=true</code>,<code>clazz</code>将赋值为当前订阅类的父类，然后重复寻找父类的订阅方法。</p>
<p><a href="#"><code>findUsingInfo</code></a>函数最后调用了<code>getMethodsAndRelease</code>函数返回<code>SubscriberMethod</code>列表，将<code>FindState</code>对象进行回收。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">    findState.recycle();</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) {</span><br><span class="line">                FIND_STATE_POOL[i] = findState;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="subscribe"><a class="markdownIt-Anchor" href="#subscribe"></a> <code>subscribe</code></h3>
<p>回到<code>register</code>函数。寻找到<code>SubscriberMethod</code>列表后，会遍历每个<code>SubscribeMethod</code>，并调用<code>subscribe</code>函数，将订阅者与订阅方法绑定。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">  	<span class="comment">//通过参数类型获取已存在的订阅信息</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) {</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">		<span class="comment">//将方法的订阅信息添加到subscriptions列表合适的位置，</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) {</span><br><span class="line">      	<span class="comment">//最后的位置或者根据优先级排序</span></span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">		<span class="comment">//typesBySubscriber保存当前类的订阅事件（方法的参数类型）</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) {</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    }</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">		<span class="comment">//判断当前方法订阅的是黏性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) {</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) {<span class="comment">//默认true,表示黏性事件可以从父类继承</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>subscribe</code>函数相对来说比较简单，已经在上面代码中注释一些信息。看下最后的<code>checkPostStickyEventToSubscription</code>函数，如何发送黏性事件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) {</span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见调用了<code>postToSubscription</code>函数，发送了一次事件，可见，如果订阅的事黏性事件，会出发最后一次黏性消息事件。这里不继续分析，因为和后面的重叠。</p>
<h1 id="unregister"><a class="markdownIt-Anchor" href="#unregister"></a> unregister</h1>
<p>在<code>register</code>函数注册中，会把当前类添加到<code>typesBySubscriber</code>中，而<code>unregister</code>函数则是从<code>typesBySubscriber</code>移除该对象，并调用<code>unsubscribeByEventType</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) {<span class="comment">//遍历当前类注册的所有事件，在事件列表里移除本注册类对应的订阅信息</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        }</span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>看看<code>unsubscribeByEventType</code>函数，通过<code>subscriptionsByEventType</code>获取注册事件<code>eventType</code>的注册信息列表，遍历列表，判断每个订阅信息是否注册类是否与当前解绑注册相同，相同的话则从订阅信息列表移除该订阅信息。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">  	<span class="comment">//订阅类型的所有订阅信息</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) {<span class="comment">//订阅信息中的订阅类与解绑订阅类一致</span></span><br><span class="line">                subscription.active = <span class="keyword">false</span>;<span class="comment">//该标志位在处理订阅方法会很有用</span></span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，解绑的过程是将订阅者和订阅信息分别从<code>typesBySubscriber</code>和<code>subscriptions</code>集合中移除。</p>
<h1 id="post"><a class="markdownIt-Anchor" href="#post"></a> Post</h1>
<p>分析了注册与解注册，接下来分析发送事件的<code>post</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>{</span><br><span class="line">  	<span class="comment">//将事件添加到当前线程的事件队列中</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) {</span><br><span class="line">      	<span class="comment">//判断是否Android主线程</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) {</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);<span class="comment">//此时队列只有我们一个事件</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>currentPostingThreadState</code>是<code>ThreadLocal</code>类型，缓存<code>PostingThreadState</code>。<code>post</code>函数的 主要功能是将事件添加到<code>eventQueue</code>队列中，如果当前<code>postingState.isPosting!=ture</code>,则调用<code>postSingleEvent</code>发布该事件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>{</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) {</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);<span class="comment">//查询该EventType所有父类和接口</span></span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) {</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) {</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) {</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) {</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>postSingleEventForEventType</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>{</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) {</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) {</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (aborted) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>postSingleEventForEventType</code>函数遍历<code>eventClass</code>对应的<code>Subscription</code>列表，然后调用了<code>postToSubscription</code>函数发送事件。前面分析到，当类订阅黏性事件也会调用该方法。</p>
<h2 id="posttosubscription"><a class="markdownIt-Anchor" href="#posttosubscription"></a> <code>postToSubscription</code></h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) {</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里就涉及到<code>EventBus</code>中线程的一些知识点，在注册类中，我们通常通过这样方式去订阅一个事件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{}</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>threadMode</code>表示当事件来临时，执行<code>get</code>函数的方法体的线程。默认情况下是<code>ThreadMode.POSTING</code>,表示与事件发布的线程一致，即发布线程，所以可能在主线程，也有可能在后台线程。而<code>ThreadMode.MAIN</code>表示在<code>Android</code>的主线程，如果发布线程也在主线程，那么方法体会被直接执行，所以可能会被主线程阻塞，可以通过<code>MAIN_ORDERED</code>按序在主线程执行，这样就不会阻塞主线程。<code>ThreadMode.MAIN_ORDERED</code>后台线程，即Android主线程外的其他线程。<code>ThreadMode.ASYNC</code>即异步线程，即发布线程和订阅线程是独立线程，不会直接运行和等待订阅方法。</p>
<p>回到<code>postToSubscription</code>函数。由于我们发布事件和订阅事件都在主线程，所以直接执行了<code>invokeSubscriber</code>函数。也就是直接通过反射调用了我们的订阅方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>假设我们在子线程发布了事件，此时调用的是<code>mainThreadPoster.enqueue(subscription, event)</code>。<code>mainThreadPoster</code>对象的类型<code>MainThreadSupport</code>，在<code>EventBus</code>对象创建的时候被创建。</p>
<h2 id="mainthreadposter"><a class="markdownIt-Anchor" href="#mainthreadposter"></a> <code>MainThreadPoster</code></h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//EventBusBuilder</span></span><br><span class="line"><span class="function">MainThreadSupport <span class="title">getMainThreadSupport</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mainThreadSupport != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> mainThreadSupport;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (AndroidLogger.isAndroidLogAvailable()) {<span class="comment">// Class.forName("android.util.Log") != null</span></span><br><span class="line">        Object looperOrNull = getAndroidMainLooperOrNull();<span class="comment">//Looper.getMainLooper()</span></span><br><span class="line">        <span class="keyword">return</span> looperOrNull == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> MainThreadSupport.AndroidHandlerMainThreadSupport((Looper) looperOrNull);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以<code>MainThreadSupport</code>其实很简单。直接创建了<code>MainThreadSupport</code>的实现类<code>AndroidHandlerMainThreadSupport</code>,内部持有主线程的<code>Looper</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainThreadSupport</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AndroidHandlerMainThreadSupport</span> <span class="keyword">implements</span> <span class="title">MainThreadSupport</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Looper looper;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AndroidHandlerMainThreadSupport</span><span class="params">(Looper looper)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.looper = looper;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> looper == Looper.myLooper();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HandlerPoster(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而<code>mainPoster</code>则是<code>HandlerPoster</code>,<code>HandlerPoster</code>是<code>Handler</code>的子类，并且实现<code>Poster</code>接口。查看其<code>enqueue</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="comment">//利用旧的或直接新建PendingPost对象</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        queue.enqueue(pendingPost);<span class="comment">//加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) {</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将信息包装成<code>PendingPost</code>对象，然后加入到<code>PendingPostQueue</code>队列<code>queue</code>中，如<code>handler</code>未激活，则调用<code>handle</code>的<code>sendMessage</code>函数。</p>
<h2 id="handlemessage"><a class="markdownIt-Anchor" href="#handlemessage"></a> <code>handleMessage</code></h2>
<p>我们看看其<code>handleMessage</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">          	<span class="comment">//从队列取PendingPost对象</span></span><br><span class="line">            PendingPost pendingPost = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                    <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                        handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) {</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                }</span><br><span class="line">                rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用了<code>invokeSubscriber</code>函数。可见最终调用了<code>invokeSubscriber</code>的重载函数，并释放<code>PendingPost</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>{</span><br><span class="line">    Object event = pendingPost.event;</span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) {<span class="comment">//调用unregister,该变量=false。</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样一分析，<code>EventBus</code>的订阅与解订阅，简单事件发布流程就分析完毕了。</p>
<h1 id="黏性事件"><a class="markdownIt-Anchor" href="#黏性事件"></a> 黏性事件</h1>
<p>所谓的黏性事件，就是在订阅方法的<code>Subscribe</code>注解，将其<code>sticky</code>属性设置为<code>ture</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样在类注册的时候，[<code>subscribe</code>](# <code>subscribe</code>)函数会发布上次黏性事件。如果没有黏性事件，则不会发布该事件。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{</span><br><span class="line">	  ...</span><br><span class="line">		<span class="comment">//判断当前方法订阅的是黏性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) {</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) {<span class="comment">//默认true,表示黏性事件可以从父类继承</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们通过<code>postSticky</code>函数来发布黏性事件。它会将黏性事件保存到<code>stickyEvents</code>中，这种后面订阅就可以取出上次黏性事件。然后再调用<code>post</code>进行事件发布。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) {</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    }</span><br><span class="line">    post(event);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="优先权"><a class="markdownIt-Anchor" href="#优先权"></a> 优先权</h1>
<p>在订阅事件时候，我们也可以通过<code>priority</code>属性设置同线程内的同事件不同订阅类接收该订阅事件的优先权。值越大表示优先权越高，会优先接收到订阅事件，这个通过[<code>subscribe</code>](# <code>subscribe</code>)函数得知。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true,priority = 1)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="线程切换"><a class="markdownIt-Anchor" href="#线程切换"></a> 线程切换</h1>
<p>前面分析中，分析了主线程的切换[<code>MainThreadPoster</code>](# <code>MainThreadPoster</code>)。回到<a href="#%60postToSubscription%60"><code>postToSubscription</code></a>函数，了解其他线程的切换。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {</span><br><span class="line">        <span class="keyword">case</span> POSTING:<span class="comment">//订阅线程为POSTING，表示与发布线程一致，不需要切换，直接调用订阅方法。</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {<span class="comment">//先判断发布线程是否在主线程，是的话，直接调用</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">//否则，通过mainThreadPoster切换到主线程</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) {<span class="comment">//mainThreadPoster进队列按序发布事件</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//技术错误，直接调用</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {<span class="comment">//后台线程队列，在线程池执行</span></span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里主要看下<code>backgroundPoster</code>和<code>asyncPoster</code>的工作原理。</p>
<h2 id="backgroundposter"><a class="markdownIt-Anchor" href="#backgroundposter"></a> <code>BackgroundPoster</code></h2>
<p><code>BackgroundPoster</code>实现<code>Runnable</code>和<code>Poster</code>接口。其<code>enqueue</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) {</span><br><span class="line">            executorRunning = <span class="keyword">true</span>;</span><br><span class="line">            eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>先把订阅信息包装类<code>PendingPost</code>添加到队列中，<code>executorRunning=false</code>,则调用<code>eventBus.getExecutorService().execute(this)</code>执行自身。这里的<code>eventBus.getExecutorService()</code>返回的线程池是<code>Executors.newCachedThreadPool()</code>对象,此时查看<code>run</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        executorRunning = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见于<code>MainPoster</code>的逻辑是一致的，只不过这里在线程池执行订阅方法，从而实现切换到后台线程，且在一条后台线程会处理完所有的事件的订阅方法，。</p>
<h2 id="asyncposter"><a class="markdownIt-Anchor" href="#asyncposter"></a> <code>AsyncPoster</code></h2>
<p><code>AsyncPoster</code>也实现<code>Runnable</code>和<code>Poster</code>接口。查看其<code>enqueue</code>函数和<code>run</code>函数。也就是说<code>AsyncPoster</code>实现逻辑与<code>BackgroundPoster</code>一致的。只不过<code>AsyncPoster</code>对象中一条线程只执行一个事件的订阅方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    PendingPost pendingPost = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">    }</span><br><span class="line">    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>【<strong>相关知识点连接</strong>】</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919002656186826765">ThreadLocal</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a class="post-meta__tags" href="/tags/EventBus/">EventBus</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/08/RxJava3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>RxJava3 源码分析</span></a></div><div class="next-post pull-right"><a href="/2021/04/02/Glide%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90/"><span>Glide 源码分析之数据</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>