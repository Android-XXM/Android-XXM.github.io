<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Binder 机制"><meta name="keywords" content="机制"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>Binder 机制 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text"> 一、序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1serializable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.Serializable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2parcelable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text"> 2.Parcelable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text"> 3.两者的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-aidl"><span class="toc-number">2.</span> <span class="toc-text"> 二、AIDL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-aidl%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 1、AIDL支持的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> 2、服务端的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 2.1、定义数据对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%8A%BD%E8%B1%A1%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%83%BD%E5%8A%9B"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 2.2、抽象服务端的服务能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text"> 3、客户端的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text"> 4、小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-binder"><span class="toc-number">3.</span> <span class="toc-text"> 三、Binder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-service%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> 1、Service的注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-processstate"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 1.1 ProcessState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3service"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 1.2 注册相关Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 1.3 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-servicemanger"><span class="toc-number">3.2.</span> <span class="toc-text"> 2、ServiceManger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%88%90%E4%B8%BAservice%E7%AE%A1%E7%90%86%E4%B8%AD%E5%BF%83"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 2.1 成为Service管理中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-servicemanger%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 2.2 ServiceManger集中管理带来的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-client"><span class="toc-number">3.3.</span> <span class="toc-text"> 3、Client</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E6%9F%A5%E8%AF%A2servicemanger"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 3.1 查询ServiceManger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 3.2 请求信息的处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text"> 四、总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Binder 机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在Linux系统中，采用的是虚拟内存地址，分为内核空间和用户空间，运行在内核空间的进程可以直接进行通信，常为系统进程。而客户程序进程则运行在用户空间，它们之间的通信则需要通过内核空间进行。这样区分主要避免客户程序直接操作内核空间，影响系统的正常运行，对系统的操作交给执行在内核空间的操作系统的程序去执行，避免造成奔溃。</p>
<p>用户程序进程之间的通信，Linux系统支持一下几种。</p>
<p><strong>管道</strong>：管道又分匿名管道和命名管道。一端写，一端读，是一种半双工的通信，单向数据流。管道效率较低，涉及四次拷贝：用户空间-&gt;内核空间-&gt;内存-&gt;内核空间-&gt;用户空间。且双向通信需要开启两条管道，对资源占用也是比较高。</p>
<p>匿名管道只能在有血缘关系的进程之间进行通信，如父子进程，兄弟进程。由于匿名管道是建立在内存的缓存区上，所以容量一般不太大，且传递的字节流格式需要双方约定。</p>
<p>命名管道则是在实际的文件系统上实现的通信机制，遵循先进先出原则。</p>
<p>信号：是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。接收进程接收到该信号后去做相应的处理逻辑。</p>
<p>消息队列：存放内核中的消息链表，处理进程不停读取消息内容，然后处理。</p>
<p>共享内存：直接读写同一块内核空间，最快IPC形式。依靠同步机制互斥。</p>
<p>套接字：套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。</p>
<p><code>Binder</code>机制是<code>Android</code>跨进程通信的一种常用方式之一，例如<code>ContentProvider</code>、<code>MediaServer</code>等等底层大多数进程间通信都是基于<code>Binder</code>机制。</p>
<p>在应用层之上想使用Binder机制进行跨进程通信一般采用<code>AIDL</code>进行开发。</p>
<h2 id="一-序列化"><a class="markdownIt-Anchor" href="#一-序列化"></a> 一、序列化</h2>
<p>在开始介绍<code>AIDL</code>之前，先介绍一下对象序列化与反序列化。对象要持久化到内存、本地磁盘或者在网络上传输，需要进行序列化。Android序列对象可以通过</p>
<h3 id="1serializable-接口"><a class="markdownIt-Anchor" href="#1serializable-接口"></a> 1.Serializable 接口</h3>
<p><code>Serializable</code>接口是Java所提供的，为对象提供标准的序列化和反序列化操作。通常一个对象实现<code>Serializable</code>接口，该对象就具有被序列化和反序列化的能力，而且几乎所有工作有系统自动完成。<code>Serializable</code>接口内<code>serialVersionID</code>可指定也可以不指定，其作用是用来判断序列化前和反序列化的类版本是否发生变化。该变量如果值不一致，表示类中某些属性或者方法发生了更改，反序列化则出问题。（静态成员变量和transient关键字标记的成员不参与序列化过程）</p>
<h3 id="2parcelable-接口"><a class="markdownIt-Anchor" href="#2parcelable-接口"></a> 2.Parcelable 接口</h3>
<p><code>Parcelable</code>接口是Android所提供的,其实现相对来说比价复杂。实现该接口的类的对象就可以通过<code>Intent</code>和<code>Binder</code>进行传递。</p>
<h3 id="3两者的区别"><a class="markdownIt-Anchor" href="#3两者的区别"></a> 3.两者的区别</h3>
<p><code>Serializable</code>是Java提供的接口，使用简单，但序列化与反序列化需要大量的IO操作，所以开销比较大。<code>Parcelable</code>是<code>Android</code>提供的序列化方法，使用麻烦当效率高。在<code>Android</code>开发中，将对象序列化到设备或者序列化后通过网络传输建议使用<code>Serializable</code>接口，其他情况建议是用<code>Parcelable</code>接口，尤其在内存的序列化上。例如Intent和Binder传输数据。</p>
<h2 id="二-aidl"><a class="markdownIt-Anchor" href="#二-aidl"></a> 二、AIDL</h2>
<p>在Java层，想利用<code>Binder</code>机制进行跨进程的通信，那就得通过AIDL（Android 接口定义语言）了，AIDL是客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口，只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL，如果是在单应用（单进程），建议使用<code>Messager</code>。</p>
<h3 id="1-aidl支持的数据类型"><a class="markdownIt-Anchor" href="#1-aidl支持的数据类型"></a> 1、AIDL支持的数据类型</h3>
<ul>
<li><code>Java</code>编程语言中的所有原语类型（如 <code>int</code>、<code>long</code>、<code>char</code>、<code>boolean</code>等等）;</li>
<li><code>String</code>和 <code>CharSequence;</code></li>
<li>所有实现了<code>Parcelable</code>接口的对象;</li>
<li>AIDL接口;</li>
<li><code>List</code>，目前List只支持<code>ArrayList</code>类型，持有元素必须是以上讲到类型;</li>
<li><code>Map</code>，目前只支持<code>HashMap</code>类型，持有元素必须是以上讲到类型;</li>
</ul>
<p>自定义的<code>Parcelable</code>对象和AIDL接口必须显示导入到AIDL文件中。</p>
<p><strong>数据的走向</strong></p>
<p><code>Parcelable</code>对象和AIDL接口在使用前必须标明数据的走向：</p>
<ul>
<li><code>in</code>客户端流向服务端的数据</li>
<li><code>out</code>服务端流向客户端的数据</li>
<li><code>inout</code> 服务端与客户端双向流向的数据</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void addUser(inout User user);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-服务端的实现"><a class="markdownIt-Anchor" href="#2-服务端的实现"></a> 2、服务端的实现</h3>
<p>通过创建一个<code>Demo</code>来实践AIDL。这里通过新建一个<code>module</code>来表示一个新的应用进程。</p>
<h4 id="21-定义数据对象"><a class="markdownIt-Anchor" href="#21-定义数据对象"></a> 2.1、定义数据对象</h4>
<p>定义<code>User</code>类，实现了<code>Parcelable</code>接口，作为客户端和服务端传输的数据对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Parcelable {</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public User() {</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public User(String username, String address) {</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.address = address;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    User(Parcel in) {</span><br><span class="line">       readFromParcel(in);</span><br><span class="line">    }</span><br><span class="line">    //系统默认生成，反序列化过程，我们只需要要构造方法读取相关值就可以</span><br><span class="line">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {</span><br><span class="line">        @Override</span><br><span class="line">        public User createFromParcel(Parcel in) {</span><br><span class="line">            return new User(in);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public User[] newArray(int size) {</span><br><span class="line">            return new User[size];</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">     //系统默认生成，内容描述功能，几乎所有情况下都返回0，</span><br><span class="line">     //仅仅当前存在文件描述符，才返回1</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() {</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line">    //序列化过程，通过一系列的write将值写到Parcel 对象</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) {</span><br><span class="line">        dest.writeString(username);</span><br><span class="line">        dest.writeString(address);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() {</span><br><span class="line">        return username+":"+address;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void readFromParcel(Parcel in){</span><br><span class="line">        username=in.readString();</span><br><span class="line">        address=in.readString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="22-抽象服务端的服务能力"><a class="markdownIt-Anchor" href="#22-抽象服务端的服务能力"></a> 2.2、抽象服务端的服务能力</h4>
<p>通过下面方法，建立一个<code>UserManger.aidl</code>文件，表示服务端能为客户端提供什么样的服务。通过Android Studio的右键来新建一个AID。<br>
<img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111707.png" alt=""><br>
下面代码通过建立<code>UserManager.aidl</code>文件,为客户端提供<code>addUser</code>和<code>getUser</code>的能力。<code>UserManager.aidl</code>可以理解为，服务端和客户端的共同约定，两者能进行怎么样的交互。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.gitcode.server;</span><br><span class="line"></span><br><span class="line">// 在这里要导入传递对象的类型，例如User</span><br><span class="line">import com.gitcode.server.User;</span><br><span class="line"></span><br><span class="line">interface UserManager {</span><br><span class="line"></span><br><span class="line">    void addUser(inout User user);</span><br><span class="line"></span><br><span class="line">    User getUser(int index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在相同目录下创建<code>User.aidl</code>，可以直接复制<code>UserManager.aidl</code>,内容修改如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.gitcode.server;</span><br><span class="line"></span><br><span class="line">parcelable User;</span><br></pre></td></tr></tbody></table></figure>
<p>定义<code>UserManager.aidl</code>文件后，<code>sync</code>后，系统默认会生成<code>UserManager.java</code>文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210507224648.png" alt=""></p>
<hr>
<p>UserManager.java的代码如下，为了减少篇幅，去掉了一些实现。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public interface UserManager extends android.os.IInterface {</span><br><span class="line"></span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.gitcode.server.UserManager {</span><br><span class="line">        private static final String DESCRIPTOR = "com.gitcode.server.UserManager";</span><br><span class="line">        </span><br><span class="line">        public Stub() {</span><br><span class="line">            this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        public static com.gitcode.server.UserManager asInterface(android.os.IBinder obj) {</span><br><span class="line">            if ((obj == null)) {</span><br><span class="line">                return null;</span><br><span class="line">            }</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin != null) &amp;&amp; (iin instanceof com.gitcode.server.UserManager))) {</span><br><span class="line">                return ((com.gitcode.server.UserManager) iin);</span><br><span class="line">            }</span><br><span class="line">            return new Stub.Proxy(obj);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public android.os.IBinder asBinder() {</span><br><span class="line">            return this;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {</span><br><span class="line">           ......</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.gitcode.server.UserManager {</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) {</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public android.os.IBinder asBinder() {</span><br><span class="line">                return mRemote;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            public String getInterfaceDescriptor() {</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addUser(com.gitcode.server.User user) throws android.os.RemoteException {</span><br><span class="line">                 ......</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public com.gitcode.server.User getUser(int index) throws android.os.RemoteException {</span><br><span class="line">                .....</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        static final int TRANSACTION_addUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line">        static final int TRANSACTION_getUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void addUser(com.gitcode.server.User user) throws android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    public com.gitcode.server.User getUser(int index) throws android.os.RemoteException;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>从上文可知，<code>UserManager</code>本身是一个接口，并继承<code>IInterface</code>接口。<code>UserManager.java</code>声明了<code>addUser</code>和<code>getUser</code>,和在<code>UserManager.aidl</code>的声明是一致的。同时声明两个整型<code>TRANSACTION_addUser</code>和<code>TRANSACTION_getUser</code>,用于在<code>transact()</code>方法中标识调用服务端哪个方法。如果服务端和客户端在不同进程，方法调用会走<code>transact()</code>方法，逻辑由<code>Stub</code>和<code>Proxy</code>内部类完成。</p>
<p>内部类<strong>Stub</strong>的一些概念和方法含义：</p>
<p><strong><code>DESCRIPTOR</code></strong></p>
<p><code>Binder</code>的唯一标识，一般用当前的类名全名标识。</p>
<p><strong><code>asInterface(IBinder obj)</code></strong></p>
<p>将服务端的Binder对象转换成客户端的AIDL接口类型的对象，如果客户端和服务端同一进程，直接返回Stub对象本身，不在同一进程，则返回由系统封装的<code>Stub.proxy</code>对象。</p>
<p><strong><code>asBinder</code></strong></p>
<p>返回当前<code>Binder</code>对象</p>
<p><strong><code>onTransact(int code, Parcel data, Parcel reply, int flags)</code></strong></p>
<p>运行在服务端<code>Binder</code>线程池，当客户端跨进程发起请求后，系统封装后交由此方法来处理。<code>code</code>表示调用服务端什么方法，上文声明的整型。<code>data</code>表示客户端传递过来的数据，<code>reply</code>为服务端对客户端的回复。</p>
<p>内部代理类 <strong><code>Poxy</code></strong>，客户端持有服务端的一个代理引用，通过该引用调用相关服务。</p>
<p>在服务端进程，通常提供多种服务，而每种服务而通过Service来体现，下面定义<code>UserService</code>,继承至<code>Service</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class UserService extends Service {</span><br><span class="line">    private static final String TAG = "Server";</span><br><span class="line">    private List&lt;User&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() {</span><br><span class="line">        super.onCreate();</span><br><span class="line">        list.add(new User("GitCode", "深圳"));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) {</span><br><span class="line">        Log.i(TAG,"on Bind");</span><br><span class="line">        return stub;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">		//实现UserMananger的Stub</span><br><span class="line">    private UserManager.Stub stub = new UserManager.Stub() {</span><br><span class="line">        @Override</span><br><span class="line">        public void addUser(User user) throws RemoteException {</span><br><span class="line">            list.add(user);</span><br><span class="line">            Log.i(TAG,"add user:"+user);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public User getUser(int index) throws RemoteException {</span><br><span class="line">            Log.i(TAG,"get user,index:"+index);</span><br><span class="line">            return list.size() &gt; index &amp;&amp; index &gt;= 0 ? list.get(index) : null;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在AndroidManifest.xml文件声明Service，以两个组件形成单独的app来体现两个进程，通过AIDL进行数据交互。在客户端通过<code>bindService()</code>来启动该服务。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name="com.gitcode.server.UserService"</span><br><span class="line">    android:enabled="true"</span><br><span class="line">    android:exported="true"&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name="com.gitcode.server.userservice"/&gt;</span><br><span class="line">            &lt;category android:name="android.intent.category.DEFAULT"/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-客户端的实现"><a class="markdownIt-Anchor" href="#3-客户端的实现"></a> 3、客户端的实现</h3>
<p>客户端主要是通过共同的约定（<code>UserManger.aidl</code>）向服务端进行请求，服务端响应客户端的请求。为了提高效率和减少出错，通过拷贝来实现客户端的AIDL文件。<strong>将服务端的<code>aidl</code>整个文件拷贝到客户端的main目录下，不做任何修改</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111718.png" alt=""><br>
<strong>在客户端建立与服务端User类同包的目录，并将User类拷贝过来，不做任何修改</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111725.png" alt=""><br>
在Activity中绑定服务端的Service，绑定成功后进行数据交互。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity {</span><br><span class="line">    private static final String TAG = "Client";</span><br><span class="line">    private UserManager mUserManager;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) {</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        toBindService();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void toBindService() {</span><br><span class="line">        Intent intent = new Intent("com.gitcode.server.userservice");</span><br><span class="line">        intent.setPackage("com.gitcode.server");</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private ServiceConnection connection = new ServiceConnection() {</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) {</span><br><span class="line">            mUserManager = UserManager.Stub.asInterface(service);</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                User user = mUserManager.getUser(0);</span><br><span class="line">                Log.e(TAG, user.toString());</span><br><span class="line"></span><br><span class="line">                mUserManager.addUser(new User("张三","北京"));</span><br><span class="line">            } catch (RemoteException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) {</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行效果：</p>
<p>客户端：<br>
<img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111731.png" alt=""><br>
服务端：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111735.png" alt=""></p>
<h3 id="4-小结"><a class="markdownIt-Anchor" href="#4-小结"></a> 4、小结</h3>
<p>客户端调用服务的方法，被调用的方法运行在服务端的的Binder线程池，同时客户端会被挂起，如果服务端方法执行耗时操作，就会导致客户端ANR,所以不要在客户端主线程访问远程服务方法。同时服务端不应该自己新建新建线程运行服务方法，因为方法会交由线程池处理，同时对数据也要做好并发访问处理。</p>
<p>AIDL可以说为应用层开发提供了封装，不用过多的了解Binder的机制，通过生成的UserManager.java，初步可以了解Binder的IPC机制。使用AIDL在进程之间进行数据通信，更注重的是细节和业务的实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GitCode8/AIDL">上文demo地址</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111739.jpeg" alt=""></p>
<h2 id="三-binder"><a class="markdownIt-Anchor" href="#三-binder"></a> 三、Binder</h2>
<p>Binder进制是Android系统提供的一种IPC机制。由于Android是基于Linux内核，之所有不使用原有的 IPC机制，是因为使用Binder机制，能从性能、稳定性、安全性带来更好的效果。例如，Socket是一套通用的接口，传输速率低下，适合网络传输这种情况，而管道和消息队列需要数据的两次拷贝，共享内容难以管控等。而Binder对数据只需要一次拷贝，使用C/S架构，职责明确，容易维护和使用。</p>
<p>通过下图可以了解到，Binder机制通过内存映射实现跨进程通信，Binder在IPC机制只是作为一个数据的载体，当进程A向虚拟内存空间中写入数据，数据会被实时反馈到进程B的虚拟内存空间。整个发送数据的过程，只从用户空间拷贝一次到虚拟内存空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510104435.png" alt=""><br>
在Binder机制中，主要涉及到<code>Client</code>、<code>Server</code>、<code>ServiceManger</code>，三者通过Binder进行跨进程通信，支撑着Android这个大网络。它们的关系如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510104552.png" alt=""><br>
<strong>服务端</strong></p>
<p>服务端，表示提供服务能力的一方，服务端通过向<code>ServiceManger</code>中注册一些<code>Service</code>，对外告知其可提供的服务。例如上文AIDL中，会注册<code>UserService</code>，并为客户端提供添加User和获取User的操作。</p>
<p><strong>客户端</strong></p>
<p>对服务端提供的服务进行业务逻辑操作。通过服务端提供的<code>Service</code>的名称在<code>ServiceManger</code>查询对应的<code>Service</code>。</p>
<p><strong><code>ServiceManager</code></strong></p>
<p><code>ServiceManger</code>集中管理所有<code>Service</code>，和施加权限。为服务端提供注册<code>Service</code>,为客户端提供查找<code>Service</code>能力，类似网络编程中<code>DNS</code>的作用。</p>
<p>图表示三者的C/S架构，例如Client查询向<code>ServiceManger</code>查询<code>Service</code>时，<code>Client</code>就是客户端，而<code>ServiceManger</code>就是服务端。而虚线则表示两者之间通过Binder进行进程间的通信，因此通过了解一条虚线的流程，就可以知道Binder的机制。</p>
<h3 id="1-service的注册过程"><a class="markdownIt-Anchor" href="#1-service的注册过程"></a> 1、Service的注册过程</h3>
<p>我们常通过<code>getSystemService()</code>函数来获取系统的相关服务，例如<code>ActivityManagerService</code>,那么这些Service从哪里来呢？就是有些服务进程向<code>ServiceManager</code>注册自己的<code>Service</code>，表示自己能对客户端提供什么样的服务。通过了解<code>Service</code>的注册过程，来学习<code>Binder</code>机制的工作原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111749.png" alt=""><br>
<code>BpServcieXXX</code>和<code>BnServcieXXX</code>是客户端与服务端进程业务层辑实现的封装。<code>BnServiceManger</code>派生自<code>IServiceManager</code>和<code>BBinder</code>类，通过调用<code>BBinder</code>对象的<code>transcat</code>函数的参与通信。是一个虚类，具体的功能需要子类去实现，存在服务端。<code>BpServiceManager</code>派生自<code>BpInterfacle</code>和``BpRefBase<code>接口，其中</code>BpRefBase<code>的</code>mRemote<code>函数返回的就是</code>BpBinder`对象,存在客户端。</p>
<p><code>BBinder</code>和<code>BpBinder</code>都是<code>IBinder</code>的子类。两者相互对应，客户端通过<code>BpBinder</code>对象与服务端进行通信，而客户端通过<code>BBinder</code>与客户端进行通信。</p>
<p>通过<code>IServiceManger</code>与<code>IBinder</code>架构将业务逻辑与IPC进行分离，下层Binder机制完全可以切换成Linux中的其他通信机制。</p>
<h4 id="11-processstate"><a class="markdownIt-Anchor" href="#11-processstate"></a> 1.1 <code>ProcessState</code></h4>
<p>每个进程通过单例模式创建了唯一的<code>ProcessState</code>对象,在其构造器中，通过<code>open_driver()</code>方法打开了<code>/dev/hwbinder</code>设备，相当于Server进程打开了与内核的<code>Binder</code>驱动交互的通道，并设置最大支持线程数为15。<code>binder</code>设备是<code>Android</code>在内核中为完成进程间通信而专门设置的一个虚拟设备。</p>
<h4 id="12-注册相关service"><a class="markdownIt-Anchor" href="#12-注册相关service"></a> 1.2 注册相关Service</h4>
<p><code>BpServiceManger</code>对象实现对<code>IServiceManger</code>的业务函数，又有<code>BpBinder</code>作为通信代表，下面分析一下注册的过程。</p>
<p>将字符串名字和Service对象作为参数传到<code>BpServiceManger</code>对象的<code>addService()</code>函数，该方法将参数数据打包后传递给<code>BpBidner</code>的<code>transact()</code>函数。业务层的逻辑到此就结束，主要作用是将请求信息打包交给通信层去处理。</p>
<p>在<code>BpBinder</code>的<code>transact()</code>函数调用了<code>IPCThreadState</code>对象的<code>transact()</code>函数，所以说<code>BpBinder</code>本身没有参与Binder设备的交互。每个线程都有一个<code>IPCThreadState</code>对象，其拥有一个<code>mOut</code>、<code>mIn</code>的缓冲区，<code>mOut</code>用来存储转发Binder设备的数据，而<code>mIn</code>用来接收<code>Binder</code>设备的数据。通过<code>ioctl</code>方式与<code>Binder</code>设备进行交互。</p>
<h4 id="13-小结"><a class="markdownIt-Anchor" href="#13-小结"></a> 1.3 小结</h4>
<p>通过上文<code>Service</code>的注册过程，分析了Binder的机制。Binder只是通信机制，业务可以基于Binder机制，也可以基于其他IPC方式的机制，也就是上文为啥有<code>BpServiceManger</code>和<code>BpBinder</code>。Binder之所以复杂，是Android通过层层的封装，巧妙的将业务与通信融合在一起。主要还是设计理想很牛逼。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210510111753.png" alt=""></p>
<h3 id="2-servicemanger"><a class="markdownIt-Anchor" href="#2-servicemanger"></a> 2、<code>ServiceManger</code></h3>
<p>通过1小节的分析，是否应该也有一个类继承自<code>BnServiceManger</code>来处理远方请求呢？</p>
<p>很可惜的是在服务端并没有<code>BnServiceManger</code>子类来响应远程客户端的请求，而是交给了<code>ServiceManger</code>来处理。</p>
<h4 id="21-成为service管理中心"><a class="markdownIt-Anchor" href="#21-成为service管理中心"></a> 2.1 成为Service管理中心</h4>
<p><code>ServiceManger</code>通过<code>binder_open</code>函数打开<code>binder</code>设备，并映射内存。通过<code>handler</code>等于0标识自己，让自己成为管理中心，所有<code>service</code>向<code>ServiceManger</code>注册时，都是通过<code>handle</code>标识为的<code>0</code>的<code>BpBinder</code>找到<code>ServiceManger</code>对应的<code>BBinder</code>,<code>ServiceManager</code>会保存要注册的<code>Service</code>的相关信息，方便Client查找。并不是所有的<code>Service</code>都可以在<code>ServiceManger</code>注册，如果<code>Server</code>进程的权限不够<code>root</code>或<code>system</code>,那么需要在<code>allowed</code>添加相应的项。</p>
<h4 id="22-servicemanger集中管理带来的好处"><a class="markdownIt-Anchor" href="#22-servicemanger集中管理带来的好处"></a> 2.2 <code>ServiceManger</code>集中管理带来的好处</h4>
<ul>
<li>统一管理，施加管控权</li>
<li>通知字符串名称查找Service</li>
<li>Server进程生命无常，通过<code>ServiceManger</code>，Client可以实时知道Server进程的最行动态。</li>
</ul>
<h3 id="3-client"><a class="markdownIt-Anchor" href="#3-client"></a> 3、Client</h3>
<p>Client想要使用Server进程提供的Service，又该进行哪些步骤呢？</p>
<h4 id="31-查询servicemanger"><a class="markdownIt-Anchor" href="#31-查询servicemanger"></a> 3.1 查询<code>ServiceManger</code></h4>
<p>Client想要得到某个Service的信息，就得与<code>ServiceManager</code>打交道，通过调用<code>getService（）</code>方法来获取对应<code>Service</code>信息。Client通过服务名称向<code>ServiceManger</code>查询对应的<code>Service</code>。如果<code>Service</code>未注册，则循环等待直到该<code>Service</code>注册；如果已注册，则会对应封装了一个能与远程<code>Service</code>通信的<code>BpBinder</code>的<code>BpXXXService</code>,通过该<code>Service</code>，Client客户调用相关业务逻辑函数。</p>
<h4 id="32-请求信息的处理"><a class="markdownIt-Anchor" href="#32-请求信息的处理"></a> 3.2 请求信息的处理</h4>
<p>Client调用的业务函数，莫非就是将请求参数打包发送给Binder驱动，<code>BpBinder</code>通过handler的值找到对应端的<code>Service</code>来处理。</p>
<p>在1.4小节中，说到<code>IPCThreadState</code>对象，在其<code>executeCommand</code>函数中，通过调用实现了<code>BnServiceXXX</code>的对象<code>onTransact</code>函数，直接定位到业务层。这就是在AIDL中，为什么在<code>onTransact</code>()函数中处理响应数据。</p>
<h2 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h2>
<p>通过对Binder机制的学习，了解Android是如何通过层层封装将Binder机制集成要应用程序，对Binder机制有一个较深入的理解。可以通过第Java层AIDL的使用，加深对Binder机制的理解。</p>
<p>个人水平有限，有误请帮忙勘正，谢谢大佬。喜欢就帮忙点个赞呗。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%BA%E5%88%B6/">机制</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/12/Android%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"><i class="fa fa-chevron-left">  </i><span>Handler 消息机制</span></a></div><div class="next-post pull-right"><a href="/2021/04/08/RxJava3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span>RxJava3 源码分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>