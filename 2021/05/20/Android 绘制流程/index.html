<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android 绘制流程"><meta name="keywords" content="机制"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>Android 绘制流程 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%B5%8B%E9%87%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text"> 一、测量流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 二、布局流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text"> 三、绘制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text"> 四、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text"> 番外篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-measurespec%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text"> 1、MeasureSpec是什么？作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-requestlayout%E5%92%8Cinvalidatepostinvalidate%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text"> 2、requestLayout和invalidate,postInvalidate区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android 绘制流程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Android View的绘制流程分为三大流程：测量、布局、绘制。三大流程都开始于<code>ViewRootImpl</code>的<code>performTraversals</code>函数。通过了解三大流程的顺序和原理，支撑日常开发工作。</p>
<h2 id="一-测量流程"><a class="markdownIt-Anchor" href="#一-测量流程"></a> 一、测量流程</h2>
<p>三大流程都是始于<code>ViewRootImpl</code>的<code>performTravels</code>函数，先是从调用View的<code>performMeasure</code>函数开始测量流程，再是调用<code>performLayout</code>函数开始布局流程,进而是调用<code>performDraw</code>函数开始绘制流程。本节从<code>performMeasure</code>函数开始，讲View的测量流程。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a59b41f94cb4a50be08214e4457c060~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>正式开始测量流程了~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047bccc00de44716a1948495d66e46a8~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p><code>performMeasure</code>函数会调用View的<code>measure</code>函数。<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90116d4255004b948b1b4ffa8b86015b~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<code>measure</code>函数第一行会调用<code>isLayoutModeOptical</code>函数，用来判断当前View是否<code>ViewGroup</code>,是<code>ViewGroup</code>的话，判断<code>layoutModel</code>属性是否<code>LAYOUT_MODE_OPTICAL_BOUNDS</code>,即<code>opticalBounds</code>。该属性默认为<code>clipBounds</code>,还可取值<code>opticalBounds</code>，前者在获取<code>ViewGroup</code>的四边(<code>getLeft</code>,<code>getTop</code>,<code>getRight</code>,<code>getBottom</code>)将返回原始的值，而<code>opticalBounds</code>表示给<code>ViewGroup</code>加一些特殊的效果，例如阴影或高亮效果，因为返回的四边也将比<code>clipBounds</code>小。</p>
<p><code>measure</code>函数接下来的这一段主要是为了判断是否需要进行重新测量，毕竟每次测量也不容易。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//用于存储上次测量的结果</span><br><span class="line">long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</span><br><span class="line">if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</span><br><span class="line"></span><br><span class="line">//view是否需要强行刷新，调用froceLayout</span><br><span class="line">final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">//判断此次的widthMeasureSpec与heightMeasureSpec是否与上次相等</span><br><span class="line">final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">        || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line"></span><br><span class="line">//判断此次测量模式是否精确，不是精确的可能需要重新测量</span><br><span class="line">final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">        &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line"></span><br><span class="line">//判断此次测量大小是否与已保存的大小一致，不是一致可能需要重新测量         </span><br><span class="line">final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"> //如果specChanged为false,即宽高measureSpec与上次都相等，不需要重新测量；true则进一步检查其他条件</span><br><span class="line"> //sAlwaysRemeasureExactly主要用于判断LinearLayout在旧版本的不同测量模式都会返回不同的测量结果，小于Android 6.0为true,大于为false；所以但小于Android 6.0需要重新测量</span><br><span class="line"> //如果isSpecExactly测量模式是非精确模式需要重新测量</span><br><span class="line">  //如果matchesSpecSize与已保存大小不一致需要重新测量</span><br><span class="line">final boolean needsLayout = specChanged</span><br><span class="line">        &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br></pre></td></tr></tbody></table></figure>
<p><code>needsLayout</code>就是根据上面相关变量的值共同判断是否需要重新测量的最终结果。也可以通过下图一览上面的注释。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b32ff1c09194ce5a7ffadec3045db1e~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>接着<code>measure</code>函数的内容，当调用<code>forceLayout</code>或<code>requestLayout</code>函数，<code>mPrivalteFlags</code>就会添加<code>PFLAG_FORCE_LAYOUT</code>标记,那么<code>forceLayout</code>就是<code>true</code>,无论后面其他判断条件怎么样，一定会调用<code>onMeasure</code>函数进行测量。而<code>needsLayout</code>就在上文刚分析了。</p>
<p><code>mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</code>语句重置所有的已设置的测量信息，毕竟要准备重新开始测量了。<code>resolveRtlPropertiesIfNeeded()</code>主要是处理文本从右到左的情况，因为并不是所有国家文字书写顺序都是从左到右。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e61aa335291c408c82722e940a15bf70~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<code>LongSparseLongArray</code>是<code>key</code>与<code>value</code>都为<code>Long</code>，类似<code>HashMap</code>的数据结构。这里正是通过这种结构用来存储测量的宽和高，如果<code>mMeasureCache.indexOfKey(key)</code>返回值小于0，表示不存在对应的宽高，需要测量。</p>
<p><code>sIgnoreMeasureCache</code>表示为了性能优化而忽略测量缓存，其实是为了兼容旧版本，因为在<code>Android4.4</code>前，APP总是希望<code>onMeasure</code>函数被调用，所以该变量总是<code>true</code>，而<code>Android 4.4</code>和后续版本，该标志总是<code>false</code>。</p>
<p>因此，如果需要测量，则调用当前View的<code>onMeasure</code>函数;不需要重新测量，则从缓存<code>mMeasureCache</code>获取已缓存宽高。</p>
<p><code>measure</code>函数的最后代码就是保存父View对当前View的宽高要求和往<code>mMeasureCache</code>存值，以供下次测量作为判断条件使用。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db77f62bf14b43a58ff489a314344acb~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p><strong>measure函数总结一下：</strong></p>
<p><strong>measure函数主要是为了性能优化，根据缓存（已缓存）、父类约束是不与上次一致，和行为（刷新布局）来判断是否重新测量大小。</strong></p>
<p>接下来看看<code>View</code>的<code>onMeasure</code>函数做了什么事：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0d65bd5545d4f78ab446c49e9d4d4b7~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>看着简单，其实还是要拆解看看：<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451e01894a3746d7be9dca4d79af2290~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<code>getSuggestedZMininumWidth</code>函数主要判断当前是否设置背景，如果没有设置背景，则取最小宽度；设置了背景，则取最小宽度和背景最小宽度的两者之间的最大值。最小宽度就是我们设置的<code>minWidth</code>属性。高度的测量亦是如此。</p>
<p><code>getDefaultSize</code>函数主要是根据测量模式，计算出默认的尺寸大小。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ded1145bbbf479780d474632075d473~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
到这里，就应该需要对<code>MeasureSpec</code>的大小和测量模式解释一下，不然有的同学真一脸懵逼。<code>MeasureSpec</code>是<code>View</code>的静态内部类，代表一个32位的整型，高2位表示测量模式，低30位表示尺寸大小。<code>measure</code>函数的两个参数<code>widthMeasureSpec</code>，<code>heightMeasureSpec</code>，分别代表着父View对子View的宽高约束。从这里也可以看出，子View的大小由父View约束和子View自身自身约束共同确定。</p>
<p>通过<code>MeasureSpec</code>提供的一些静态方法，如<code>int getSize(int measureSpec)</code>、<code>int getMode(int measureSpec)</code>,可以获取到测量模式<code>mode</code>和大小<code>size</code>，分别为：</p>
<ul>
<li><strong>EXACTLY</strong>：当<code>View</code>的<code>layout_width</code>或者<code>layout_height</code>设置为<code>match_parent</code>或具体的值时，该测量模式就是<code>EXACTLY</code>，表示父<code>View</code>对当前<code>View</code>的尺寸要求大小是size;</li>
<li><strong>AT_MOST</strong>：当<code>View</code>的<code>layout_width</code>或者<code>layout_height</code>属性设置为<code>wrap_content</code>，该测量模式就是<code>AT_MOST</code>,表示父<code>View</code>能给予当前<code>View</code>的最大的可用尺寸是<code>size</code>，具体用多少当前<code>View</code>自己决定;</li>
<li><strong>UNSPECIFIED</strong>：表示父View对当前View没有任何约束，想要多大的尺寸当前View自己决定。</li>
</ul>
<p><strong>从<code>getDefaultSize</code>函数对测量模式<code>AT_MOST</code>和<code>EXACTLY</code>的处理方式看，自定义View继承View时，要格外注意<code>layout_width</code>或<code>layout_height</code>属性值为<code>wrap_content</code>的情况，因为它的表现就跟<code>match_parent</code>是一样的，有时需要根据具体情况去更改这种行为。</strong></p>
<p><code>setMeasureDimension</code>函数开始跟<code>measure</code>函数类似，先判读一下<code>layoutModel</code>是否<code>optical bound</code>，进行宽高的调整，并调用<code>setMeasureDimensionRaw</code>函数。<br>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6966c5915a824b5caecd1c9d59a15ccd~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p><code>setMeasureDimension</code>则是简单的赋值，设置<code>mPrivateFlags</code>标志位。这样就可以通过<code>getMeasuredWidth</code>与<code>getMeasuredHeight</code>函数来获取测量的宽高了。<strong>注意：</strong> 重写<code>onMeasure</code>函数需要调用<code>setMeasureDimension</code>函数进行数据缓存。<br>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cfd55cb26cf454fb237b111fd3fc8b3~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>测量流程也就到此结束了。但仔细一想，发现不对劲，这里测量指的是<code>View</code>，那么<code>ViewGroup</code>呢？</p>
<p><code>ViewGroup</code>是<code>View</code>的子类，而<code>View</code>的<code>measure</code>函数被被声明成了<code>final</code>，所以<code>ViewGroup</code>测量自身或者测量子<code>View</code>只能重写<code>onMeasure</code>函数。但在<code>ViewGroup</code>类仔细寻找，却没有发现重写<code>onMeasure</code>函数的痕迹。因为具体的<code>ViewGroup</code>，如<code>LinearLayout</code>和<code>RelativeLayout</code>它们各自的测量方式是不一样的，<code>onMeasure</code>需要它们具体去实现。但<code>ViewGroup</code>类提供了一些便捷的<code>api</code>，如<code>measureChildren</code>、<code>measureChildWithMargins</code>、<code>measureChild</code>等等。<br>
翻翻<code>LinearLayout</code>的<code>onMeasure</code>函数，最终也会调用View的<code>measure</code>函数，走<code>View</code>的测量流程。</p>
<p><strong>因此自定义<code>View</code>或者<code>ViewGroup</code>，需要根据自身实现的功能去重写<code>omMeasure</code>函数，来测量自身或子View的大小</strong><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959d102ed91140af81e71dbc626f5bb2~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="二-布局流程"><a class="markdownIt-Anchor" href="#二-布局流程"></a> 二、布局流程</h2>
<p>上一节分析了测量流程，得知了每个View的宽高大小，这一节紧跟着分析布局流程，判断子<code>View</code>如何在父<code>View</code>进行定位。<code>performLayout</code>函数同样是在<code>ViewRootImpl</code>类的<code>performTraversals</code>函数中，<code>performMeasure</code>函数之后。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23f3c04af9524a9985a180c1e08ba08b~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
可以看到，<code>performLayout</code>函数很快就调用了<code>View</code>的<code>layout</code>函数进行布局流程。这里先不跟进去，只需要知道已经进行了一次布局，然后看<code>performLayout</code>函数的后续内容。</p>
<p><code>mLayoutRequesters</code>是一个保存了在布局过程中所有请求布局的View的列表。当列表不为空时候，需要对这些View进行处理。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33d1aa40547e41198d75d46ab5d4a486~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>在布局的过程中，可能View请求布局（即设置了<code>PFLAG_FORCE_LAYOUT</code>）,将它们存到列表<code>mLayoutRequesters</code>中，然后在布局结束后，第一次通过<code>getValidLayoutRequesters</code>函数判断这些<code>View</code>是否需要重新布局，判断条件就是当前View是否可见和设置了<code>PFLAG_FORCE_LAYOUT</code>标志。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2ddf68091e40b085269f3adb79fc13~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
如果返回值<code>validLayoutRequesters</code>不为空，重新设置他们的标志位<code>PFLAG_FORCE_LAYOUT</code>，并调用<code>measureHierarchy</code>函数，对它们进行View层级的测量，测量流程和整个界面测量流程是一致。然后再跟着重新布局一次<code>host.layout()</code>。</p>
<p>进行第二次判断是否还在布局过程中，有View请求布局，如果有的话，判断有效的需要重新布局的View，这次判断忽略了<code>PFLAG_FORCE_LAYOUT</code>标志位，除了不可见的View，其他都列为需要有效的。然后留到下次帧再重新来过。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad945db9e9734099bae835dfbc52c20e~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p><strong>总结一下</strong></p>
<p>在第一次布局的过程中，如果有View需要<code>requestLayout</code>函数（一般发生在<code>ListView</code>等的子View），则需要判断这些View是否可见或已经处理了<code>requestLaout</code>。如果有可见的、未处理<code>requestLayout</code>的View则需要进行View层次级别的测量，然后重新布局一次。然后进行第二次判断是否有View需要<code>requestlayout</code>，这次只判断是否可见。如果还有，这些View就留到下一帧进行吧，老子不管了。</p>
<p>再回到第一次布局<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</code>。<br>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f795fa23c63481991445e4943147bd4~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<code>setOpticalFrame</code>函数最终也会调用<code>setFrame</code>,只是追加了点效果边距长度。<code>setFrame</code>函数主要是对当前View在父View的位置进行确定，如果此时定位位置有变（四边有不一致），则changed返回的是true。在<code>setFrame</code>函数会调用<code>sizeChanged</code>函数，而<code>sizeChanged</code>函数会调用<code>onSizeChanged</code>函数。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b792de69fe2c43f3a389996414973653~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<code>onLayout</code>函数在View中是一个空实现，而在<code>ViewGroup</code>未重写该方法。因为子View在父View位置，在不同的<code>ViewGroup</code>表现也是不同的，所以需要具体的<code>ViewGroup</code>根据自己的特性去重写。但这里我们注意到一个时机，<code>onSizeChanged</code>函数的回调在<code>onMeasure</code>函数之后，<code>onLayout</code>函数之前，在尺寸大小发生变化时会回调该方法。</p>
<p>在调用<code>onLaout</code>函数后的主要进行<code>OnLayoutChangeListener</code>的回调和焦点的处理。<code>isLayoutValid</code>函数表示至少已经经历过一次布局了或者不会再进行其他布局了，就返回true。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f70d1b2c4ec4426d8188b33f11d06cbc~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d43c6976990c4469ba360f8afc142665~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
到这里，布局流程基本也就结束了。</p>
<p><strong>本节小结</strong></p>
<p>布局流程始于<code>ViewRootImpl</code>的<code>performTraversals</code>函数，然后调用自身的<code>performLayout</code>函数，对View进行布局，布局结束后对布局过程有请求布局的View进行View层级测量和布局。在View的<code>layout</code>函数中，通过<code>setFrame</code>对自身进行布局定位，如果位置发生变化则回调<code>onSizeChanged</code>函数。再而是调用<code>onLayout</code>函数。因此自定View无需重写<code>onLayout</code>函数，自定义<code>ViewGroup</code>则需要重写<code>onLayout</code>函数进行子View的布局。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21fca9f9f6204936940fa65776a4d460~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="三-绘制流程"><a class="markdownIt-Anchor" href="#三-绘制流程"></a> 三、绘制流程</h2>
<p>经过测量、绘制，已经知道了View的大小，在父View的位置，那么接下来就是如何将View绘制出来，展现在屏幕。</p>
<p>绘制流程始于<code>ViewRootImpl</code>的<code>performTraversals</code>函数，调用自身的<code>performDraw</code>函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//ViewRootImpl.java</span><br><span class="line">performTraversals=&gt;performDraw=&gt;draw=&gt;drawSoftware=&gt;View.draw</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>draw</code>函数中，主要是绘制区域<code>dirty</code>的确定，例如是否滚动、全部绘制等。</p>
<p><code>drawSoftware</code>函数就是通过软件去绘制的地方，主要根据<code>dirty</code>区域，生成并锁定<code>canvas</code>，而<code>canvas</code>就是绘制内容的区域。</p>
<p>而在View的<code>draw</code>函数，则是View的绘制的开始：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawBackground=&gt;onDraw=&gt;dispatchDraw=&gt;onDrawForeground=&gt;drawDefaultFocusHighlight</span><br></pre></td></tr></tbody></table></figure>
<p>在View的<code>draw</code>流程中，自定义<code>View</code>一般重写<code>onDraw</code>函数，<code>super.onDraw</code>后绘制自己的内容，表示所绘制内容在系统绘制的内容之后。而自定义<code>ViewGroup</code>中，如果需要覆盖在子View之上，应该是重写<code>dispatchDraw</code>函数，并调用<code>super.dispatchDraw</code>之后，因为<code>dispatchDraw</code>函数会去绘制所有子View的内容，在之前绘制的内容都会被覆盖。当然，也可以以<code>dispatchDraw</code>作为分界点，根据需要重写其他函数，绘制内容。</p>
<p>如果重写<code>ViewGroup</code>的<code>onDraw</code>函数,绘制的内容一般显示不出来，因为<code>ViewGroup</code>会优化从而跳过<code>onDraw</code>函数，可以通过设置背景或<code>setWillNotDraw(false)</code>来解决这个问题。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/810a00fea1fe4c57abe71d39257bc685~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h2>
<p>View的工作流程出发于<code>ViewRootImpl</code>类，并在其他<code>performTraversals</code>函数开始View的测量、布局和绘制。</p>
<p>在测量阶段，子View的宽高受自身和父View的共同约束，而父View一般都是xml布局中<code>layout_</code>开头的属性,而<code>DecorView</code>则受自身和手机屏幕尺寸约束。其中涉及到一个比较重要的概念是<code>MeasureSpec</code>的使用。布局阶段主要定位子View在父View的位置，进行排版。绘制阶段主要对View的内容进行绘制，要注意<code>View</code>和<code>ViewGroup</code>几个方法的绘制顺序。</p>
<p>通过学习<code>Android</code>的绘制流程，需要知道几点情况：</p>
<ol>
<li>自定View时，需要考虑宽高设置<code>wrap_content</code>的情况，因为它的表现在测量阶段和<code>match_parent</code>是一致的。</li>
<li>重写View的<code>onDraw</code>函数，要避免在<code>onDraw</code>创建对象，因为<code>onDraw</code>会被调用多次，可以考虑在<code>onSizeChanged</code>函数创建。</li>
<li>如果<code>View</code>或<code>ViewGroup</code>需要改变自身大小，应该在<code>onMeasure</code>函数实现,并通过<code>setMeasureDimension</code>保存下来。</li>
<li>重写<code>ViewGroup</code>的<code>onDraw</code>函数时，要注意<code>onDraw</code>函数在整个draw流程的地位，以及它并不是都会被调用。</li>
</ol>
<h2 id="番外篇"><a class="markdownIt-Anchor" href="#番外篇"></a> 番外篇</h2>
<h3 id="1-measurespec是什么作用"><a class="markdownIt-Anchor" href="#1-measurespec是什么作用"></a> 1、<code>MeasureSpec</code>是什么？作用</h3>
<p><code>MeasureSpec</code>在View中的一个静态内部类，能将一个32位整型拆分成测量模式和测量大小，代表着父View对子View的约束。32位的整型，高两位代表着测量模式，低三十位代表测量大小。通过位位运算，可以分别获取测量模式和大小，而合并成一个32位整型，只需要相加即可。</p>
<p>例如，给宽设置10,此时测量模式是精确模式EXACTLY,即01，用32位的整型表示应该是（暂且用xxx表示中间所有的0）</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52c17a5796454b8b8338d4543a151bd1~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>若求测试模式model,只需要和高两位都是1，低三十位都是0的<code>MODE_MASK</code>按位与即可。<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/551299d126464e5f8c50d61e9361639b~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int getMode(int measureSpec) {</span><br><span class="line">	return (measureSpec &amp; MODE_MASK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>若求测试大小,只需要和取反后<code>MODE_MASK</code>按位与即可。<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0dbe39a08f48a091cbecb33be29102~tplv-k3u1fbpfcp-watermark.image" alt=""><br>
代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int getSize(int measureSpec) {</span><br><span class="line">    return (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-requestlayout和invalidatepostinvalidate区别"><a class="markdownIt-Anchor" href="#2-requestlayout和invalidatepostinvalidate区别"></a> 2、<code>requestLayout</code>和<code>invalidate</code>,<code>postInvalidate</code>区别？</h3>
<p>一般来说，需要重新走整个流程，就调用<code>requestLayout</code>，然后再调用<code>invalidate</code>保证<code>onDraw</code>一定被调用。也就是说<code>requestLayout</code>不一定保证<code>onDraw</code>被调用，但会调用<code>onMeasure</code>函数和<code>onLayout</code>函数。而<code>invalidata</code>函数只会调用到<code>onDraw</code>函数。<code>invalidate</code>函数在UI线程刷新界面，<code>postInvalidate</code>表示在子线程刷新界面。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%BA%E5%88%B6/">机制</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/06/17/%E7%90%86%E8%A7%A3%E4%B8%8A%E4%B8%8B%E6%96%87Context/"><i class="fa fa-chevron-left">  </i><span>理解上下文 Context</span></a></div><div class="next-post pull-right"><a href="/2021/05/19/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"><span>Android 启动优化</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>