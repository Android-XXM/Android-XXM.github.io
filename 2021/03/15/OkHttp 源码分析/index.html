<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="OkHttp 源码分析"><meta name="keywords" content="OkHttp,源码分析"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>OkHttp 源码分析 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text"> 摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text"> 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#realcall%E7%9A%84enqueue%E4%B8%8Eexecute%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text"> RealCall的enqueue与execute函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getresponsewithinterceptorchain"><span class="toc-number">2.2.</span> <span class="toc-text"> getResponseWithInterceptorChain</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E9%93%BE"><span class="toc-number">3.</span> <span class="toc-text"> 拦截链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82callserverinterceptor"><span class="toc-number">3.1.</span> <span class="toc-text"> 网络请求：CallServerInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8connectinterceptor"><span class="toc-number">3.2.</span> <span class="toc-text"> 连接复用：ConnectInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5cacheinterceptor"><span class="toc-number">3.3.</span> <span class="toc-text"> 缓存策略：CacheInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8Fbridgeinterceptor"><span class="toc-number">3.4.</span> <span class="toc-text"> 桥接模式：BridgeInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%81%A2%E5%A4%8Dretryandfollowupinterceptor"><span class="toc-number">3.5.</span> <span class="toc-text"> 重试恢复：RetryAndFollowUpInterceptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text"> 自定义拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text"> 责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text"> 总结：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">OkHttp 源码分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>本文主要是分析Android主流网络请求框架<code>OkHttp</code>源码，看看每天都在打交道的伙计到底在干什么。处理了网络中最根本的HTTP问题，如对HTTP请求报文和响应报文的处理。允许自定义拦截器实现特殊的需求，如日志打印，增加请求头等。默认六个拦截器处理网络请求，缓存复用，连接复用，数据转化，重试恢复机制。</p>
<h2 id="请求"><a class="markdownIt-Anchor" href="#请求"></a> 请求</h2>
<p><code>OkHttp</code>的异步请求主要了调用<code>Call</code>对象的<code>enqueue</code>函数，而<code>Call</code>接口唯一的实现类是<code>RealCall</code>。所以异步请求主要是调用了<code>RealCall</code>的<code>enqueue</code>函数，而同步请求则是<code>RealCall</code>对象的<code>execute</code>函数。</p>
<h3 id="realcall的enqueue与execute函数"><a class="markdownIt-Anchor" href="#realcall的enqueue与execute函数"></a> <code>RealCall</code>的enqueue与execute函数</h3>
<p>下面先分析异步请求：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> {</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) { <span class="string">"Already Executed"</span> }</span><br><span class="line"></span><br><span class="line">    callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p><code>RealCall</code>调用<code>Dispatcher的enqueue</code>函数</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> {</span><br><span class="line">    synchronized(<span class="keyword">this</span>) {</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) {</span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>readyAsyncCalls</code>是一个队列，用于保存即将执行的<code>AsyncCall</code>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> {</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) {</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) {</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"><span class="comment">//maxRequests默认最大网络请求数 64 </span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">//maxRequestsPerHost默认最大目的主机请求数5</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove()</span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    }</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span><span class="comment">//待运行+正在运行主机数</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) {</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    <span class="comment">//调用AsyncCall</span></span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>runningAsyncCalls</code> 是一个队列，保存<strong>正在执行</strong>的<code>AsyncCall</code>。<code>promoteAndExecute()</code>函数主要将<code>readyAsyncCalls</code>队列中待运行的请求添加到<code>runningAsyncCalls</code>队列中，并调用其<code>executeOn</code>函数。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> {</span><br><span class="line">  client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//将AsyncCall添加到线程池中</span></span><br><span class="line">    executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">    success = <span class="literal">true</span></span><br><span class="line">  } <span class="keyword">catch</span> (e: RejectedExecutionException) {</span><br><span class="line">    <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">    ioException.initCause(e)</span><br><span class="line">    noMoreExchanges(ioException)</span><br><span class="line">    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>executeOn</code>函数主要是将<code>AsyncCall</code>添加到线程池中。此时看看<code>AsyncCall</code>的<code>run</code>函数如何实现。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">  threadName(<span class="string">"OkHttp <span class="subst">${redactedUrl()}</span>"</span>) {</span><br><span class="line">    <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">    timeout.enter()</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//在这里返回了响应数据</span></span><br><span class="line">      <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">      signalledCallback = <span class="literal">true</span></span><br><span class="line">      responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">    } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">      <span class="keyword">if</span> (signalledCallback) {</span><br><span class="line">        <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">        Platform.<span class="keyword">get</span>().log(<span class="string">"Callback failure for <span class="subst">${toLoggableString()}</span>"</span>, Platform.INFO, e)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (t: Throwable) {</span><br><span class="line">      cancel()</span><br><span class="line">      <span class="keyword">if</span> (!signalledCallback) {</span><br><span class="line">        <span class="keyword">val</span> canceledException = IOException(<span class="string">"canceled due to <span class="variable">$t</span>"</span>)</span><br><span class="line">        canceledException.addSuppressed(t)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">throw</span> t</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>run</code>函数，通过<code>getResponseWithInterceptorChain()</code>函数返回了响应数据，可见在该函数里面进行了网络请求。</p>
<p>再回到同步请求中，即调用<code>realCall</code>的<code>execute</code>函数。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response {</span><br><span class="line">  check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) { <span class="string">"Already Executed"</span> }</span><br><span class="line"></span><br><span class="line">  timeout.enter()</span><br><span class="line">  callStart()</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，同步请求直接调用了<code>getResponseWithInterceptorChain()</code>函数，而不是交给线程池去执行。因此同步请求 的时候记得切换到子线程执行。</p>
<h3 id="getresponsewithinterceptorchain"><a class="markdownIt-Anchor" href="#getresponsewithinterceptorchain"></a> <code>getResponseWithInterceptorChain</code></h3>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response {</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) {</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  }</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) {</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) {</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getResponseWithInterceptorChain()</code>函数先是将我们自定义的拦截器和默认的拦截器添加到集合中，并创建<code>RealInterceptorChain</code>对象<code>chain</code>，即所谓的拦截链。然后调用<code>chain.proceed(originalRequest)</code>返回响应数据。每一个拦截器都会实现自己特定的功能，并在自己的重载的<code>intercept</code>函数中调用<code>chain.proceed(request)</code>函数去调用下一个拦截器的<code>intercept</code>函数。这里<code>request</code>已经不再是原始的<code>originalRequest</code>，而且经过当前拦截器改造，假如需要的话。先不管每个拦截器分做了什么，大概就知道了拦截链的调用图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210302114511.png" alt="未命名绘图"></p>
<h2 id="拦截链"><a class="markdownIt-Anchor" href="#拦截链"></a> 拦截链</h2>
<p>在<code>OkHttp</code>中，最重要的就是拦截链中每个拦截器的工作。例如发起网络请求的<code>CallServerInterceptor</code>,网络连接的<code>ConnectInterceptor</code>,缓存策略的<code>CacheInterceptor</code>,桥接模式的<code>BridgeInterceptor</code>,重试恢复的<code>RetryAndFollowUpInterceptor</code>。以及我们自定义的<code>Interceptor</code>,可以用来打印日志等。从它们在拦截链的不同位置，以及所做的事情，可以掌握更好的自定义的Interceptor。</p>
<h3 id="网络请求callserverinterceptor"><a class="markdownIt-Anchor" href="#网络请求callserverinterceptor"></a> 网络请求：<code>CallServerInterceptor</code></h3>
<p>那么，我们假装所有拦截器都会调用下一个拦截器，直到最后的<code>CallServerInterceptor</code>拦截器。作为拦截链最后一个拦截器，只重写了<code>intercept</code>函数，并进行真正的网络请求。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">   <span class="keyword">val</span> exchange = realChain.exchange!!</span><br><span class="line">   <span class="keyword">val</span> request = realChain.request</span><br><span class="line">   <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">   <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">   exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> invokeStartEvent = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">     <span class="comment">//除了head+get,其他返回false，因为其他需要请求体</span></span><br><span class="line">   <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) {</span><br><span class="line">     <span class="comment">//客户端请求头携带"Expect: 100-continue"表示告诉服务器，客户端有一个期望值（例如请求体很大），希望得到服务器能否妥善处理该请求，响应报文状态码：100能417不能</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) {</span><br><span class="line">       exchange.flushRequest()</span><br><span class="line">       <span class="comment">//responseBuilder=null表示服务器能处理</span></span><br><span class="line">       responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">       invokeStartEvent = <span class="literal">false</span></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) {</span><br><span class="line">       <span class="keyword">if</span> (requestBody.isDuplex()) {</span><br><span class="line">         <span class="comment">//Http 2.0全双工，发送请求，并将请求体写到底层TCP发送缓存</span></span><br><span class="line">         exchange.flushRequest()</span><br><span class="line">         <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">         requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">//服务器能处理`"Expect: 100-continue"`期望，将请求体写到底层TCP发送缓存</span></span><br><span class="line">         <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">         requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">         bufferedRequestBody.close()</span><br><span class="line">       }</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       exchange.noRequestBody()</span><br><span class="line">       <span class="keyword">if</span> (!exchange.connection.isMultiplexed) {</span><br><span class="line">          <span class="comment">//非100-continue情况下，防止HTTP/1.1的使用</span></span><br><span class="line">         exchange.noNewExchangesOnConnection()</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     exchange.noRequestBody()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) {</span><br><span class="line">     exchange.finishRequest()</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//开始获取响应头</span></span><br><span class="line">   <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) {</span><br><span class="line">     responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">     <span class="keyword">if</span> (invokeStartEvent) {</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">       invokeStartEvent = <span class="literal">false</span></span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">       .request(request)</span><br><span class="line">       .handshake(exchange.connection.handshake())</span><br><span class="line">       .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">       .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">       .build()</span><br><span class="line">   <span class="keyword">var</span> code = response.code</span><br><span class="line">   <span class="comment">//服务器响应：Expect：100-continue </span></span><br><span class="line">   <span class="keyword">if</span> (code == <span class="number">100</span>) {</span><br><span class="line">  <span class="comment">//重新读取响应头</span></span><br><span class="line">     responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">     <span class="keyword">if</span> (invokeStartEvent) {</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">     }</span><br><span class="line">     response = responseBuilder</span><br><span class="line">         .request(request)</span><br><span class="line">         .handshake(exchange.connection.handshake())</span><br><span class="line">         .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build()</span><br><span class="line">     code = response.code</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//响应头读取结束</span></span><br><span class="line">   exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">   response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) {</span><br><span class="line">     <span class="comment">// 表示服务器支持协议升级，切换到websocket或者HTTP 2。</span></span><br><span class="line">     response.newBuilder()</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .build()</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     response.newBuilder()</span><br><span class="line">         .body(exchange.openResponseBody(response)) <span class="comment">//获取响应数据真正地方</span></span><br><span class="line">         .build()</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">       <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) {</span><br><span class="line">     exchange.noNewExchangesOnConnection()<span class="comment">//关闭连接</span></span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) {</span><br><span class="line">     <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">         <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">${response.body?.contentLength()}</span>"</span>)</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> response</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>整块代码看下来，主要是为了区别下面几种情况：</p>
<ul>
<li>
<p><strong>Expect：100-continue</strong>: 客户端请求报文携带该请求头字段，表示期望服务器能处理客户端的某个期望，例如大报文。如果能满足该条件，服务器则返回状态码是100的响应报文。</p>
<p><code>OKHttp</code>的处理是，如果满足该条件，直接发送请求，开始等待服务器响应，若服务器支持，则直接将请求报文数据写到发送缓存中。</p>
</li>
<li>
<p><strong>全双工 HTTP2.0</strong>：因为目前HTTP中只有2.0版本支持全双工，全双工的过程中，请求报文与响应报文的传输会有交差的情况，HTTP/1.1 半双工不存在这种情况。</p>
<p><code>OKHttp</code>的处理是，如果满足该条件，直接发送请求，开始等待服务器响应，若服务器支持，则直接将请求报文数据写到发送缓存中。</p>
</li>
<li>
<p><strong>一般情况</strong>：直接调用<code>exchange.noRequestBody()</code>进行请求。</p>
</li>
</ul>
<p>最后通过根据响应头判断是否需要协议升级，否则通过<code>exchange.openResponseBody(response)</code>获取响应数据部分。</p>
<p>所以大概流程就是：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">exchange.flushRequest()</span><br><span class="line"><span class="comment">//写请求数据部分</span></span><br><span class="line"><span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">requestBody.writeTo(bufferedRequestBody)</span><br><span class="line"><span class="comment">//结束请求</span></span><br><span class="line">exchange.finishRequest()</span><br><span class="line"><span class="comment">//开始读取响应头</span></span><br><span class="line">exchange.responseHeadersStart()</span><br><span class="line"><span class="comment">//读取响应头</span></span><br><span class="line">exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line"><span class="comment">//结束读取响应头</span></span><br><span class="line">exchange.responseHeadersEnd(response)</span><br><span class="line"><span class="comment">//读取响应体</span></span><br><span class="line">exchange.openResponseBody(response)</span><br></pre></td></tr></tbody></table></figure>
<p>而在正常获得响应数据后，回调<code>Callback</code>对象的<code>onResponse</code>函数。到此，整个过程也就结束了。</p>
<h3 id="连接复用connectinterceptor"><a class="markdownIt-Anchor" href="#连接复用connectinterceptor"></a> 连接复用：<code>ConnectInterceptor</code></h3>
<p><code>ConnectInterceptor</code>连接拦截器的<code>intercept</code>函数非常简单，但却涉及到<code>OkHttp</code>的一个重要概念，<strong>连接复用</strong>。众所周知，HTTP是基于运输层的TCP协议（HTTP/3将基于UDP协议），意味着TCP三次握手建立连接和4次挥手断开连接，以及拥塞机制的慢启动阶段,都会影响到APP性能和数据响应速度。通过TCP连接的复用，能有效提高效率和降低时延。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>intercept</code>函数中最重要的代码<code>realChain.call.initExchange(chain)</code>，创建或复用一条TCP连接进行HTTP请求或响应。这里有条调用链：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealCall.initExchange-&gt;ExchangeFinder.find-&gt;ExchangeFinder.findHealthyConnection</span><br><span class="line">-&gt;ExchangeFinder.findConnection</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>findConnection</code>函数中，查找有用的连接步骤：</p>
<ol>
<li>复用当前请求<code>RealCall</code>的连接。如果当前<code>RealCall</code>携带的连接<code>connection</code>不为<code>null</code>，且端口号与主机与当前主机请求一致。判断是否有其他请求<code>call</code>在该<code>connection</code>与服务器交互，没有的情况下通知连接池释放该连接，并返回Socket，并复用该<code>connection</code>。</li>
<li>在连接池中寻找。遍历连接池中所有的<code>connection</code>，通过<code>connection.isEligible</code>来判断是否可以复用该<code>connection</code>。<code>isEligible</code>函数会检查很多东西，例如域名、域名、代理、DNS等等是否一致。甚至HTTP/2的<code>connect</code>的一些要求，例如证书。</li>
<li>创建新的连接。如果在前两步没有找到合适的<code>connection</code>，只能创建新的<code>connection</code>了。在创建新的连接前，还会在创建路由后，再尝试在连接池中寻找合适的<code>connection</code>。否则会为当前请求<code>call</code>创建新的<code>connection</code>并添加在连接池。</li>
</ol>
<p><strong>连接池：<code>RealConnectionPool</code></strong></p>
<p><code>RealConnectionPool</code>内部有一个<code>ConcurrentLinkedQueue&lt;RealConnection</code>类型的<code>connections</code>，用于持有所有连接。在创建<code>OkHttpClient</code>时，会创建默认的最大空闲连接数为5，存活时间为5分钟的连接池。</p>
<h3 id="缓存策略cacheinterceptor"><a class="markdownIt-Anchor" href="#缓存策略cacheinterceptor"></a> 缓存策略：<code>CacheInterceptor</code></h3>
<p>缓存拦截器通常情况下只支持<code>GET</code>方法请求的缓存，每次请求都会先根据URL计算出key,然后在<code>DiskLruCache</code>中获取缓存快照（上次请求缓存的数据），假如有的话。然后根据缓存快照和请求报文，生成缓存策略，即根据请求报文和响应报文的首部行中相关字段（<code>Cache-Control</code>、<code>Etag</code>等等）来生成策略。根据不同的缓存策略进行不同的操作。</p>
<ol>
<li>
<p>通过url的md5+hex获取缓存快照</p>
<p>通过<code>Request</code>的<code>URL</code>计算出的<code>md5</code>的<code>hex</code>值作为<code>key</code>，来获取<code>DiskLruCache</code>中的缓存快照<code>SnapShot</code>。<code>Snapshot</code>缓存了请求报文和响应报文的相关数据，例如请求报文的请求行和响应报文的状态行。通过<code>SnapShot</code>构建<code>Entry</code>对象，该对象主要存储了请求报文和响应报文的首部信息。最后通过<code>Entry</code>和<code>SnapShot</code>的创建出缓存响应<code>Response</code>。</p>
<p><code>SnapShot</code>通过<code>snapshot.getSource(ENTRY_METADATA)</code>获取首部元数据信息，和<code>snapshot.getSource(ENTRY_BODY)</code>获取缓存的响应报文数据部分。</p>
</li>
<li>
<p><code>CacheStrategy.Factory</code>计算缓存策略</p>
<p>通过<code>CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</code>生成的<code>CacheStartegy</code>对象含有两个属性<code>networkRequest</code>和<code>cacheResponse</code>,当<code>cacheResponse==null</code>表示不使用缓存，从服务器拉取数据；当<code>networkRequest==null</code>表示强制使用缓存。同时为<code>null</code>,表示不满足<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>only-if-cached</code></a>。<code>compute</code>函数主要是根据请求报文和响应报文的请求头来生成缓存策略。</p>
<p>**<code>cacheResponse==null</code>**情况：</p>
<ul>
<li>本地没有缓存，即第一步得出的<code>cacheCandidate==nll</code>。</li>
<li>HTTP中不支持缓存的报文或者请求报文和响应报文首部行设置了<code>Cache-Control:no-store</code></li>
<li>缓存的响应报文请求头都没设置<code>ETag</code>,<code>Last-Modified</code>,<code>Date</code>字段。</li>
</ul>
<p>**<code>networkRequest==null</code>**情况：</p>
<ul>
<li>request设置了<code>Cache-Control:only-if-cached</code>。</li>
<li>使用协商缓存，且缓存未过期。</li>
</ul>
</li>
<li>
<p>判断<code>networkRequest==null</code>的情况，表示只使用缓存。</p>
</li>
<li>
<p>发起网络请求，若服务器响应304且本地缓存不为null，则使用本地缓存，并更新本地缓存。</p>
</li>
<li>
<p>最后将请求报文和响应报文存放到缓存中，仅支持<strong>GET缓存</strong>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> call = chain.call()</span><br><span class="line">   <span class="comment">//第一步:通过url的md5+hex获取缓存快照</span></span><br><span class="line">   <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"><span class="comment">//计算缓存策略</span></span><br><span class="line">   <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">   <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">   <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">   cache?.trackResponse(strategy)</span><br><span class="line">   <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) {</span><br><span class="line">     <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">     cacheCandidate.body?.closeQuietly()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//请求报文使用缓存，即请求头携带`Cache-Control：if-only-cached`</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">return</span> Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">         .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build().also {</span><br><span class="line">           listener.satisfactionFailure(call, it)</span><br><span class="line">         }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// networkRequest==null表示不使用网络请求</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build().also {</span><br><span class="line">           listener.cacheHit(call, it)</span><br><span class="line">         }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">     listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">   } <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) {</span><br><span class="line">     listener.cacheMiss(call)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     	<span class="comment">//发起网络请求，也就是会调用CallServerInterceptor的intercept函数</span></span><br><span class="line">       networkResponse = chain.proceed(networkRequest)</span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">     <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">     <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) {</span><br><span class="line">       cacheCandidate.body?.closeQuietly()</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果有本地缓存，且服务器返回304报文的，则使用响应报文</span></span><br><span class="line">   <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) {</span><br><span class="line">       <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build()</span><br><span class="line"></span><br><span class="line">       networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">       <span class="comment">//更新缓存</span></span><br><span class="line">       cache!!.trackConditionalCacheHit()</span><br><span class="line">       cache.update(cacheResponse, response)</span><br><span class="line">       <span class="keyword">return</span> response.also {</span><br><span class="line">         listener.cacheHit(call, it)</span><br><span class="line">       }</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       cacheResponse.body?.closeQuietly()</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {</span><br><span class="line">       <span class="comment">//存放缓存</span></span><br><span class="line">       <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">       <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also {</span><br><span class="line">         <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">           <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">           listener.cacheMiss(call)</span><br><span class="line">         }</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">  <span class="comment">//仅支持GET缓存</span></span><br><span class="line">     <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) {</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">         cache.remove(networkRequest)</span><br><span class="line">       } <span class="keyword">catch</span> (_: IOException) {</span><br><span class="line">         <span class="comment">// The cache cannot be written.</span></span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> response</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="桥接模式bridgeinterceptor"><a class="markdownIt-Anchor" href="#桥接模式bridgeinterceptor"></a> 桥接模式：BridgeInterceptor</h3>
<p>之所以将它称为桥接模式拦截器，是因为它将应用发起的请求转化成HTTP请求所需的内容，将网络响应数据转化成应用数据。其实也没那么神奇，就是已有的Request，判断请求报文是否添加一些头部信息，没有话就帮我们添加，如：<code>Content-Type</code>、<code>Content-Length</code>等等。</p>
<p>请求报文首部行：</p>
<ul>
<li><code>Content-Type</code>:如果在<code>ReqeuestBody</code>添加了<code>ContentType</code>,则帮我们添加到<code>header</code>。</li>
<li><code>Content-Length</code>:如果<code>ReqeuestBody</code>的<code>contentLength</code>没有设置，则添加<code>Transfer-Encoding:chunked</code>,否则添加到<code>header</code>。</li>
<li><code>Transfer-Encoding:chunked</code>,在没有<code>ReqeuestBody</code>情况下才会设置该请求头。</li>
<li><code>Host:域名</code></li>
<li><code>Connection:Keep-Alive</code></li>
<li><code>Accept-Encoding: gzip</code>如果帮我们添加了该请求头，还要负责帮我们解压缩。</li>
<li><code>Cookie:XXX</code> 假如有的话</li>
<li><code>User-Agent:okhttp/${OkHttp.VERSION}</code></li>
</ul>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">   <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> body = userRequest.body </span><br><span class="line">   <span class="keyword">if</span> (body != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">     <span class="keyword">if</span> (contentType != <span class="literal">null</span>) {</span><br><span class="line">       requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">     <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) {</span><br><span class="line">       requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//Host:域名 请求头</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//Connection:Keep-Alive HTTP1.1 短连接请求头</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">   <span class="comment">// the transfer stream.</span></span><br><span class="line">   <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     transparentGzip = <span class="literal">true</span></span><br><span class="line">     requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">   <span class="keyword">if</span> (cookies.isNotEmpty()) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">   cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">       .request(userRequest)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">       <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">       networkResponse.promisesBody()) {</span><br><span class="line">     <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">     <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) {</span><br><span class="line">       <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">       <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">           .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">           .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">           .build()</span><br><span class="line">       responseBuilder.headers(strippedHeaders)</span><br><span class="line">       <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">       responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="重试恢复retryandfollowupinterceptor"><a class="markdownIt-Anchor" href="#重试恢复retryandfollowupinterceptor"></a> 重试恢复：RetryAndFollowUpInterceptor</h3>
<p>该拦截器在客户端允许重试恢复机制下，主要根据网络请求抛出的一些异常类型或者响应报文的状态码，进行重试恢复请求。如果该异常或者状态码不支持恢复，或者重试次数达到了设置次数，则抛出异常，本次客户端发起的请求。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) {</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      } <span class="keyword">catch</span> (e: RouteException) {</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) {</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        }</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) {</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        }</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">//while是一个死循环</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) {</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">//判读一些常见的网络错误或者重定向，例如400，然后尝试新建request的恢复连接</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) {</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        }</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) {</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) {</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>recover</code>函数主要检测发生的异常是否属于可以恢复的类型。如果设置了<code>client.retryOnConnectionFailure=false</code>,直接抛出异常不会重新进行请求。主要是根据一些错误的类型，来判断该错误是否避免，如果不能避免就直接抛异常，可以的话重新进入下次<code>while</code>循环。</p>
<h2 id="自定义拦截器"><a class="markdownIt-Anchor" href="#自定义拦截器"></a> 自定义拦截器</h2>
<p>我们自定的拦截器有两种，一种是普通的应用拦截器，也就是拦截链最开始的地方。第二种是网络拦截器，在拦截链倒数第二，即发起网络前。前者处于拦截链的前端，可以多次调用拦截链后续的拦截器，但拦截不到它们处理的内容。后者只有发起网络才会被拦截到，例如命中缓存的话，并不会调用到。因此在自定义拦截器时，要根据具体的需求实现不同拦截器。</p>
<h2 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h2>
<p>OkHttp的拦截链使用了责任链设计模式，将一个请求交给多个对象处理，解耦了请求的发送者和接收者。将对象构成链，并将请求沿着该链传递，直到某个处理对象终止该请求。例如缓存拦截器命中缓存后终止将请求交付给下个一个处理对象。</p>
<p>每个处理对象根据自己的特性，即处理能力，当请求满足自身条件，则进行处理而不继续传递。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2>
<p>通过分析OkHttp的源码，发现大部分的HTTP知识点，也就是OkHttp自己实现了一套从低到上的网络请求框架。以前总以为OkHttp应该很复杂，毕竟那么流行。却没想到如此的基础和稳定，学习了，不要惧怕源码，勇敢过去学。</p>
<hr>
<p><strong>【相关连接】</strong></p>
<p><a target="_blank" rel="noopener" href="https://xxm-sz.github.io/2021/03/06/Http%E4%B8%8EHttps/">HTTP与HTTPS</a></p>
<p><a target="_blank" rel="noopener" href="https://xxm-sz.github.io/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/">运输层TCP</a></p>
<p><a target="_blank" rel="noopener" href="https://xxm-sz.github.io/2021/03/02/OkHttp%E4%BD%BF%E7%94%A8/#%E6%91%98%E8%A6%81">OkHttp使用</a></p>
<p>欢迎<strong>点赞+关注+评论三连击</strong></p>
<p>【<a target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a>】【<a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a>】</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OkHttp/">OkHttp</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/03/18/Retrofit%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>Retrofit 源码分析</span></a></div><div class="next-post pull-right"><a href="/2021/03/06/Http%E4%B8%8EHttps/"><span>HTTP与HTTPS</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>