<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Retrofit 源码分析"><meta name="keywords" content="Retrofit,源码分析"><meta name="author" content="zhangws"><meta name="copyright" content="zhangws"><title>Retrofit 源码分析 | 新小梦</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="新小梦" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text"> 摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text"> 流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text"> 动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadservicemethod"><span class="toc-number">2.2.</span> <span class="toc-text"> loadServiceMethod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#servicemethodparseannotations"><span class="toc-number">2.3.</span> <span class="toc-text"> ServiceMethod.parseAnnotations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestfactoryparseannotations"><span class="toc-number">2.4.</span> <span class="toc-text"> RequestFactory.parseAnnotations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#httpservicemethodparseannotations"><span class="toc-number">2.5.</span> <span class="toc-text"> HttpServiceMethod.parseAnnotations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createcalladapter"><span class="toc-number">2.6.</span> <span class="toc-text"> createCallAdapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadservicemethodmethodinvokeargs"><span class="toc-number">2.7.</span> <span class="toc-text"> loadServiceMethod(method).invoke(args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-number">2.8.</span> <span class="toc-text"> 网络请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createresponseconverter"><span class="toc-number">2.9.</span> <span class="toc-text"> createResponseConverter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text"> 协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-2"><span class="toc-number">4.</span> <span class="toc-text"> 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text"> 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210205152041.png"></div><div class="author-info__name text-center">zhangws</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917">关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/xxm-sz">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/888061125471917/posts">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xxm-sz.github.io/">博客</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">新小梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Retrofit 源码分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>通过分析Retrofit源码，了解这款简洁的网络库如何提高我们的工作效率。通过动态代理技术，创建我们接口对象，以提供我们调用接口函数。通过解析接口定义的函数，装配成<code>OkHttp</code>网络请求所需的数据并发起网络请求。我们可以根据自己的需求，自定义请求适配器和响应转换器。</p>
<h2 id="流程分析"><a class="markdownIt-Anchor" href="#流程分析"></a> 流程分析</h2>
<h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3>
<p>我们定义了<code>service</code>接口，并通过<code>retrofit</code>对象的<code>create</code>函数创建了<code>service</code>类型的对象。通过该对象，我们可以调用在<code>service</code>接口定义的函数，从而发起定义的网络请求。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val service=retrofit.create(service::class.java)</span><br></pre></td></tr></tbody></table></figure>
<p><code>Retrofit</code>通过动态代理技术生成我们定义<code>service</code>接口代理对象，因此调用代理对象的函数时都会转发到<code>InvocationHandler</code>对象的<code>invoke</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>{</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] {service},</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">              <span class="comment">//判断是否Obect的默认方法</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) {</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              }</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              <span class="comment">//判断是否特定平台的方法，例如Android</span></span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            }</span><br><span class="line">          });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="loadservicemethod"><a class="markdownIt-Anchor" href="#loadservicemethod"></a> <code>loadServiceMethod</code></h3>
<p>在<code>invoke</code>函数，我们只关心<code>loadServiceMethod(method).invoke(args)</code>函数。<code>loadServiceMethod(method)</code>函数会返回一个<code>ServiceMethod</code>对象，<code>ServiceMethod</code>是一个抽象类，唯一直接实现类是<code>HttpServiceMethod</code>。也就是说这里调用了<code>HttpServiceMethod.invoke(args)</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) {</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>loadServiceMethod</code>函数主要先通过缓存<code>serviceMethodCache</code>获取<code>ServiceMethod</code>对象，如果缓存中没有获取到<code>ServiceMethod</code>对象，则通过<code>ServiceMethod.parseAnnotations</code>解析获取<code>ServiceMethod</code>对象，并将其放在缓存中。<code>serviceMethodCache</code>是一个<code>ConcurrentHashMap</code>，以<code>Method</code>为<code>Key</code>,<code>ServiceMethod</code>为<code>value</code>。<code>ServiceMethod.parseAnnotations(this, method)</code>主要是解析<code>Method</code>对象（我们定义的方法）的注解，参数及注解以及返回类型,然后通过<code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>生成<code>ServerMethod</code>对象。</p>
<h3 id="servicemethodparseannotations"><a class="markdownIt-Anchor" href="#servicemethodparseannotations"></a> <code>ServiceMethod.parseAnnotations</code></h3>
<p>该函数分别调用了<code>RequestFactory</code>类和<code>HttpServiceMethod</code>的<code>parseAnnotations</code>函数。<code>RequestFactory</code>类主要封装本次网络请求的大多数信息，例如<code>method</code>，<code>headers</code>,<code>httpMethod</code>等等。<code>HttpServiceMethod</code>是<code>ServerMethod</code>的子类，主要用来创建请求适配器和数据转换器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>{</span><br><span class="line">  <span class="comment">//解析方法的注解和参数的注解及值</span></span><br><span class="line">  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"><span class="comment">//解析方法的注解和参数的注解及返回值</span></span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) {</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        method,</span><br><span class="line">        <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">        returnType);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) {</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="requestfactoryparseannotations"><a class="markdownIt-Anchor" href="#requestfactoryparseannotations"></a> <code>RequestFactory.parseAnnotations</code></h3>
<p><code>RequestFactory.parseAnnotations(retrofit, method)</code>通过构建者模式创建<code>RequestFactory</code>对象。构建的过程主要是解析传递进来的参数<code>method</code>对象上相关信息，并赋值到<code>RequestFactory</code>对象相关属性上。<code>Method</code>对象代表着反射上的一个函数，包含这个该函数的相关信息，例如注解，参数，返回类型等。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Builder(Retrofit retrofit, Method method) {</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">//1、解析方法上注解</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) {</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  }</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) {</span><br><span class="line">      <span class="comment">//解析函数参数，包括其注解和值</span></span><br><span class="line">      parameterHandlers[p] =</span><br><span class="line">        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">  }</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>build</code>函数主要解析方法上的注解，参数注解。 <code>parseMethodAnnotation(annotation)</code>用来解析方法的注解，根据<code>anotation</code>的类型，例如<code>GET</code>、<code>POST</code>等等，然后根据这些方法类型在HTTP报文对应的特性，设置相关属性，例如<code>GET</code>类型的请求没有请求体<code>hasBody=false</code>,POST类型的<code>hasBody=true</code>。</p>
<p>通过<code>parseParameter</code>解析函数参数注解和获取对应的值。参数注解的解析和函数注解的解析类似，主要检查我们使用方式是否正确和设置相关属性。并且也会判断当前函数是否<code>Kotlin</code>协程中的挂起函数（后文分析）。</p>
<h3 id="httpservicemethodparseannotations"><a class="markdownIt-Anchor" href="#httpservicemethodparseannotations"></a> <code>HttpServiceMethod.parseAnnotations</code></h3>
<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>又是干了什么呢？将上面解析生成的<code>RequestFactory</code>，生成请求适配器<code>CallAdapter</code>和响应转换器<code>Converter</code>,然后将三者封装到<code>HttpServiceMethod</code>的子类并返回。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>{</span><br><span class="line">   <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">   <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   Annotation[] annotations = method.getAnnotations();</span><br><span class="line">   Type adapterType;</span><br><span class="line">   <span class="keyword">if</span> (isKotlinSuspendFunction) {<span class="comment">//是否支持协程</span></span><br><span class="line">     Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">     Type responseType =</span><br><span class="line">         Utils.getParameterLowerBound(</span><br><span class="line">             <span class="number">0</span>, (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">     <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">       <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">       responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">       continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       <span class="comment">// TODO figure out if type is nullable or not</span></span><br><span class="line">       <span class="comment">// Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)</span></span><br><span class="line">       <span class="comment">// Find the entry for method</span></span><br><span class="line">       <span class="comment">// Determine if return type is nullable or not</span></span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">     annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     adapterType = method.getGenericReturnType(); <span class="comment">//获取方法的返回类型</span></span><br><span class="line">   }</span><br><span class="line"><span class="comment">//遍历Retrofit的CallAdapter列表，寻找是否有符合处理该adapterType的CallAdapter</span></span><br><span class="line">   CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">       createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">   Type responseType = callAdapter.responseType();</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line">       </span><br><span class="line"><span class="comment">//遍历Retrofit的转换器列表，寻找合适的转换器</span></span><br><span class="line">   Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">       createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">   okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">   <span class="keyword">if</span> (!isKotlinSuspendFunction) {</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<span class="comment">//非协程情况下，HtttpServerMethod的子类</span></span><br><span class="line">   } <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) {</span><br><span class="line">     <span class="comment">//使用了协程，且返回类型Response</span></span><br><span class="line">     <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">         <span class="keyword">new</span> SuspendForResponse&lt;&gt;(</span><br><span class="line">             requestFactory,</span><br><span class="line">             callFactory,</span><br><span class="line">             responseConverter,</span><br><span class="line">             (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     <span class="comment">//使用了协程，且返回类型ResponseBody</span></span><br><span class="line">     <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">         <span class="keyword">new</span> SuspendForBody&lt;&gt;(</span><br><span class="line">             requestFactory,</span><br><span class="line">             callFactory,</span><br><span class="line">             responseConverter,</span><br><span class="line">             (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">             continuationBodyNullable);</span><br><span class="line">   }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>在创建<code>CallAdatper</code>和<code>Converter</code>后,根据是否协程，返回不同的<code>HttpServiceMethod</code>子类。</p>
<h3 id="createcalladapter"><a class="markdownIt-Anchor" href="#createcalladapter"></a> <code>createCallAdapter</code></h3>
<p>其中<code>createCallAdapter(retrofit, method, adapterType, annotations);</code>创建<code>CallAdapted</code>对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  } <span class="keyword">catch</span> (RuntimeException e) { <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>retrofit.callAdapter(returnType, annotations)</code>，根据返回类型<code>retrunType</code>选择合适的请求适配器。需要注意到的是，这里是从头开始遍历，如果前面适配器符合条件，意味着会被优先选用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {</span><br><span class="line">   <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(</span><br><span class="line">     <span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {</span><br><span class="line">......</span><br><span class="line">   <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) {</span><br><span class="line">     CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) {</span><br><span class="line">       <span class="keyword">return</span> adapter;</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">......</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>nextCallAdapter</code>函数主要通过循环遍历在构建<code>Retrofit</code>是保存在<code>callAdapterFactories</code>列表的<code>CallAdapter</code>,通过其<code>get</code>函数查看是否匹配。如果<code>Android SDK_INT&gt;=24</code>返回的是<code>CompletableFutureCallAdapterFactory</code>,否则返回的是<code>DefaultCallAdapterFactory</code>。</p>
<p>看看<code>CompletableFutureCallAdapterFactory</code>对象的<code>get</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">     Type returnType, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">   <span class="keyword">if</span> (getRawType(returnType) != CompletableFuture.class) {</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) {</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">"CompletableFuture return type must be parameterized"</span></span><br><span class="line">             + <span class="string">" as CompletableFuture&lt;Foo&gt; or CompletableFuture&lt;? extends Foo&gt;"</span>);</span><br><span class="line">   }</span><br><span class="line">   Type innerType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (getRawType(innerType) != Response.class) {</span><br><span class="line">     <span class="comment">// Generic type is not Response&lt;T&gt;. Use it for body-only adapter.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> BodyCallAdapter&lt;&gt;(innerType);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Generic type is Response&lt;T&gt;. Extract T and create the Response version of the adapter.</span></span><br><span class="line">   <span class="keyword">if</span> (!(innerType <span class="keyword">instanceof</span> ParameterizedType)) {</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">"Response must be parameterized"</span> + <span class="string">" as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"</span>);</span><br><span class="line">   }</span><br><span class="line">   Type responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) innerType);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ResponseCallAdapter&lt;&gt;(responseType);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p><code>CompletableFutureCallAdapterFactory</code>的<code>get</code>函数根据函数返回类型是否与自己要处理的返回类型一致，不一致则返回null，表示不处理，例如这里是<code>CompletableFuture</code>。然后进一步检查返回值的合法性，例如是不是泛型对象。最终根据泛型对象最外层类型返回<code>CallAdapter</code>的子类<code>BodyCallAdapter</code>或<code>ResponseCallAdapter</code>。两者的主要区别是其<code>adapt</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BodyCallAdapter   </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;R&gt; <span class="title">adapt</span><span class="params">(<span class="keyword">final</span> Call&lt;R&gt; call)</span> </span>{</span><br><span class="line">  CompletableFuture&lt;R&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> BodyCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//ResponseCallAdapter</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Response&lt;R&gt;&gt; adapt(<span class="keyword">final</span> Call&lt;R&gt; call) {</span><br><span class="line">  CompletableFuture&lt;Response&lt;R&gt;&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> ResponseCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="loadservicemethodmethodinvokeargs"><a class="markdownIt-Anchor" href="#loadservicemethodmethodinvokeargs"></a> <code>loadServiceMethod(method).invoke(args)</code></h3>
<p>回到<code>loadServiceMethod(method).invoke(args)</code>，也就是说，这里实际调用了<code>CallAdapter</code>对象的<code>invoke</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>{</span><br><span class="line">	Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, 					responseConverter);</span><br><span class="line">	<span class="keyword">return</span> adapt(call, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>invoke</code>函数主要是构建<code>OkHttpCall</code>并调用<code>adapt</code>函数。这里分析<code>ResponseCallAdapter</code>的<code>adapt</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Response&lt;R&gt;&gt; adapt(<span class="keyword">final</span> Call&lt;R&gt; call) {</span><br><span class="line">  CompletableFuture&lt;Response&lt;R&gt;&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> ResponseCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="网络请求"><a class="markdownIt-Anchor" href="#网络请求"></a> 网络请求</h3>
<p><code>adapt</code>函数调用了<code>OkHttpCall</code>的<code>enqueue</code>函数。是不是跟<code>OKHttp</code>的异步请求很相似。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{</span><br><span class="line">  Objects.requireNonNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        throwIfFatal(t);</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failure != <span class="keyword">null</span>) {</span><br><span class="line">    callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) {</span><br><span class="line">    call.cancel();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  call.enqueue(</span><br><span class="line">      <span class="keyword">new</span> okhttp3.Callback() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>{</span><br><span class="line">          Response&lt;T&gt; response;</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            response = parseResponse(rawResponse);<span class="comment">//解析 原始数据，调用转化适配器</span></span><br><span class="line">          } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            throwIfFatal(e);</span><br><span class="line">            callFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">          } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            throwIfFatal(t);</span><br><span class="line">            t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>{</span><br><span class="line">          callFailure(e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>{</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">          } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            throwIfFatal(t);</span><br><span class="line">            t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>enqueue</code>函数的简单分析，就是创建<code>OkHttp</code>的<code>Call</code>对象,并调用<code>enqueue</code>函数。然后发起网络请求，请求成功之后调用<code>parseResponse</code>解析响应数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">   ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">   rawResponse =</span><br><span class="line">       rawResponse</span><br><span class="line">           .newBuilder()</span><br><span class="line">           .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">           .build();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">   <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">       <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">       rawBody.close();</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) {</span><br><span class="line">     rawBody.close();</span><br><span class="line">     <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     T body = responseConverter.convert(catchingBody); <span class="comment">//转换响应数据</span></span><br><span class="line">     <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">   } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">     <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">     <span class="comment">// a runtime exception.</span></span><br><span class="line">     catchingBody.throwIfCaught();</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="createresponseconverter"><a class="markdownIt-Anchor" href="#createresponseconverter"></a> <code>createResponseConverter</code></h3>
<p>重点地方就是在函数最后的地方调用了<code>T body = responseConverter.convert(catchingBody);</code>将原始数据转化成我们需要的数据类型。在<code>HttpServiceMethod</code>的<code>parseAnnotations</code>函数中<code>createResponseConverter</code>创建响应数据转换器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Retrofit retrofit, Method method, Type responseType)</span> </span>{</span><br><span class="line">   Annotation[] annotations = method.getAnnotations();</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">   } <span class="keyword">catch</span> (RuntimeException e) { <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">     <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>{</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) {</span><br><span class="line">     Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">         converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (converter != <span class="keyword">null</span>) {</span><br><span class="line">       <span class="comment">//noinspection unchecked</span></span><br><span class="line">       <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">......</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>响应转换器与请求适配器的创建过程很相似。在创建Retrofit对象时，会将相关转化器保存到<code>converterFactories</code>列表，通过转化器的<code>responseBodyConverter</code>函数判断是否处理该响应数据。这里看下<code>OptionalConverterFactory</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Converter.Factory INSTANCE = <span class="keyword">new</span> OptionalConverterFactory();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">      Type type, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">    <span class="keyword">if</span> (getRawType(type) != Optional.class) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Type innerType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) type);</span><br><span class="line">    Converter&lt;ResponseBody, Object&gt; delegate =</span><br><span class="line">        retrofit.responseBodyConverter(innerType, annotations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptionalConverter&lt;&gt;(delegate);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IgnoreJRERequirement</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    OptionalConverter(Converter&lt;ResponseBody, T&gt; delegate) {</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(delegate.convert(value));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>responseBodyConverter</code>逻辑很简单，判断放回类型<code>Type</code>是不是<code>Optional.class</code>,然后返回<code>OptionalConverter</code>。那么网络成功返回数据就会调用<code>convert</code>函数，而这个直接委托给下一个转化器。</p>
<p>而在构建<code>converterFactories</code>列表的时候，会优先添加<code>BuiltInConverters</code>,然后是我们自定义的转换器，最后如果Android SDK&gt;=24,才添加<code>OptionalConverterFactory</code>。也就是说从这里可以看到优先权。</p>
<p>而构建<code>callAdapterFactories</code>列表，则是先我们自定义的，再是平台默认的适配器。</p>
<p>通常情况下，我们都会添加<code>GsonConverterFactory</code>适配器，将<code>gson</code>转化成对象类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">    Type type, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>GsonResponseBodyConverter</code>的<code>convert</code>函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    T result = adapter.read(jsonReader);</span><br><span class="line">    <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">"JSON document was not fully consumed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    value.close();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到这里，Retrofit整个源码流程就分析完了。所以也应该学会了如何自定适配器和转换器了。</p>
<h2 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h2>
<p>Retrofit在目前版本2.6.0开始就已经支持协程，即允许在接口中定义挂起函数。那Retrofit如何确定接口定义的函数是挂起函数呢？</p>
<p>在上一节分析<code>RequestFactory.parseAnotations</code>中分析函数注解，说到<code>parseParameter</code>解析函数参数注解，有提到判断函数是否挂起函数。来看是如何判断的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="meta">@Nullable</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">     <span class="keyword">int</span> p, Type parameterType, <span class="meta">@Nullable</span> Annotation[] annotations, <span class="keyword">boolean</span> allowContinuation) {</span><br><span class="line">······</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span>) {<span class="comment">//参数没有注解</span></span><br><span class="line">     <span class="keyword">if</span> (allowContinuation) {<span class="comment">//参数为函数最后一个参数</span></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">         <span class="keyword">if</span> (Utils.getRawType(parameterType) == Continuation.class) {<span class="comment">//参数类型为Continuation</span></span><br><span class="line">           isKotlinSuspendFunction = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         }</span><br><span class="line">       } <span class="keyword">catch</span> (NoClassDefFoundError ignored) {</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">throw</span> parameterError(method, p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>判断是否协程函数有三个条件：</p>
<ol>
<li>函数参数没有注解</li>
<li>该参数是在函数中的最后一个位置</li>
<li>该参数的类型是<code>Continuation.class</code></li>
</ol>
<p>但这跟我们理解中协程的挂起函数区别有点大啊。因为这是我们理解中的<code>Kotlin</code>挂起函数，当它编译后成Java字节码后，会自动在函数最后一个参数增加<code>Continuation</code>类型的参数。</p>
<p><code>Kotlin</code>函数</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span></span><br></pre></td></tr></tbody></table></figure>
<p><code>Java</code>函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void getData(Continuation c)</span><br></pre></td></tr></tbody></table></figure>
<p>通过解析接口中函数的最后一个参数没有注解，而且类型为<code>Continuation</code>时，就确定为了一个Kotlin协程挂起函数，并将<code>ReqeustFactory</code>的<code>isKotlinSuspendFunction</code>设置为<code>true</code>。</p>
<p>在<code>HttpServiceMethod.parseAnnotations</code>解析时根据<code>isKotlinSuspendFunction</code>来走不同的分支，例如<code>isKotlinSuspendFunction=true</code>情况下，返回的是<code>SuspendForResponse</code>,<code>=false</code>情况下，返回的是<code>CallAdapter</code>。看看具体处理了哪些工作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>{</span><br><span class="line">  <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">  <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  Type adapterType;</span><br><span class="line"> 	  <span class="comment">//协程情况下，与非协程情况下类似，获取返回类型adapterType,用于创建CallAdapter</span></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) {</span><br><span class="line">    Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    Type responseType =</span><br><span class="line">        Utils.getParameterLowerBound(</span><br><span class="line">            <span class="number">0</span>, (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">      <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">      responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">      continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// TODO figure out if type is nullable or not</span></span><br><span class="line">      <span class="comment">// Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)</span></span><br><span class="line">      <span class="comment">// Find the entry for method</span></span><br><span class="line">      <span class="comment">// Determine if return type is nullable or not</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">    annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    adapterType = method.getGenericReturnType();<span class="comment">//非协程情况</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line"> 	</span><br><span class="line">  ......</span><br><span class="line">      </span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (!isKotlinSuspendFunction) {<span class="comment">//非协程情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) {</span><br><span class="line">    <span class="comment">////使用了协程，且返回类型Response</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForResponse&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">////使用了协程，且返回类型ResponseBody</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForBody&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">            continuationBodyNullable);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在这里根据接口的函数返回类型的不同，返回<code>SuspendForResponse</code>或者<code>SuspendForBody</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForResponse</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">  SuspendForResponse(</span><br><span class="line">      RequestFactory requestFactory,</span><br><span class="line">      okhttp3.Call.Factory callFactory,</span><br><span class="line">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">      CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) {</span><br><span class="line">    <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>{</span><br><span class="line">    call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">    Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class="line">        (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">return</span> KotlinExtensions.suspendAndThrow(e, continuation);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过调用<code>OkHttp</code>的<code>Call</code>扩展函数来实现网络请求。我们知道非协程下是通过创建OkHttpCall来实现的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">suspend fun &lt;T : Any&gt; Call&lt;T&gt;.await(): T {</span><br><span class="line">  <span class="keyword">return</span> suspendCancellableCoroutine { continuation -&gt;</span><br><span class="line">    continuation.invokeOnCancellation {</span><br><span class="line">      cancel()</span><br><span class="line">    }</span><br><span class="line">    enqueue(object : Callback&lt;T&gt; {</span><br><span class="line">      <span class="function">override fun <span class="title">onResponse</span><span class="params">(call: Call&lt;T&gt;, response: Response&lt;T&gt;)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful) {</span><br><span class="line">          val body = response.body()</span><br><span class="line">          <span class="keyword">if</span> (body == <span class="keyword">null</span>) {</span><br><span class="line">            val invocation = call.request().tag(Invocation::class.java)!!</span><br><span class="line">            val method = invocation.method()</span><br><span class="line">            val e = KotlinNullPointerException(<span class="string">"Response from "</span> +</span><br><span class="line">                method.declaringClass.name +</span><br><span class="line">                <span class="string">'.'</span> +</span><br><span class="line">                method.name +</span><br><span class="line">                <span class="string">" was null but response body type was declared as non-null"</span>)</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            continuation.resume(body)</span><br><span class="line">          }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          continuation.resumeWithException(HttpException(response))</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="function">override fun <span class="title">onFailure</span><span class="params">(call: Call&lt;T&gt;, t: Throwable)</span> </span>{</span><br><span class="line">        continuation.resumeWithException(t)</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，非协程与协程下的Retrofit的工作流程差不多。协程情况下，在<code>RequestFactory</code>解析，确定是协程，在<code>HttpserviceMethod</code>解析走不同的路径，通过<code>Call</code>扩展函数实现网络请求。</p>
<h2 id="动态代理-2"><a class="markdownIt-Anchor" href="#动态代理-2"></a> 动态代理</h2>
<p>说到动态代理，总是离不开静态代理和代理模式。静态代理总是要写接口，然后代理类和被代理类实现该接口，客户端通过代理类使用接口提供的功能，而代理类把功能实际的工作转到被代理类。问题在哪里，每次我们都懂得去实现代理类和代理类，如果很多个接口，这样会很累的，毕竟程序员都是懒的。再说如果这样，用Retrofit这种第三方库，怎么知道用户创建什么样的接口，怎么去实现他们功能？那就是利用Java的动态代理技术了。动态代理在使用上也可以理解是一套模板。</p>
<p>首先，定义接口，以及实现类，也就是我们对外提供的功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Service {</span><br><span class="line">    void coding();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class CoderService implements Service {</span><br><span class="line">    @Override</span><br><span class="line">    public void coding() {</span><br><span class="line">        System.out.println("提供编程服务");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二，实现<code>InvocationHandler</code>的子类。核心点在于实现<code>invoke</code>函数，调用接口的函数都会转到这里来。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Object service)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"开发了"</span>);</span><br><span class="line">        method.invoke(service,objects);</span><br><span class="line">        System.out.println(<span class="string">"结束了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后，创建<code>Proxy.newProxyInstance</code>接口对象。在Java中，接口和抽象类是不能被直接实例化的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Service service = <span class="keyword">new</span> CoderService();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> Handler(service);</span><br><span class="line">        Service se = (Service) Proxy.newProxyInstance(Service.class.getClassLoader(), <span class="keyword">new</span> Class[]{Service.class}, handler);</span><br><span class="line">        se.coding();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样就可以通过实例化的接口对象，使用相关功能。</p>
<p><code>Retrofit</code>通过在<code>InvocationHandler</code>的<code>invoke</code>解析<code>Method</code>来获得网络请求所需要的的数据。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Retrofit通过Java动态代理技术生成我们请求接口的对象，而我们调用对象的任何函数时，其实都转到<code>InvocationHandler</code>对象的<code>invoke</code>函数。而<code>invoke</code>函数的主要工作就是解析我们在接口中定义函数，包括解析注解，参数注解及值，以及返回类型，然后封装到<code>RequestFactory</code>，然后通过<code>HttpServiceMethod.parseAnnotations</code>函数，查找合适的请求适配器和响应转换器，最后将<code>RequestFactory</code>和适配器、转换器封装成<code>HttpServiceMethod</code>的子类，并调用其<code>invoke</code>函数，通过<code>OkHttp</code>发起网络请求。</p>
<p>通过源码分析，我们知道，一个优秀的的框架都会使用缓存，例如这里方法的解析，<code>OkHttp</code>请求的缓存。同时也知道Retrofit目前已经支持协程，即挂起函数。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Retrofit/">Retrofit</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/03/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Glide源码分析之流程</span></a></div><div class="next-post pull-right"><a href="/2021/03/15/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span>OkHttp源码分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By zhangws</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>