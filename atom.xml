<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新小梦</title>
  
  <subtitle>热爱 • 编程</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-06T12:23:09.459Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zhangws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus 源码分析</title>
    <link href="http://example.com/2021/04/06/EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/04/06/EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-04-05T16:00:00.000Z</published>
    <updated>2021-04-06T12:23:09.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p>本文分析Android主流的事件框架<code>EventBus</code>，尤其在不同的界面触发函数的调用，避免层层嵌套回调。通过源码分析，了解<code>EventBus</code>如何查找订阅方法，切换线程，发布事件的原理。</p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>我们将根据下面的例子来分析<code>EventBus</code>的源码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() {</span><br><span class="line">    <span class="keyword">private</span> val TAG = <span class="string">"MainActivity"</span></span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">        EventBus.getDefault().post(<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line">    <span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function">override fun <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="eventbusgetdefault"><a class="markdownIt-Anchor" href="#eventbusgetdefault"></a> <code>EventBus.getDefault</code></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>{</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) {</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过双重检查单例模式创建<code>EventBus</code>单例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) {</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//通过事件类型获取所有订阅信息</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//通过订阅类获取该订阅类中所有的事件类型</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();<span class="comment">//支持Android主线程</span></span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;<span class="comment">//Handler子类</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//用于寻找订阅类中的订阅方法</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>DEFAULT_BUILDER</code>是<code>EventBusBuilder</code>的实例，所有配置都采用默认值。这里涉及到几个主要对象的创建，例如<code>HandlerPoster</code>对象<code>mainThreadPoster</code>,其实是用来切换到主线程的。</p><h1 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h1><p>接着我们看<code>EventBus</code>如何将一个类与订阅事件绑定。查看<code>EventBus</code>的<code>register</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) {</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>register</code>函数通过<code>SubscriberMethodFinder</code>对象<code>findSubscriberMethods</code>函数，获取当前订阅类所有的订阅方法<code>subscriberMethods</code>。然后遍历所有订阅方法<code>SubscriberMethod</code>，然后调用<code>subscribe</code>函数，将当前订阅类和订阅方法进行绑定。</p><h3 id="findsubscribermethods"><a class="markdownIt-Anchor" href="#findsubscribermethods"></a> <code>findSubscriberMethods</code></h3><p>我们查看<code>SubscriberMethodFinder</code>对象如何通过<code>findSubscriberMethod</code>函数如何寻找当前订阅类中合法的订阅方法，并封装成<code>SubscriberMethod</code>实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">  <span class="comment">//先通过缓存获取该订阅类是否解析过（例如Activity销毁后，重新进入）</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) {<span class="comment">//默认false</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的<code>METHOD_CACHE</code>是<code>ConcurrentHashMap</code>类型,键值对分别是<code>Class&lt;?&gt;, List&lt;SubscriberMethod&gt;</code>,也就是<code>findSubscriberMethods</code>函数会查找订阅方法，然后缓存到<code>METHOD_CACHE</code>中，下次优先通过通过缓存查找。初次注册，那肯定是没有缓存。<code>ignoreGeneratedIndex</code> 默认情况下是<code>flase</code>，所以会调用<code>findUsingInfo(subscriberClass)</code>查找类中的注册方法。</p><h3 id="findusinginfo"><a class="markdownIt-Anchor" href="#findusinginfo"></a> <code>findUsingInfo</code></h3><p><code>findUsingInfo</code>函数会将相关的信息封装到<code>FindState</code>对象，最后获取到订阅方法<code>SubscriberMethod</code>列表后释放<code>FindState</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) {</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) {</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) {</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        }</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>prepareFindState</code>函数返回了<code>FindState</code>对象，该函数主要遍历大小为4的<code>FIND_STATE_POOL</code>数组，取第一个不为<code>null</code>的<code>FindState</code>对象,并将数组该位置引用置为<code>null</code>，如果数组不存在元素，则直接新建一个<code>FindState</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            FindState state = FIND_STATE_POOL[i];</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="keyword">null</span>) {</span><br><span class="line">                FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后调用<code>FindState</code>对象的<code>initForSubscriber</code>函数。将当前订阅类类型赋值<code>FindState</code>对象的<code>subscriberClass</code>和<code>clazz</code>变量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">    skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">    subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到<a href="#"><code>findUsingInfo</code></a>函数，由于<code>clazz</code>被赋值为<code>subscriberClass</code>,所以<code>while</code>循环为<code>ture</code>。接着调用了<code>getSubscriberInfo(findState)</code>函数。</p><h3 id="getsubscriberinfo"><a class="markdownIt-Anchor" href="#getsubscriberinfo"></a> <code>getSubscriberInfo</code></h3><p>在<code>getSubscriberInfo(findState)</code>函数中，由于第一次注册该类，所以<code>FindState</code>对象的<code>subscriberInfo=null</code>。而<code>subscriberInfoIndexes</code>在<code>SubscriberMethodFinder</code>实例创建的时候传递进来。<code>subscriberInfoIndexes</code>是通过<code>EventBusBuilder</code>传递进来的，默认为<code>null</code>。所以<code>getSubscriberInfo</code>函数返回了<code>null</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) {</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) {</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) {</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="findusingreflectioninsingleclass"><a class="markdownIt-Anchor" href="#findusingreflectioninsingleclass"></a> <code>findUsingReflectionInSingleClass</code></h3><p>回到[<code>findUsingInfo</code>](#  <code>findUsingInfo</code>)函数中，由于<code>findState.subscriberInfo=null,</code>将执行<code>findUsingReflectionInSingleClass(findState)</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable th) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">        } <span class="keyword">catch</span> (LinkageError error) { </span><br><span class="line">           ...</span><br><span class="line">        }</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;<span class="comment">//该标志位会在moveToSuperclass函数用到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) {</span><br><span class="line">      <span class="comment">//获取方法修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">      <span class="comment">//public修饰且非编译器生成</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) {</span><br><span class="line">          <span class="comment">//获取所有参数类型</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) {<span class="comment">//参数长度为1</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) {<span class="comment">//方法被Subscribe注解</span></span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) {</span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getDeclaredMethods</code>函数是获取订阅类自身声明的所有方法，包括<code>public</code>、<code>protected</code>、<code>private</code>方法,而<code>getMethods</code>函数是类所有公共方法，自身、父类和接口的公共方法。如果前者抛出异常，将采用后者，并设置<code>findState.skipSuperClasses = true</code>。</p><p>接着遍历所有获取的方法，访问方法的修饰符。判断条件<code>(modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0</code>表示当前方法是<code>public</code>修饰符且不是编译器生成的。然后通过<code>method.getParameterTypes()</code>函数，获取方法的参数类型列表，这里只是用来判断参数的数量，当参数数量为1才继续下一步。</p><p>然后通过<code>method.getAnnotation(Subscribe.class)</code>函数判断方法被<code>Subscribe</code>注解着。然后调用了<code>FindState</code>对象的<code>checkAdd</code>函数，将方法<code>method</code>和事件类型<code>eventType</code>（参数类型）作为参数传递 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">    Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) {</span><br><span class="line">            <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            }</span><br><span class="line">            anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>anyMethodByEventType</code>是<code>HashMap</code>类型，键值对是<code>&lt;Class, Object&gt;</code>。将注解类型和方法<code>put</code>到<code>anyMethodByEventType</code>，如果返回<code>null</code>，说明该类只有一个参数的类型为该<code>eventType</code>的方法，没有冲突，直接返回<code>ture</code>。如果返回了<code>existing</code>对象不为<code>null</code>，说明类中已经找到了相同参数类型的方法，进一步检查方法签名。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">    String methodKey = methodKeyBuilder.toString();<span class="comment">//methodName&gt;paramTypeName</span></span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass();<span class="comment">//获取方法所在的类</span></span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>checkAddWithMethodSignature</code>函数通过<code>put</code>元素到<code>subscriberClassByMethodKey</code>来判断前面是否有已存在的方法，<code>subscriberClassByMethodKey</code>也是<code>HashMap</code>类型，键值对是<code>Map&lt;String, Class&gt;</code>。其<code>put</code>函数返回<code>null</code>表明前面没有签名（<code>methodName&gt;paramTypeName</code>）相同的方法,或者存在且其值是当前订阅类的父类，父接口或者相同类。</p><p>因此<code>checkAdd</code>函数也称为第二层检查<code>EventBus</code>中类的合法注册。<code>checkAdd</code>函数返回<code>true</code>之后，将相关信息封装到<code>SubscriberMethod</code>对象中，并添加到<code>findState.subscriberMethods</code>列表中。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">     subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br></pre></td></tr></tbody></table></figure><p>**到这里确定了如何注解一个合法的方法： **</p><ul><li>注解方法必须是<code>public</code>修饰且非编译器生成，只有一个参数,并且<code>Subscribe</code>注解该方法</li><li>不存在相同签名（<code>methodName&gt;paramTypeName</code>）</li><li>若已存在的注册类则得是方法所在的类或者父类</li></ul><h3 id="movetosuperclass"><a class="markdownIt-Anchor" href="#movetosuperclass"></a> <code>moveToSuperclass</code></h3><p>回到<a href="#"><code>findUsingInfo</code></a>函数。调用了<code>FindState</code>对象的<code>moveToSuperclass</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (skipSuperClasses) {<span class="comment">//findUsingReflectionInsingleClass函数，默认情况getDeclaredMethods函数获取当前类自身声明方法，发生异常情况下调用getMethods函数获取所有方法，会将skipSuperClasses设为true</span></span><br><span class="line">        clazz = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">        String clazzName = clazz.getName();</span><br><span class="line">        <span class="comment">//如果当前类是系统类，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) || clazzName.startsWith(<span class="string">"javax."</span>) ||</span><br><span class="line">                clazzName.startsWith(<span class="string">"android."</span>) || clazzName.startsWith(<span class="string">"androidx."</span>)) {</span><br><span class="line">            clazz = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意到这里还在<code>while</code>循环中，正常情况<code>skipSuperClasses=true</code>,<code>clazz</code>将赋值为当前订阅类的父类，然后重复寻找父类的订阅方法。</p><p><a href="#"><code>findUsingInfo</code></a>函数最后调用了<code>getMethodsAndRelease</code>函数返回<code>SubscriberMethod</code>列表，将<code>FindState</code>对象进行回收。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>{</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">    findState.recycle();</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) {</span><br><span class="line">                FIND_STATE_POOL[i] = findState;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="subscribe"><a class="markdownIt-Anchor" href="#subscribe"></a> <code>subscribe</code></h3><p>回到<code>register</code>函数。寻找到<code>SubscriberMethod</code>列表后，会遍历每个<code>SubscribeMethod</code>，并调用<code>subscribe</code>函数，将订阅者与订阅方法绑定。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">  <span class="comment">//通过参数类型获取已存在的订阅信息</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) {</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//将方法的订阅信息添加到subscriptions列表合适的位置，</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) {</span><br><span class="line">      <span class="comment">//最后的位置或者根据优先级排序</span></span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//typesBySubscriber保存当前类的订阅事件（方法的参数类型）</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) {</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    }</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"><span class="comment">//判断当前方法订阅的是黏性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) {</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) {<span class="comment">//默认true,表示黏性事件可以从父类继承</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>subscribe</code>函数相对来说比较简单，已经在上面代码中注释一些信息。看下最后的<code>checkPostStickyEventToSubscription</code>函数，如何发送黏性事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) {</span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见调用了<code>postToSubscription</code>函数，发送了一次事件，可见，如果订阅的事黏性事件，会出发最后一次黏性消息事件。这里不继续分析，因为和后面的重叠。</p><h1 id="unregister"><a class="markdownIt-Anchor" href="#unregister"></a> unregister</h1><p>在<code>register</code>函数注册中，会把当前类添加到<code>typesBySubscriber</code>中，而<code>unregister</code>函数则是从<code>typesBySubscriber</code>移除该对象，并调用<code>unsubscribeByEventType</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) {<span class="comment">//遍历当前类注册的所有事件，在事件列表里移除本注册类对应的订阅信息</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        }</span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看看<code>unsubscribeByEventType</code>函数，通过<code>subscriptionsByEventType</code>获取注册事件<code>eventType</code>的注册信息列表，遍历列表，判断每个订阅信息是否注册类是否与当前解绑注册相同，相同的话则从订阅信息列表移除该订阅信息。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>{</span><br><span class="line">  <span class="comment">//订阅类型的所有订阅信息</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) {<span class="comment">//订阅信息中的订阅类与解绑订阅类一致</span></span><br><span class="line">                subscription.active = <span class="keyword">false</span>;<span class="comment">//该标志位在处理订阅方法会很有用</span></span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说，解绑的过程是将订阅者和订阅信息分别从<code>typesBySubscriber</code>和<code>subscriptions</code>集合中移除。</p><h1 id="post"><a class="markdownIt-Anchor" href="#post"></a> Post</h1><p>分析了注册与解注册，接下来分析发送事件的<code>post</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>{</span><br><span class="line">  <span class="comment">//将事件添加到当前线程的事件队列中</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) {</span><br><span class="line">      <span class="comment">//判断是否Android主线程</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) {</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);<span class="comment">//此时队列只有我们一个事件</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>currentPostingThreadState</code>是<code>ThreadLocal</code>类型，缓存<code>PostingThreadState</code>。<code>post</code>函数的 主要功能是将事件添加到<code>eventQueue</code>队列中，如果当前<code>postingState.isPosting!=ture</code>,则调用<code>postSingleEvent</code>发布该事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>{</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) {</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);<span class="comment">//查询该EventType所有父类和接口</span></span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) {</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) {</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) {</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) {</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用<code>postSingleEventForEventType</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>{</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) {</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) {</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (aborted) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>postSingleEventForEventType</code>函数遍历<code>eventClass</code>对应的<code>Subscription</code>列表，然后调用了<code>postToSubscription</code>函数发送事件。前面分析到，当类订阅黏性事件也会调用该方法。</p><h2 id="posttosubscription"><a class="markdownIt-Anchor" href="#posttosubscription"></a> <code>postToSubscription</code></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) {</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里就涉及到<code>EventBus</code>中线程的一些知识点，在注册类中，我们通常通过这样方式去订阅一个事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{}</span><br></pre></td></tr></tbody></table></figure><p>其中<code>threadMode</code>表示当事件来临时，执行<code>get</code>函数的方法体的线程。默认情况下是<code>ThreadMode.POSTING</code>,表示与事件发布的线程一致，即发布线程，所以可能在主线程，也有可能在后台线程。而<code>ThreadMode.MAIN</code>表示在<code>Android</code>的主线程，如果发布线程也在主线程，那么方法体会被直接执行，所以可能会被主线程阻塞，可以通过<code>MAIN_ORDERED</code>按序在主线程执行，这样就不会阻塞主线程。<code>ThreadMode.MAIN_ORDERED</code>后台线程，即Android主线程外的其他线程。<code>ThreadMode.ASYNC</code>即异步线程，即发布线程和订阅线程是独立线程，不会直接运行和等待订阅方法。</p><p>回到<code>postToSubscription</code>函数。由于我们发布事件和订阅事件都在主线程，所以直接执行了<code>invokeSubscriber</code>函数。也就是直接通过反射调用了我们的订阅方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设我们在子线程发布了事件，此时调用的是<code>mainThreadPoster.enqueue(subscription, event)</code>。<code>mainThreadPoster</code>对象的类型<code>MainThreadSupport</code>，在<code>EventBus</code>对象创建的时候被创建。</p><h2 id="mainthreadposter"><a class="markdownIt-Anchor" href="#mainthreadposter"></a> <code>MainThreadPoster</code></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//EventBusBuilder</span></span><br><span class="line"><span class="function">MainThreadSupport <span class="title">getMainThreadSupport</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mainThreadSupport != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> mainThreadSupport;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (AndroidLogger.isAndroidLogAvailable()) {<span class="comment">// Class.forName("android.util.Log") != null</span></span><br><span class="line">        Object looperOrNull = getAndroidMainLooperOrNull();<span class="comment">//Looper.getMainLooper()</span></span><br><span class="line">        <span class="keyword">return</span> looperOrNull == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> MainThreadSupport.AndroidHandlerMainThreadSupport((Looper) looperOrNull);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以<code>MainThreadSupport</code>其实很简单。直接创建了<code>MainThreadSupport</code>的实现类<code>AndroidHandlerMainThreadSupport</code>,内部持有主线程的<code>Looper</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainThreadSupport</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AndroidHandlerMainThreadSupport</span> <span class="keyword">implements</span> <span class="title">MainThreadSupport</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Looper looper;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AndroidHandlerMainThreadSupport</span><span class="params">(Looper looper)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.looper = looper;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> looper == Looper.myLooper();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HandlerPoster(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而<code>mainPoster</code>则是<code>HandlerPoster</code>,<code>HandlerPoster</code>是<code>Handler</code>的子类，并且实现<code>Poster</code>接口。查看其<code>enqueue</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="comment">//利用旧的或直接新建PendingPost对象</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        queue.enqueue(pendingPost);<span class="comment">//加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) {</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将信息包装成<code>PendingPost</code>对象，然后加入到<code>PendingPostQueue</code>队列<code>queue</code>中，如<code>handler</code>未激活，则调用<code>handle</code>的<code>sendMessage</code>函数。</p><h2 id="handlemessage"><a class="markdownIt-Anchor" href="#handlemessage"></a> <code>handleMessage</code></h2><p>我们看看其<code>handleMessage</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">          <span class="comment">//从队列取PendingPost对象</span></span><br><span class="line">            PendingPost pendingPost = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                    <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                        handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) {</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                }</span><br><span class="line">                rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用了<code>invokeSubscriber</code>函数。可见最终调用了<code>invokeSubscriber</code>的重载函数，并释放<code>PendingPost</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>{</span><br><span class="line">    Object event = pendingPost.event;</span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) {<span class="comment">//调用unregister,该变量=false。</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样一分析，<code>EventBus</code>的订阅与解订阅，简单事件发布流程就分析完毕了。</p><h1 id="黏性事件"><a class="markdownIt-Anchor" href="#黏性事件"></a> 黏性事件</h1><p>所谓的黏性事件，就是在订阅方法的<code>Subscribe</code>注解，将其<code>sticky</code>属性设置为<code>ture</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样在类注册的时候，[<code>subscribe</code>](# <code>subscribe</code>)函数会发布上次黏性事件。如果没有黏性事件，则不会发布该事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">//判断当前方法订阅的是黏性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) {</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) {<span class="comment">//默认true,表示黏性事件可以从父类继承</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们通过<code>postSticky</code>函数来发布黏性事件。它会将黏性事件保存到<code>stickyEvents</code>中，这种后面订阅就可以取出上次黏性事件。然后再调用<code>post</code>进行事件发布。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) {</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    }</span><br><span class="line">    post(event);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="优先权"><a class="markdownIt-Anchor" href="#优先权"></a> 优先权</h1><p>在订阅事件时候，我们也可以通过<code>priority</code>属性设置同线程内的同事件不同订阅类接收该订阅事件的优先权。值越大表示优先权越高，会优先接收到订阅事件，这个通过[<code>subscribe</code>](# <code>subscribe</code>)函数得知。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true,priority = 1)</span></span><br><span class="line"><span class="function">fun <span class="title">get</span><span class="params">(event:Int)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="线程切换"><a class="markdownIt-Anchor" href="#线程切换"></a> 线程切换</h1><p>前面分析中，分析了主线程的切换[<code>MainThreadPoster</code>](# <code>MainThreadPoster</code>)。回到<a href="#%60postToSubscription%60"><code>postToSubscription</code></a>函数，了解其他线程的切换。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {</span><br><span class="line">        <span class="keyword">case</span> POSTING:<span class="comment">//订阅线程为POSTING，表示与发布线程一致，不需要切换，直接调用订阅方法。</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {<span class="comment">//先判断发布线程是否在主线程，是的话，直接调用</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">//否则，通过mainThreadPoster切换到主线程</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) {<span class="comment">//mainThreadPoster进队列按序发布事件</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//技术错误，直接调用</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) {<span class="comment">//后台线程队列，在线程池执行</span></span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里主要看下<code>backgroundPoster</code>和<code>asyncPoster</code>的工作原理。</p><h2 id="backgroundposter"><a class="markdownIt-Anchor" href="#backgroundposter"></a> <code>BackgroundPoster</code></h2><p><code>BackgroundPoster</code>实现<code>Runnable</code>和<code>Poster</code>接口。其<code>enqueue</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) {</span><br><span class="line">            executorRunning = <span class="keyword">true</span>;</span><br><span class="line">            eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先把订阅信息包装类<code>PendingPost</code>添加到队列中，<code>executorRunning=false</code>,则调用<code>eventBus.getExecutorService().execute(this)</code>执行自身。这里的<code>eventBus.getExecutorService()</code>返回的线程池是<code>Executors.newCachedThreadPool()</code>对象,此时查看<code>run</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">                            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        executorRunning = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见于<code>MainPoster</code>的逻辑是一致的，只不过这里在线程池执行订阅方法，从而实现切换到后台线程，且在一条后台线程会处理完所有的事件的订阅方法，。</p><h2 id="asyncposter"><a class="markdownIt-Anchor" href="#asyncposter"></a> <code>AsyncPoster</code></h2><p><code>AsyncPoster</code>也实现<code>Runnable</code>和<code>Poster</code>接口。查看其<code>enqueue</code>函数和<code>run</code>函数。也就是说<code>AsyncPoster</code>实现逻辑与<code>BackgroundPoster</code>一致的。只不过<code>AsyncPoster</code>对象中一条线程只执行一个事件的订阅方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    PendingPost pendingPost = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">    }</span><br><span class="line">    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>【<strong>相关知识点连接</strong>】</p><p><a href="https://juejin.cn/post/6919002656186826765">ThreadLocal</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h1&gt;
&lt;p&gt;本文分析Android主流的事件框架&lt;code&gt;EventBus&lt;/code&gt;，尤其在不同的界面触发函数的调用，避免层层嵌套回调。通过源码分析，</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="EventBus" scheme="http://example.com/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Glide源码分析之数据</title>
    <link href="http://example.com/2021/04/02/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90/"/>
    <id>http://example.com/2021/04/02/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90/</id>
    <published>2021-04-01T16:00:00.000Z</published>
    <updated>2021-04-02T08:59:52.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p>作为Glide的第二篇，主要分析了Glide请求中数据来源，或者说Glide的缓存机制。Glide构建过程会配置很多注册项，然后在获取数据时，会根据已有的信息，如<code>dataClass</code>等，然后找到合适的<code>ModelLoader</code>、<code>Decoder</code>、<code>Transcoder</code>等，经历了四个缓存历程，没有找到合适的缓存，最终从网络拉取数据。</p><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在上文<a href="https://xxm-sz.github.io/2021/03/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/">Glide流程分析</a>分析<code>with</code>、<code>load</code>、<code>into</code>函数三步骤时，略过了最重要的步骤：数据获取。本节从<code>into</code>函数中的<code>engile.load</code>函数开始，分析Glide如何从不同的地方加载数据。这里需要记住参数<code>modelClass</code>、<code>resourceClass</code>和<code>transcodeClass</code>的实参分别是<code>String.class</code>、<code>Object.class</code>和<code>Drawable.Class</code>，而<code>model=https://xxm-sz/github.io/test.png</code>。</p><p><code>resourceClass</code>通常代表原始数据解码后的资源类型，<code>dataClass</code>代表原始数据类型，<code>transcodeClass</code>代表采样，解码后的资源类型。<code>modelClass</code>代表我们<code>Glide.with(context).load(xxx)</code>函数中<code>load</code>函数参数<code>xxx</code>的类型。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//EngineKey用参数来作为equals和hashCode函数的计算条件</span></span><br><span class="line">  EngineKey key =</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="comment">//步骤1：从内存获取资源（活动资源缓存和内存缓存）</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//步骤2：从本地磁盘或网络获取资源</span></span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="内存缓存"><a class="markdownIt-Anchor" href="#内存缓存"></a> 内存缓存</h1><p><code>engile.load</code>函数通过各种信息计算出<code>EngineKey</code>,然后通过<code>loadFromMemory</code>函数从内存获取资源。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) {</span><br><span class="line">  <span class="keyword">if</span> (!isMemoryCacheable) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>isMemoryCacheable</code>默认情况下等于<code>true</code>，先调用了<code>loadFromActiveResources</code>函数从活动资源获取资源，如果获取不到，再调用<code>loadFromCache</code>函数从内存获取资源。</p><h2 id="loadfromactiveresources"><a class="markdownIt-Anchor" href="#loadfromactiveresources"></a> <code>loadFromActiveResources</code></h2><p>先分析从<code>loadFromActiveResources</code>资源获取活动资源。这里的活动资源指的已经设置到<code>Target</code>后释放的，没有<code>Target</code>引用到的，垃圾回收器还没有回收的资源的，<code>Glide</code>可以重新获取设置给新的<code>Target</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) {</span><br><span class="line">  EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="keyword">null</span>) {</span><br><span class="line">    active.acquire();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> active;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>ActiveResources</code>对象在<code>Engine</code>引擎被创建时初始化，内部持有一个<code>HashMap</code>类型的``activeEngineResources<code>变量,以</code>Key<code>为键，</code>ResourceWeakReference<code>为值。通过</code>get`函数去获取资源的弱引用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) {</span><br><span class="line">  ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (activeRef == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">  <span class="keyword">if</span> (active == <span class="keyword">null</span>) {</span><br><span class="line">    cleanupActiveReference(activeRef);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> active;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果能获取到活动资源<code>EngineResource</code>,调用其<code>activate</code>函数,并返回该活动资源，然后通过回调设置给<code>Target</code>了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>{</span><br><span class="line">  ResourceWeakReference toPut =</span><br><span class="line">      <span class="keyword">new</span> ResourceWeakReference(</span><br><span class="line">          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">  ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">  <span class="keyword">if</span> (removed != <span class="keyword">null</span>) {</span><br><span class="line">    removed.reset();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>activate</code>只是新建<code>ResourceWeakReference</code>实例，然后放到<code>activeEngineResources</code>中。</p><h2 id="loadfromcache"><a class="markdownIt-Anchor" href="#loadfromcache"></a> <code>loadFromCache</code></h2><p>从活动缓存获取不到资源，就调用<code>loadFromCache</code>函数从内存缓存获取资源。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) {</span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) {</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用了<code>getEngineResourceFromCache</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) {</span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="keyword">null</span>) {</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) {</span><br><span class="line">    <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> EngineResource&lt;&gt;(</span><br><span class="line">            cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getEngineResourceFromCache</code>函数的逻辑也是非常易懂，不过多介绍。这里的<code>cache</code>是<code>MemoryCache</code>类型，在<code>GlideBuilder</code>的<code>build</code>函数创建<code>Glide</code>时，会创建<code>MemoryCache</code>的实现类<code>LruResourceCache</code>并传递给<code>Engine</code>实例。<code>LruResourceCache</code>继承自<code>LruCache</code>类，并实现<code>MemoryCache</code>接口。而LruCache内部维护着<code>LinkedHashMap</code>，用于存取缓存。</p><p>所以如果从<code>LruChache</code>中能得到缓存，也会回调将资源设置给<code>Target</code>.</p><h1 id="waitforexistingorstartnewjob"><a class="markdownIt-Anchor" href="#waitforexistingorstartnewjob"></a> <code>waitForExistingOrStartNewJob</code></h1><p>该函数主要是从不同的来源去加载目标资源，有可能是本地磁盘缓存，也有可能是网络资源。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">    EngineKey key,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> startTime)</span> </span>{</span><br><span class="line"><span class="comment">//Jobs对象jobs内部持有HashMap类型的jobs和onlyCacheJobs，根据onlyRetrieveFromCache在两者切换</span></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current != <span class="keyword">null</span>) {</span><br><span class="line">    current.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) {</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      decodeJobFactory.build(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          key,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          options,</span><br><span class="line">          engineJob);</span><br><span class="line"></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中<code>jobs</code>是<code>Jobs</code>类对象，<code>Jobs</code>类持有<code>HashMap</code>类型的<code>jobs</code>和<code>onlyCacheJobs</code>，根据<code>onlyRetrieveFromCache</code>在两者切换。<code>HashMap</code>的<code>Value</code>是<code>EngineJob</code>类，是一个<code>Glide</code>请求加载管理类，当加载完成会通过回调通知。如果能获取到<code>EngineJob</code>对象，说明已经有相同的任务在进行中。</p><p>如果<code>Jobs</code>对象中获取不到<code>EngineJob</code>，则通过工厂新建一个<code>EngineJob</code>对象和<code>DecodeJob</code>对象，并调用其<code>engineJob.start</code>函数。这里<code>DecodeJob</code>类负责从缓存数据或原始数据解码，转换出目标资源类型。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">  GlideExecutor executor =</span><br><span class="line">      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//DiskCacheStrategy默认情况下decodeCachedResource返回ture,firstStage将返回Stage.RESOURCE_CACHE，所以该方法返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">willDecodeFromCache</span><span class="params">()</span> </span>{</span><br><span class="line">  Stage firstStage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">  <span class="keyword">return</span> firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>start</code>函数通过线程池去执行<code>DecodeJob</code>对象。在看<code>DecodeJob</code>的<code>run</code>函数之前，先看看相关线程池的创建。</p><h3 id="diskcacheexector"><a class="markdownIt-Anchor" href="#diskcacheexector"></a> <code>DiskCacheExector</code></h3><p><code>GlideBuilder</code>的<code>build</code>函数会将下面提到的线程池都创建，这里先看 <code>diskCacheExecutor</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GlideBuilder#build </span></span><br><span class="line">diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//GlideExector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newDiskCacheExecutor</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> newDiskCacheBuilder().build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newDiskCacheBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">true</span>)</span><br><span class="line">      .setThreadCount(DEFAULT_DISK_CACHE_EXECUTOR_THREADS)<span class="comment">//=1</span></span><br><span class="line">      .setName(DEFAULT_DISK_CACHE_EXECUTOR_NAME);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> GlideExecutor <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(name)) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Name must be non-null and non-empty, but given: "</span> + name);</span><br><span class="line">    }</span><br><span class="line">    ThreadPoolExecutor executor =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            <span class="comment">/*keepAliveTime=*/</span> threadTimeoutMillis,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            <span class="keyword">new</span> DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadTimeoutMillis != NO_THREAD_TIMEOUT) {</span><br><span class="line">      executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(executor);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里线程池的核心线程和最大线程数都设置成了1,即单线程线程池。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> GlideExecutor <span class="title">getActiveSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> useUnlimitedSourceGeneratorPool</span><br><span class="line">      ? sourceUnlimitedExecutor</span><br><span class="line">      : (useAnimationPool ? animationExecutor : sourceExecutor);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sourceexecutor"><a class="markdownIt-Anchor" href="#sourceexecutor"></a> <code>SourceExecutor</code></h3><p><code>sourceExecutor</code>的创建：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">return</span> newSourceBuilder().build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newSourceBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">false</span>)</span><br><span class="line">      .setThreadCount(calculateBestThreadCount())</span><br><span class="line">      .setName(DEFAULT_SOURCE_EXECUTOR_NAME);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与磁盘缓存线程池创建的区别是线程数的计算。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateBestThreadCount</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (bestThreadCount == <span class="number">0</span>) {</span><br><span class="line">    bestThreadCount =</span><br><span class="line">        Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, RuntimeCompat.availableProcessors());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bestThreadCount;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>MAXIMUM_AUTOMATIC_THREAD_COUNT=4</code>，所以资源线程池的线程多少取决于设备CPU核心数量，且最多为4。</p><h3 id="animationexecutor"><a class="markdownIt-Anchor" href="#animationexecutor"></a> <code>AnimationExecutor</code></h3><p><code>animationExecutor</code>线程的创建亦是如此，不过它逻辑是这样，当CPU核心数大于4，线程数设为2，否则设为1.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor.<span class="function">Builder <span class="title">newAnimationBuilder</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> bestThreadCount = calculateBestThreadCount();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maximumPoolSize = bestThreadCount &gt;= <span class="number">4</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor.Builder(<span class="comment">/*preventNetworkOperations=*/</span> <span class="keyword">true</span>)</span><br><span class="line">      .setThreadCount(maximumPoolSize)</span><br><span class="line">      .setName(DEFAULT_ANIMATION_EXECUTOR_NAME);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="unlimitedsourceexecutor"><a class="markdownIt-Anchor" href="#unlimitedsourceexecutor"></a> <code>UnlimitedSourceExecutor</code></h3><p>Glide还创建了无限制的线程池。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GlideExecutor.newUnlimitedSourceExecutor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideExecutor <span class="title">newUnlimitedSourceExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GlideExecutor(</span><br><span class="line">      <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          Integer.MAX_VALUE,</span><br><span class="line">          KEEP_ALIVE_TIME_MS,</span><br><span class="line">          TimeUnit.MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">          <span class="keyword">new</span> DefaultThreadFactory(</span><br><span class="line">              DEFAULT_SOURCE_UNLIMITED_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT, <span class="keyword">false</span>)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里直接创建线程池，线程池容量无限大（<code>Integer.MAX_VALUE</code>）,核心线程为1，10秒存活。</p><p>也就是说，默认情况下，Glide会为我们创建四种类型<code>GlideExecutor</code>,它们的主要区别是核心线程数和最大线程数的区别。</p><ul><li><code>diskCacheExecutor</code>：磁盘缓存线程池：核心和最大线程数都是1。</li><li><code>sourceExecutor</code>： 数据来源线程池：核心和最大线程数都最大为4，最小取决CPU核心。</li><li><code>animationExecutor</code>：动画线程池：CPU核心数大于4，核心和最大线程数设为2，否则设为1</li><li><code>unlimitedSourceExecutor</code>：无限制线程池，核心为，最大无限制。</li></ul><h3 id="decodejob"><a class="markdownIt-Anchor" href="#decodejob"></a> <code>DecodeJob</code></h3><p>了解完线程池的创建，回到<code>DecodeJob</code>类的<code>run</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">    runWrapped();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在创建<code>DecodeJob</code>对象的时候,<code>runReason</code>会被赋值为<code>INITIALIZE</code>，所以<code>runWrapped</code>函数这里走的是<code>INITIALIZE</code>分支。该分支有三个重要函数。</p><p><code>getNextStage</code>函数、<code>getNextGenerator</code>函数和<code>runGenerators</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (runReason) {</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getNextStage</code>函数的<code>INITIALIZE</code>分支。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (current) {</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">          ? Stage.RESOURCE_CACHE</span><br><span class="line">          : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">          ? Stage.DATA_CACHE</span><br><span class="line">          : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (stage) {</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，默认情况下<code>DiskCacheStrategy</code>是<code>AUTOMATIC</code>,其<code>decodeCachedResource</code>函数和<code>decodeCachedData</code>函数都是返回<code>true</code>。所有<code>getNextStage</code>函数返回<code>Stage.RESOURCE_CACHE</code>，<code>getNextGenerator</code>函数返回<code>ResourceCacheGenerator</code>对象。</p><p>而<code>runGenerators</code>函数主要执行<code>Generator</code>的<code>startNext</code>函数。如果<code>startNext</code>函数返回<code>false</code>，则执行下一个策略和对应的<code>Generator</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>{</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) {</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) {</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {</span><br><span class="line">    notifyFailed();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="resourcecachegenerator"><a class="markdownIt-Anchor" href="#resourcecachegenerator"></a> <code>ResourceCacheGenerator</code></h2><p><code>ResourceCacheGenerator</code>是我们碰到第一个<code>Generator</code>,主要缓存采样或转换后的资源，利用<code>DiskLruCache</code>在硬盘上进行存取资源。分析起来会比较吃力，但理解了之后，再看<code>DataCacheGenerator</code>和<code>SourceGenerator</code>就简单多了。</p><h3 id="startnext"><a class="markdownIt-Anchor" href="#startnext"></a> <code>startNext</code></h3><p>看看<code>ResourceCacheGenerator</code>的<code>startNext</code>函数。<code>startNext</code>函数的工作量非常多，分成几个步骤分析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">//步骤1</span></span><br><span class="line">  List&lt;Key&gt; sourceIds = helper.getCacheKeys();</span><br><span class="line">  <span class="keyword">if</span> (sourceIds.isEmpty()) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//步骤2</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();</span><br><span class="line">  <span class="keyword">if</span> (resourceClasses.isEmpty()) {</span><br><span class="line">    <span class="keyword">if</span> (File.class.equals(helper.getTranscodeClass())) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Failed to find any load path from "</span></span><br><span class="line">            + helper.getModelClass()</span><br><span class="line">            + <span class="string">" to "</span></span><br><span class="line">            + helper.getTranscodeClass());</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//步骤3</span></span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">    resourceClassIndex++;</span><br><span class="line">    <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) {</span><br><span class="line">      sourceIdIndex++;</span><br><span class="line">      <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">    currentKey =</span><br><span class="line">        <span class="keyword">new</span> ResourceCacheKey( <span class="comment">// NOPMD AvoidInstantiatingObjectsInLoops</span></span><br><span class="line">            helper.getArrayPool(),</span><br><span class="line">            sourceId,</span><br><span class="line">            helper.getSignature(),</span><br><span class="line">            helper.getWidth(),</span><br><span class="line">            helper.getHeight(),</span><br><span class="line">            transformation,</span><br><span class="line">            resourceClass,</span><br><span class="line">            helper.getOptions());</span><br><span class="line">    cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">      sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//步骤4</span></span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(</span><br><span class="line">            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="getchachekeys"><a class="markdownIt-Anchor" href="#getchachekeys"></a> <code>getChacheKeys</code></h3><p>步骤1：<code>DecodeHelper.getCacheKeys</code>函数主要工作遍历<code>getLoadData</code>函数获取到的<code>LoadData</code>列表，将每个<code>LoadData</code>中的<code>sourceKeys</code>对象和<code>alternateKeys</code>集合添加到<code>cacheKeys</code>集合(去掉重复的<code>Key</code>)并返回。这里的<code>key</code>对象用于唯一标识缓存数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Key&gt; <span class="title">getCacheKeys</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!isCacheKeysSet) {</span><br><span class="line">    isCacheKeysSet = <span class="keyword">true</span>;</span><br><span class="line">    cacheKeys.clear();</span><br><span class="line">    <span class="comment">//重点，通过modelClass获取所有model配置项符合的ModelLoader</span></span><br><span class="line">    List&lt;LoadData&lt;?&gt;&gt; loadData = getLoadData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = loadData.size(); i &lt; size; i++) {<span class="comment">//将LoadData的key和备选alternateKeys列表添加到cacheKeys列表</span></span><br><span class="line">      LoadData&lt;?&gt; data = loadData.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!cacheKeys.contains(data.sourceKey)) {<span class="comment">//去掉重复的key</span></span><br><span class="line">        cacheKeys.add(data.sourceKey);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.alternateKeys.size(); j++) {</span><br><span class="line">        <span class="keyword">if</span> (!cacheKeys.contains(data.alternateKeys.get(j))) {<span class="comment">//去掉重复的key</span></span><br><span class="line">          cacheKeys.add(data.alternateKeys.get(j));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cacheKeys;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="getloaddata"><a class="markdownIt-Anchor" href="#getloaddata"></a> <code>getLoadData</code></h3><p><code>getLocadData</code>函数主要通过<code>glideContext.getRegistry().getModelLoaders(model)</code>函数获取<code>ModelLoader</code>列表<code>modelLoaders</code>，并迭代<code>modelLoaders</code>列表，调用每个<code>ModelLoader</code>的<code>buildLoadData</code>函数创建<code>LoadData</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() {</span><br><span class="line">  <span class="keyword">if</span> (!isLoadDataSet) {</span><br><span class="line">    isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">    loadData.clear();</span><br><span class="line">    <span class="comment">//从注册表获取modelLoaders列表</span></span><br><span class="line">    List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) {</span><br><span class="line">      ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line"></span><br><span class="line">      LoadData&lt;?&gt; current = modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="comment">//并不是所有获取到的ModelLoader都能处理该model，current==null表示该loader或者其持有的loader都不能处理该model</span></span><br><span class="line">      <span class="keyword">if</span> (current != <span class="keyword">null</span>) {</span><br><span class="line">        loadData.add(current);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> loadData;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>glideContext.getRegistry().getModelLoaders(model)</code>函数最终调用到<code>ModelLoaderRegistry.getModelLoaders(model)</code>函数。</p><p>在构建Glide的单例时，会创建<code>Register</code>的实例，而<code>Register</code>会创建其他几个注册类，例如这里的<code>ModelLoaderRegistry</code>，Glide通过Register注册的内容会被代理到具体的注册类，这些注册类或者它们的工厂类会持有各自<code>Entry</code>元素的列表，Glide注册的所有内容（注册项）都以<code>Entry</code>实例被保存到对应列表。也就是它们的工作原理都是类似，然后通过<code>modelClass</code>、<code>resourceClass</code>、<code>transcodeClas</code>等去获取相关配置项。我们会把这些配置项整理成Excel文件，方便筛选。</p><p>**<code>ModelLoaderRegistry</code>**是注册类之一，主要持有<code>MultiModelLoaderFactory</code>工厂，所有的操作基本代理到工厂上，例如添加配置项到Entry列表。另外就是<code>ModelLoaderCache</code>缓存，毕竟每次寻找迭代所有配置项是昂贵的操作。<code>MultiModelLoaderFactory</code>工厂类主要根据给定的<code>modelClass</code>和<code>dataClass</code>(原始数据类型，例如<code>InputStream.Class</code>)获取一个或多个<code>ModelLoader</code>（这种寻找或者说映射关系就是所谓的配置项）。</p><p><code>ModelLoader</code>：是一个接口，有很多具体实现类，表示从不同的来源加载不同类型的资源。其<code>buildLoadData</code>函数返回<code>LoadData</code>对象，<code>handles</code>函数表示当前<code>ModelLoader</code>能否处理该<code>model</code>，通过该类型去加载原始数据。</p><p><code>LoadData</code>是<code>ModelLoader</code>的内部类,表示持有一个<code>Key</code>类型变量<code>sourceKey</code>用于标识正在加载的来源（地址）和备选的<code>Key</code>集合<code>alternateKeys</code>指向缓存数据，当没有缓存，通过<code>DataFetcher</code>对象<code>fetcher</code>从来源加载数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> Model model) {</span><br><span class="line">  <span class="keyword">return</span> modelLoaderRegistry.getModelLoaders(model);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="getmodelloaders"><a class="markdownIt-Anchor" href="#getmodelloaders"></a> <code>getModelLoaders</code></h3><p><code>getModelLoaders</code>函数调用了<code>getModelLoadersForClass</code>函数获取了<code>ModelLoader</code>列表<code>modelLoaders</code>，并迭代调用每个<code>ModelLoader</code>对象的<code>handles</code>函数过滤掉不能处理该模型具体内容的<code>ModelLoader</code>。例如列表中<code>ModelLoader</code>实例都能处理<code>String.class</code>，但有的<code>ModelLoader</code>能处理<code>http/https</code>开头的<code>String</code>，而有的不行，所以需要<code>ModelLoader</code>的<code>handles</code>函数再进一步过滤。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> A model) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; modelLoaders = getModelLoadersForClass(getClass(model));</span><br><span class="line">  <span class="keyword">if</span> (modelLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; filteredLoaders = Collections.emptyList();</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;A, ?&gt; loader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (loader.handles(model)) {<span class="comment">//过滤掉一些不能处理具体内容的</span></span><br><span class="line">      <span class="keyword">if</span> (isEmpty) {</span><br><span class="line">        filteredLoaders = <span class="keyword">new</span> ArrayList&lt;&gt;(size - i);</span><br><span class="line">        isEmpty = <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      filteredLoaders.add(loader);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (filteredLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model, modelLoaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> filteredLoaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="getmodelloadersforclass"><a class="markdownIt-Anchor" href="#getmodelloadersforclass"></a> <code>getModelLoadersForClass</code></h3><p><code>getModelLoadersForClass</code>函数根据<code>model</code>，先在缓存<code>ModelLoaderCache</code>(内部持有<code>HashMap</code>)对象<code>cache</code>获取<code>ModelLoader</code>列表<code>loaders</code>，没有的话再通过工厂<code>MultiModelLoaderFactory</code>对象的<code>build</code>函数创建。注意到创建列表后会缓存到<code>cache</code>中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoadersForClass(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;A&gt; modelClass) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; loaders = cache.get(modelClass);</span><br><span class="line">  <span class="keyword">if</span> (loaders == <span class="keyword">null</span>) {</span><br><span class="line">    loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));</span><br><span class="line">    cache.put(modelClass, loaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> loaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="multimodelloaderfactorybuildmodelclass"><a class="markdownIt-Anchor" href="#multimodelloaderfactorybuildmodelclass"></a> <code>multiModelLoaderFactory.build(modelClass)</code></h3><p><code>MultiModelLoaderFactory.build</code>函数创建<code>ModelLoader</code>列表。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; build(<span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass) {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    List&lt;ModelLoader&lt;Model, ?&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(modelClass)) {</span><br><span class="line">        alreadyUsedEntries.add(entry);</span><br><span class="line">        loaders.add(<span class="keyword">this</span>.&lt;Model, Object&gt;build(entry));</span><br><span class="line">        alreadyUsedEntries.remove(entry);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> loaders;</span><br><span class="line">  } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">    alreadyUsedEntries.clear();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遍历<code>Entry</code>集合<code>entries</code>，通过每个<code>Entry</code>实例的<code>handles</code>函数判断是否有能力处理该<code>model</code>，能处理的话通过<code>entry.factory.build(this)</code>创建<code>ModelLoader</code>。</p><p><code>Entry</code>类<code>handles</code>函数是判断该<code>Entry</code>能否处理该<code>model</code>，例如，<code>String.class</code>,<code>Uri.class</code>。而<code>ModelLoader</code>子类的<code>handles</code>函数判断是能否处理<code>model</code>类型的内容，例如字符串<code>https://xxm-sz.githuh.io</code>与<code>content://localstorage/data</code>，但有的<code>ModelLoader</code>直接返回<code>true</code>,在<code>buildLoadData</code>函数交给自身持有的<code>ModelLoader</code>或<code>ModelLoader</code>列表去处理。</p><p>贴一下到这里的<strong>调用图</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210323173012.png" alt="resouceCacheGenerator"></p><p>接下来，就涉及到<code>Entry</code>集合<code>entries</code>怎么来，以及<code>Entry</code>怎么创建<code>ModelLoader</code>。</p><p><code>ModelLoaderRegistry</code>在<code>Register</code>创建的时候被实例化，而在<code>GlideBuilder</code>构建建的过程中，会给<code>Register</code>设置超多的配置，这些配置中的<code>Loader</code>配置都会设置给<code>ModelLoaderRegistry</code>，每个配置都会封装成Entry保存到工厂类<code>MultiModelLoaderFactory</code>的<code>entries</code>列表中。而我们例子匹配到下面四个配置项。<img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331145147.png" alt="image-20210331145140795"></p><p>看看<code>MultiModelLoaderFactory</code>的<code>build</code>函数如何创建<code>ModelLoader</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultiModelLoaderFactory的build函数中的代码</span></span><br><span class="line">loaders.add(<span class="keyword">this</span>.&lt;Model, Data&gt;build(entry));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> Entry&lt;?, ?&gt; entry)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (ModelLoader&lt;Model, Data&gt;) Preconditions.checkNotNull(entry.factory.build(<span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>Entry</code>对象持有的<code>Factory</code>对象的<code>build</code>函数来创建<code>ModelLoader</code>实例。<code>Model</code>为<code>String.class</code>对应的<code>factory</code>为上面提到的4种<code>Factory</code>。</p><ul><li><code>DataUrlLoader.StreamFactory</code>：</li></ul><p><code>DataUrlLoader.StreamFacotry</code>的<code>build</code>函数是直接创建了<code>DataUrlLoader</code>对象，并将自身的<code>DataDecoder</code>对象<code>opener</code>作为参数传递给了<code>DataUrlLoader</code>构造函数。<code>DataUrlLoader</code>的<code>decode</code>函数对<code>String</code>进行合法检测，是否符合<code>base64 Image</code>的规范。</p><ul><li><code>StringLoader.StreamFactory()</code></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelLoader&lt;String, InputStream&gt; <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> MultiModelLoaderFactory multiFactory)</span> </span>{</span><br><span class="line">    <span class="comment">//StringLoader会将String转换成Uri,在代理给后面创建的Loader</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringLoader&lt;&gt;(multiFactory.build(Uri.class, InputStream.class));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>StringLoader.StreamFactory().build</code>又调用<code>MultiModelLoaderFactory</code>的<code>build</code>重载函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass, <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    List&lt;ModelLoader&lt;Model, Data&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> ignoredAnyEntries = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) {</span><br><span class="line">        ignoredAnyEntries = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(modelClass, dataClass)) {</span><br><span class="line">        alreadyUsedEntries.add(entry);</span><br><span class="line">        loaders.add(<span class="keyword">this</span>.&lt;Model, Data&gt;build(entry));</span><br><span class="line">        alreadyUsedEntries.remove(entry);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (loaders.size() &gt; <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> factory.build(loaders, throwableListPool);<span class="comment">//返回MutilModelLoader</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (loaders.size() == <span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> loaders.get(<span class="number">0</span>);<span class="comment">//返回单独的ModelLoader</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (ignoredAnyEntries) {</span><br><span class="line">        <span class="keyword">return</span> emptyModelLoader();</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(modelClass, dataClass);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">    alreadyUsedEntries.clear();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，又是一个从<code>Entry</code>列表中查找<code>Entry</code>对象的过程，只不过这时的<code>modelClass</code>是<code>Uri.Class</code>,<code>dataClass</code>是<code>InputStream.Class</code>。会调用<code>Entry</code>的<code>handles</code>函数表示能否处理该类型。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150606.png" alt="image-20210331150606495"></p><p>所以这里返回的将是<code>StringLoader</code>实例，但该实例包含<code>MultiModelLoader</code>对象，该对象持有其他<code>ModelLoader</code>的列表。</p><ul><li><code>StringLoader.FileDescriptorFactory()</code></li></ul><p>这里的<code>FileDescriptorFactory</code>最终也在注册项中匹配到<code>model</code>是<code>Uri.class,data</code>是<code>ParcelFileDescriptor.class</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150852.png" alt="image-20210331150852806"></p><p>所以这里返回的也是<code>StringLoader</code>实例，该实例也包含包含<code>MultiModelLoader</code>对象，该对象持有其他<code>ModelLoader</code>的列表。</p><ul><li><code>StringLoader.AssetFileDescriptorFactory()</code></li></ul><p>这里的<code>FileDescriptorFactory</code>最终也在注册项中选择<code>model</code>是<code>Uri.class</code>,<code>data</code>是<code>AssetFileDescriptor.class</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150929.png" alt="image-20210331150929807"></p><p>所以这里返回的也是<code>StringLoader</code>实例，但该实例只包含<code>UriLoader</code>。</p><p><code>ModelLoader</code>小结一下:</p><p>在Glide创建时，会将Glide能处理的<code>modelClass</code>，<code>dataClass</code>，以及创建<code>Loader</code>的<code>Factory</code>封装成<code>Entry</code>保存<code>ModelLoaderRegistry</code>的工厂类<code>MultiModelLoaderFactory</code>中。在后面发起的Glide请求，根据<code>modelClass</code>去找到合适的<code>ModelLoader</code>,会通过<code>Entry</code>和<code>ModelLoader</code>的<code>handles</code>函数过滤掉不匹配的类型和不能处理具体内容的<code>ModelLoader</code>。</p><h3 id="modelloaderbuildloaddata"><a class="markdownIt-Anchor" href="#modelloaderbuildloaddata"></a> <code>modelLoader.buildLoadData</code></h3><p>再回到<code>ModelLoaderRegister</code>的<a href="#%60getModelLoaders%60"><code>getModelLoaders</code></a>函数中，获取到能处理<code>String.class</code>类型的<code>ModelLoaders</code>列表后，迭代列表，调用每个<code>ModelLoader</code>的<code>handles</code>函数，由于<code>StringLoader</code>都返回<code>true</code>,而<code>DataUrlLoader</code>需要判断String以<code>data:image</code>开头，所以这里返回的<code>ModelLoader</code>只有三个。再回到上层函数<code>getLoadData</code>中，迭代<code>modelLoaders</code>列表并调用<code>modelLoader.buildLoadData</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> String model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  Uri uri = parseUri(model);</span><br><span class="line">  <span class="keyword">if</span> (uri == <span class="keyword">null</span> || !uriLoader.handles(uri)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> uriLoader.buildLoadData(uri, width, height, options);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于<code>StringLoader</code>中<code>uriLoader</code>是<code>UriLoader</code>类型的实例，其<code>handles</code>函数判断条件，显然与我们的例子不符。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> Uri model)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> SCHEMES.contains(model.getScheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SCHEMES =</span><br><span class="line">    Collections.unmodifiableSet(</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(</span><br><span class="line">                ContentResolver.SCHEME_FILE,</span><br><span class="line">                ContentResolver.SCHEME_ANDROID_RESOURCE,</span><br><span class="line">                ContentResolver.SCHEME_CONTENT)))</span><br></pre></td></tr></tbody></table></figure><p>对于<code>StringLoader</code>中<code>uriLoader</code>是<code>MultiModelLoader</code>对象的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  Key sourceKey = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  List&lt;DataFetcher&lt;Data&gt;&gt; fetchers = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;Model, Data&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (modelLoader.handles(model)) {</span><br><span class="line">      LoadData&lt;Data&gt; loadData = modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="keyword">null</span>) {</span><br><span class="line">        sourceKey = loadData.sourceKey;</span><br><span class="line">        fetchers.add(loadData.fetcher);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> !fetchers.isEmpty() &amp;&amp; sourceKey != <span class="keyword">null</span></span><br><span class="line">      ? <span class="keyword">new</span> LoadData&lt;&gt;(sourceKey, <span class="keyword">new</span> MultiFetcher&lt;&gt;(fetchers, exceptionListPool))</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>即调用<code>MultiModelLoader</code>对象中<code>ModeLoader</code>列表中每个<code>modelLoader</code>的<code>handles</code>函数。返回的将是一个包含<code>MultiFetcher</code>的<code>LoadData</code>。而这里符合我们例子的是<code>StringLoader.StreamFactory()</code>对象<code>build</code>生成的<code>MultiModelLoader</code>对象。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331150606.png" alt="image-20210331150606495"></p><p>在<code>MultiModelLoader</code>对象中<code>modelLoader</code>列表最后一项工厂<code>UrlUriLoader.StreamFactory</code>。看看<code>factory.build</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelLoader&lt;Uri, InputStream&gt; <span class="title">build</span><span class="params">(MultiModelLoaderFactory multiFactory)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UrlUriLoader&lt;&gt;(multiFactory.build(GlideUrl.class, InputStream.class));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>返回的是<code>UrlUriLoader</code>对象，其<code>handles</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> Uri uri)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> SCHEMES.contains(uri.getScheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SCHEMES =</span><br><span class="line">    Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"http"</span>, <span class="string">"https"</span>)));</span><br></pre></td></tr></tbody></table></figure><p>也就是说可以处理我们的URL地址。看看其参数，又是找匹配的注册项，生成<code>ModelLoader</code>对象并赋值给<code>UrlUriLoader</code>对象的<code>urlLoader</code>变量。<code>UrlUriLoader</code>的<code>buildLoadData</code>函数是委托给<code>urlLoader</code>对象的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public LoadData&lt;Data&gt; buildLoadData(</span><br><span class="line">    @NonNull Uri uri, int width, int height, @NonNull Options options) {</span><br><span class="line">  GlideUrl glideUrl = new GlideUrl(uri.toString());</span><br><span class="line">  return urlLoader.buildLoadData(glideUrl, width, height, options);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见<code>LoadData</code>的<code>sourceKey</code>的值就是<code>mode</code>的值，这时是我们的<code>url</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210331161732.png" alt="image-20210331161732384"></p><p>可见这里匹配到的<code>Loader</code>是<code>HttpGlideUrlLoader</code>。其<code>buildLoadData</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>{</span><br><span class="line">  <span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">  <span class="comment">// spent parsing urls.</span></span><br><span class="line">  GlideUrl url = model;</span><br><span class="line">  <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) {</span><br><span class="line">    url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) {</span><br><span class="line">      modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">      url = model;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以<code>getLoadData</code>函数最终返回只有一个<code>LoadData</code>对象的列表。该对象的<code>DataFetcher</code>是<code>MultiFetcher</code>。<code>MultiFetcher</code>对象列表中只有<code>HttpUrlFetcher</code>对象。</p><p>所以步骤1，<code>getCacheKeys</code>函数返回的是是一个<code>GlideUrl</code>。回到<code>startNext</code>函数的步骤2。</p><h3 id="getregisteredresourceclasses"><a class="markdownIt-Anchor" href="#getregisteredresourceclasses"></a> <code>getRegisteredResourceClasses()</code></h3><p>接着<a href="#"><code>startNext</code></a>函数的<code>getRegisteredResourceClasses()</code>函数。</p><p><code>getRegisteredResourceClasses</code>函数先在缓存中获取，获取不到的话通过类似<code>getChacheKeys</code>函数的步骤去步骤获取。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Model, TResource, Transcode&gt; List&lt;Class&lt;?&gt;&gt; getRegisteredResourceClasses(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass) {</span><br><span class="line">  <span class="comment">//获取缓存结果</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; result =</span><br><span class="line">      modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">    result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取dataClass列表</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; dataClasses = modelLoaderRegistry.getDataClasses(modelClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; dataClass : dataClasses) {</span><br><span class="line">     <span class="comment">//遍历每个dataClass对应的ResouceClass列表</span></span><br><span class="line">      List&lt;? extends Class&lt;?&gt;&gt; registeredResourceClasses =</span><br><span class="line">          decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">        <span class="comment">//迭代resourceClass列表去获取transcodeClassess</span></span><br><span class="line">        List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">            transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">         <span class="comment">//返回的transcodeClass列表有数据的resourceClass才添加在结果列表中。</span></span><br><span class="line">        <span class="keyword">if</span> (!registeredTranscodeClasses.isEmpty() &amp;&amp; !result.contains(registeredResourceClass)) {</span><br><span class="line">          result.add(registeredResourceClass);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    modelToResourceClassCache.put(</span><br><span class="line">        modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>ModelToResourceClassCache</code>类持持有<code>ArrayMap</code>类型的<code>registeredResourceClassCache</code>的变量，键值对为&lt;<code>MultiClassKey``List&lt;Class&gt;</code>&gt;，存取内容都是操作该变量的元素。而<code>MutilClassKey</code>则是以<code>modelClass</code>,<code>resourceClass</code>,<code>TranscodeClass</code>来作为<code>hash</code>,<code>equeas</code>函数计算的条件。</p><p>在没有缓存的情况，通过一下步骤获取：</p><h4 id="dataclass列表"><a class="markdownIt-Anchor" href="#dataclass列表"></a> <code>DataClass</code>列表</h4><ol><li>获取<code>DataClasses</code>列表</li></ol><p>通过<code>modelLoaderRegistry.getDataClasses</code>函数获取<code>dataClass</code>列表。<code>ModelLoaderRegistry</code>和<code>MultiModelLoaderFactory</code>在前面已经分析过了，这里快速过一遍。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ModelLoaderRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;Class&lt;?&gt;&gt; getDataClasses(<span class="meta">@NonNull</span> Class&lt;?&gt; modelClass) {</span><br><span class="line">  <span class="keyword">return</span> multiModelLoaderFactory.getDataClasses(modelClass);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//MultiModelLoaderFactory</span></span><br><span class="line"><span class="keyword">synchronized</span> List&lt;Class&lt;?&gt;&gt; getDataClasses(<span class="meta">@NonNull</span> Class&lt;?&gt; modelClass) {</span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">    <span class="keyword">if</span> (!result.contains(entry.dataClass) &amp;&amp; entry.handles(modelClass)) {</span><br><span class="line">      result.add(entry.dataClass);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是遍历<code>Entry</code>列表，判断<code>entry</code>能否处理<code>modelClass</code>，能的话加到列表<code>result</code>，迭代结束后返回<code>result</code>。按照我们的列子，返回的<code>dataClass</code>列表应该只有<code>InputStream.class</code>、<code>ParcelFileDescriptor.class</code>、<code>AssetFileDescriptor.class</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324110101.png" alt="image-20210324110054330"></p><h4 id="resourceclass列表"><a class="markdownIt-Anchor" href="#resourceclass列表"></a> <code>ResourceClass</code>列表</h4><ol start="2"><li>获取<code>resourceClass</code>列表</li></ol><p>在<code>Registry</code>的构造函数中，创建<code>ResourceDecoderRegistry</code>对象之后，会调用<code>setResourceDecoderBucketPriorityList</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setResourceDecoderBucketPriorityList(</span><br><span class="line">  Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setBucketPriorityList</span><span class="params">(<span class="meta">@NonNull</span> List&lt;String&gt; buckets)</span> </span>{</span><br><span class="line">  List&lt;String&gt; previousBuckets = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketPriorityList);</span><br><span class="line">  bucketPriorityList.clear();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : buckets) {</span><br><span class="line">    bucketPriorityList.add(bucket);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (String previousBucket : previousBuckets) {</span><br><span class="line">    <span class="keyword">if</span> (!buckets.contains(previousBucket)) {</span><br><span class="line">      bucketPriorityList.add(previousBucket);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时<code>modifiedBuckets</code>列表的内容应该是[<code>BUCKET_PREPEND_ALL</code>,<code>BUCKET_GIF</code>, <code>BUCKET_BITMAP</code>, <code>BUCKET_BITMAP_DRAWABLE</code>,<code>BUCKET_APPEND_ALL</code>]，都是String元素，然后调用<code>ResourceDecoderRegistry</code>对象的<code>setBucketPriorityList</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ResourceDecoderRegistry#setBucketPriorityList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setBucketPriorityList</span><span class="params">(<span class="meta">@NonNull</span> List&lt;String&gt; buckets)</span> </span>{</span><br><span class="line">  List&lt;String&gt; previousBuckets = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketPriorityList);</span><br><span class="line">  bucketPriorityList.clear();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : buckets) {</span><br><span class="line">    bucketPriorityList.add(bucket);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (String previousBucket : previousBuckets) {</span><br><span class="line">    <span class="keyword">if</span> (!buckets.contains(previousBucket)) {</span><br><span class="line">      bucketPriorityList.add(previousBucket);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就把<code>modifiedBuckets</code>列表的内容按序添加到了<code>bucketPriorityList</code>。这里主要在于添加顺序，从而更改不同的优先级。而在创建Glide时，也会将一些配置也会以<code>Entry</code>的形式注册到<code>ResourceDecoderRegistry</code>中。<code>ResourceDecoderRegistry</code>持有下面两个属性,<code>bucketPriorityList</code>用于保存前面提到的<code>String</code>类型的<code>BUCKET</code>，而<code>decoders</code>用于保存<code>Glide</code>的对<code>ResourceDecoderRegistry</code>的注册项。<code>Entry</code>持有的<code>Class</code>类型的<code>dataClass</code>,<code>resourceClass</code>和<code>ResourceDecoder</code>类型的<code>decoder</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;String&gt; bucketPriorityList = new ArrayList&lt;&gt;();</span><br><span class="line">private final Map&lt;String, List&lt;Entry&lt;?, ?&gt;&gt;&gt; decoders = new HashMap&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><p>通过Excel文件来看看<code>ResourceCacheRegister</code>中的注册项。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324205219.png" alt="image-20210324205014589"></p><p><code>resourceClass</code>只有<code>Bitmap.class</code>、<code>BitmapDrawable.class</code> 、<code>GifDrawable.class</code>，<code>Drawable.class</code>四种类型。</p><p>回到<code>getRegisteredResourceClasses()</code>函数，在获取<code>dataClass</code>列表后，调用了<code>decoderRegistry.getResourceClasses</code>函数获取<code>resourceClass</code>列表。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T, R&gt; List&lt;Class&lt;R&gt;&gt; getResourceClasses(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;T&gt; dataClass, <span class="meta">@NonNull</span> Class&lt;R&gt; resourceClass) {</span><br><span class="line">  List&lt;Class&lt;R&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : bucketPriorityList) {</span><br><span class="line">    List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket);</span><br><span class="line">    <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(dataClass, resourceClass)</span><br><span class="line">          &amp;&amp; !result.contains((Class&lt;R&gt;) entry.resourceClass)) {</span><br><span class="line">        result.add((Class&lt;R&gt;) entry.resourceClass);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getResourceClasses</code>函数中的<code>bucketPriorityList</code>的元素为key，遍历Entry列表，判断每个<code>Entry</code>实例能否处理该<code>dataClass</code>和<code>resourceClass</code>，能的话添加到<code>result</code>列表，并返回<code>result</code>。按照我们的列子，因为<code>dataClass</code>有<code>InputStream.class</code>、<code>ParcelFileDescriptor.class</code>、<code>AssetFileDescriptor.class</code>，而<code>resourceClass</code>是默认的<code>Object.class</code>。按照前面的注册项，再按key排序，这里返回<code>resourceClass</code>列表有[<code>GifDrawable.class</code>,<code>Bitmap.class</code>,<code>BitmapDrawable.class</code> ]</p><h4 id="transcodeclass列表"><a class="markdownIt-Anchor" href="#transcodeclass列表"></a> <code>TranscodeClass</code>列表</h4><ol start="3"><li>获取<code>transcodeClass</code>列表</li></ol><p>同样``TranscoderRegistry<code>注册类会在</code>Registry<code>构造函数中被创建，在</code>Glide<code>构造函数中被装配。</code>TranscoderRegistry<code>只持有一个</code>Entry<code>的列表。</code>Entry<code>持有</code>Class<code>类型的</code>fromClass<code>,</code>toClass<code>和</code>ResourceTransocder<code>类型的</code>transcoder`。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Entry&lt;?, ?&gt;&gt; transcoders = new ArrayList&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><p><code>Glide</code>构建过程会对``TranscoderRegistry`实例的注册项进行装配，通过Excel文件筛选。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324212620.png" alt="image-20210324212620640"></p><p>回到<code>getRegisteredResourceClasses()</code>函数，在获取<code>resourceClass</code>列表后通过<code>getTranscodeClasses</code>函数获取<code>transcodeClass</code>列表。函数参数<code>transcodeClass</code>可能是<code>Drawable.class</code>、<code>Bitmap.class</code>、<code>GifDrawable.class</code>，<code>File.class</code>。而在我们的例子中是默认的<code>Drawable.class</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Z, R&gt; List&lt;Class&lt;R&gt;&gt; getTranscodeClasses(<span class="meta">@NonNull</span> Class&lt;Z&gt; resourceClass, <span class="meta">@NonNull</span> Class&lt;R&gt; transcodeClass{</span><br><span class="line">  List&lt;Class&lt;R&gt;&gt; transcodeClasses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// transcodeClass是resourceClass的父类、父接口或者相同</span></span><br><span class="line">  <span class="keyword">if</span> (transcodeClass.isAssignableFrom(resourceClass)) {</span><br><span class="line">    transcodeClasses.add(transcodeClass);</span><br><span class="line">    <span class="keyword">return</span> transcodeClasses;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//遍历Entry列表,判断Entry能否处理转换，可以的话返回transcodeClass</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : transcoders) {</span><br><span class="line">    <span class="keyword">if</span> (entry.handles(resourceClass, transcodeClass)) {</span><br><span class="line">      transcodeClasses.add(transcodeClass);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> transcodeClasses;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到<code>Registry</code>的<code>getRegisteredResourceClasses</code>函数中获取<code>transcodeClass</code>列表之后，判断并添加到<code>result</code>列表中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">  <span class="comment">//registeredResourceClass有Bitmap.class、BitmapDrawable.class、GifDrawable.class</span></span><br><span class="line">  <span class="comment">//transcodeClass是Drawable.class</span></span><br><span class="line">         List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">             transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">         <span class="keyword">if</span> (!registeredTranscodeClasses.isEmpty() &amp;&amp; !result.contains(registeredResourceClass)) {</span><br><span class="line">           result.add(registeredResourceClass);</span><br><span class="line">         }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure><p>所以<code>startNext</code>函数中返回的最终<code>resourceClass</code>列表是[<code>Bitmap.class</code>、<code>BitmapDrawable.class</code>、<code>GifDrawable.class</code>]</p><p>回到<a href="#%60startNext%60"><code>startNext</code></a>函数的步骤4。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">  resourceClassIndex++;</span><br><span class="line">  <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) {</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">  Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">  Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">  currentKey =</span><br><span class="line">      <span class="keyword">new</span> ResourceCacheKey( <span class="comment">// NOPMD AvoidInstantiatingObjectsInLoops</span></span><br><span class="line">          helper.getArrayPool(),</span><br><span class="line">          sourceId,</span><br><span class="line">          helper.getSignature(),</span><br><span class="line">          helper.getWidth(),</span><br><span class="line">          helper.getHeight(),</span><br><span class="line">          transformation,</span><br><span class="line">          resourceClass,</span><br><span class="line">          helper.getOptions());</span><br><span class="line">  cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">   <span class="comment">//找到了缓存文件后，且获取modelLoaders不为null，表明找到了最终合适的缓存，退出循环</span></span><br><span class="line">  <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">    sourceKey = sourceId;</span><br><span class="line">    modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">    modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尝试遍历步骤1获取到的<code>Key</code>列表和步骤2获取到<code>resourceClass</code>列表的每个元素，以及其他元素，计算出<code>ResourceCacheKey</code>对象，然后通过</p><p><code>helper.getDiskCache().get(currentKey)</code>在磁盘缓存获取。</p><h3 id="disklrucache"><a class="markdownIt-Anchor" href="#disklrucache"></a> <code>DiskLruCache</code></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DiskCache <span class="title">getDiskCache</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> diskCacheProvider.getDiskCache();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过追溯<code>diskCacheProvider</code>来源，在<code>Engine</code>的<code>build</code>函数有如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DecodeJob&lt;R&gt; result = Preconditions.checkNotNull((DecodeJob&lt;R&gt;) pool.acquire());</span><br></pre></td></tr></tbody></table></figure><p>而<code>pool</code>则是Engine的静态内部类<code>DecodeJobFactory</code>的一个对象池。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Pools.Pool&lt;DecodeJob&lt;?&gt;&gt; pool =</span><br><span class="line">  FactoryPools.threadSafe(</span><br><span class="line">      JOB_POOL_SIZE,</span><br><span class="line">      <span class="keyword">new</span> FactoryPools.Factory&lt;DecodeJob&lt;?&gt;&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> DecodeJob&lt;?&gt; create() {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DecodeJob&lt;&gt;(diskCacheProvider, pool);</span><br><span class="line">        }</span><br><span class="line">      });</span><br></pre></td></tr></tbody></table></figure><p><code>DecodeJobFactory</code>的创建追溯到<code>Engine</code>的构造器中</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.diskCacheProvider = <span class="keyword">new</span> LazyDiskCacheProvider(diskCacheFactory)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (decodeJobFactory == <span class="keyword">null</span>) {</span><br><span class="line">    decodeJobFactory = <span class="keyword">new</span> DecodeJobFactory(diskCacheProvider);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位到GlideBuider的build函数</span></span><br><span class="line"><span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) {</span><br><span class="line">  diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所有这里<code>diskCacheProvider</code>定位到时<code>LazyDiskCacheProvider</code>的实例，而factory是<code>InternalCacheDiskCacheFactory</code>。再查看其<code>getDiskCache</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LazyDiskCacheProvider</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiskCache <span class="title">getDiskCache</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">      <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">        diskCache = factory.build();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (diskCache == <span class="keyword">null</span>) {</span><br><span class="line">        diskCache = <span class="keyword">new</span> DiskCacheAdapter();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> diskCache;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先通过<code>factory.build</code>函数创建<code>diskCache</code>，创建失败则创建<code>DiskCacheAdapter</code>实例。定位到<code>InternalCacheDiskCacheFactory</code>类的父类<code>DiskLruCacheFactory</code>的<code>build</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DiskCache <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">  File cacheDir = cacheDirectoryGetter.getCacheDirectory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheDir.isDirectory() || cacheDir.mkdirs()) {</span><br><span class="line">    <span class="keyword">return</span> DiskLruCacheWrapper.create(cacheDir, diskCacheSize);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里<code>cacheDirectoryGetter</code>在<code>InternalCacheDiskCacheFactory</code>创建时被实例化，提供一个缓存文件，用于存取缓存资源。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalCacheDiskCacheFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Context context, <span class="keyword">final</span> String diskCacheName, <span class="keyword">long</span> diskCacheSize)</span> </span>{</span><br><span class="line">  <span class="keyword">super</span>(</span><br><span class="line">      <span class="keyword">new</span> CacheDirectoryGetter() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDirectory</span><span class="params">()</span> </span>{</span><br><span class="line">          File cacheDirectory = context.getCacheDir();</span><br><span class="line">          <span class="keyword">if</span> (cacheDirectory == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (diskCacheName != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(cacheDirectory, diskCacheName);</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> cacheDirectory;</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      diskCacheSize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是<code>factory.build</code>函数需要获取到<code>/data/data/&lt;application package&gt;/cache</code>目录才能进一步通过<code>DiskLruCacheWrapper.create(cacheDir, diskCacheSize)</code>创建<code>CacheFile</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DiskLruCacheWrapper</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.directory = directory;</span><br><span class="line">  <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">  <span class="keyword">this</span>.safeKeyGenerator = <span class="keyword">new</span> SafeKeyGenerator();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，那么``getDiskCache<code>返回的就是</code>DiskLruCacheWrapper<code>对象，看看其</code>getDiskCache`函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DiskLruCache <span class="title">getDiskCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  <span class="keyword">if</span> (diskLruCache == <span class="keyword">null</span>) {</span><br><span class="line">    diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> diskLruCache;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说，利用了<code>DisLruChache</code>来缓存资源。</p><p>假如<code>factory.build</code>返回是<code>null</code>,那么<code>getDiskCache</code>返回的是<code>DiskCacheAdapter</code>。</p><h3 id="helpergetmodelloaders"><a class="markdownIt-Anchor" href="#helpergetmodelloaders"></a> <code>helper.getModelLoaders</code></h3><p>假设获取到了<code>cacheFile</code>，看看<code>helper.getModelLoaders(cacheFile)</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeHelper</span></span><br><span class="line">List&lt;ModelLoader&lt;File, ?&gt;&gt; getModelLoaders(File file)</span><br><span class="line">    <span class="keyword">throws</span> Registry.NoModelLoaderAvailableException {</span><br><span class="line">  <span class="keyword">return</span> glideContext.getRegistry().getModelLoaders(file);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Register</span></span><br><span class="line"><span class="keyword">public</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> Model model) {</span><br><span class="line">  <span class="keyword">return</span> modelLoaderRegistry.getModelLoaders(model);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//ModelLoaderRegister</span></span><br><span class="line"><span class="keyword">public</span> &lt;A&gt; List&lt;ModelLoader&lt;A, ?&gt;&gt; getModelLoaders(<span class="meta">@NonNull</span> A model) {</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; modelLoaders = getModelLoadersForClass(getClass(model));</span><br><span class="line">  <span class="keyword">if</span> (modelLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> size = modelLoaders.size();</span><br><span class="line">  <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line">  List&lt;ModelLoader&lt;A, ?&gt;&gt; filteredLoaders = Collections.emptyList();</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    ModelLoader&lt;A, ?&gt; loader = modelLoaders.get(i);</span><br><span class="line">    <span class="keyword">if</span> (loader.handles(model)) {</span><br><span class="line">      <span class="keyword">if</span> (isEmpty) {</span><br><span class="line">        filteredLoaders = <span class="keyword">new</span> ArrayList&lt;&gt;(size - i);</span><br><span class="line">        isEmpty = <span class="keyword">false</span>;</span><br><span class="line">      }</span><br><span class="line">      filteredLoaders.add(loader);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (filteredLoaders.isEmpty()) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(model, modelLoaders);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> filteredLoaders;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>helper.getModelLoaders(cacheFile)</code>函数最终还是调用了<code>ModelLoaderRegister.getModelLoaders</code>函数，和前面分析得<code>getChacheKeys</code>是一致的，只是这里<code>model</code>是<code>File.class</code>。所以直接找到相关注册项。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.append(File.class, ByteBuffer.class, <span class="keyword">new</span> ByteBufferFileLoader.Factory())</span><br><span class="line">.append(File.class, InputStream.class, <span class="keyword">new</span> FileLoader.StreamFactory())</span><br><span class="line">.append(File.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileLoader.FileDescriptorFactory())</span><br><span class="line"><span class="comment">// Compilation with Gradle requires the type to be specified for UnitModelLoader here.</span></span><br><span class="line">.append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance())</span><br></pre></td></tr></tbody></table></figure><p>所以步骤3得到的<code>modelLoaders</code>列表为[<code>ByteBufferFileLoader</code>,<code>FileLoader&lt;InputStream&gt;</code>,<code>FileLoader&lt;ParcelFileDescriptor&gt;</code>,<code>UnitModelLoader</code>]</p><p>接下来步骤4，根据遍历<code>modelLoaders</code>列表的每个<code>ModelLoader</code>对象,尝试加载数据，直到找到第一个能处理该Glide请求的<code>ModelLoader</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loadData = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">  ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">  loadData =</span><br><span class="line">      modelLoader.buildLoadData(</span><br><span class="line">          cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">  <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">    loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看一下四个匹配到的<code>ModelLoader</code>的<code>buildLoadData</code>函数返回的<code>LoadData</code>对象中的<code>DataFetcher</code>对象<code>fetcher</code>。</p><ul><li><p><code>ByteBufferFileLoader</code></p><p>返回的<code>LoadDadata</code>中的是<code>ByteBufferFetcher(file)</code>,其<code>getDataClass</code>函数返回<code>ByteBuffer.class</code>。</p></li><li><p><code>FileLoader.StreamFactory()</code></p><p>返回的<code>LoadDadata</code>中的是<code>FileFetcher&lt;&gt;(model, fileOpener)</code>,<code>fileOpener</code>是<code>FileOpener&lt;InputStream&gt;</code>类型，其<code>getDataClass</code>函数返回<code>InputStream.class</code></p></li><li><p><code>FileLoader.FileDescriptorFactory()</code></p><p>返回的<code>LoadDadata</code>中的是<code>FileFetcher&lt;&gt;(model, fileOpener))</code>,<code>fileOpener</code>是<code>FileOpener&lt;ParcelFileDescriptor&gt;</code>类型，其<code>getDataClass</code>函数返回<code>ParcelFileDescriptor.class</code></p></li><li><p><code>UnitModelLoader</code></p><p>返回的<code>LoadDadata</code>中的是<code>UnitFetcher(file)</code>,其<code>getDataClass</code>函数返回<code>File.class</code>。</p></li></ul><p>接下来看看<code>helper.hasLoadPath(loadData.fetcher.getDataClass())</code>这个函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DecodeHelper</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLoadPath</span><span class="params">(Class&lt;?&gt; dataClass)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> getLoadPath(dataClass) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;Data&gt; LoadPath&lt;Data, ?, Transcode&gt; getLoadPath(Class&lt;Data&gt; dataClass) {</span><br><span class="line">  <span class="keyword">return</span> glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Register</span></span><br><span class="line"><span class="keyword">public</span> &lt;Data, TResource, Transcode&gt; <span class="function">LoadPath&lt;Data, TResource, Transcode&gt; <span class="title">getLoadPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass)</span> </span>{</span><br><span class="line">  <span class="comment">//先从缓存获取</span></span><br><span class="line">  LoadPath&lt;Data, TResource, Transcode&gt; result =</span><br><span class="line">      loadPathCache.get(dataClass, resourceClass, transcodeClass);</span><br><span class="line">  <span class="keyword">if</span> (loadPathCache.isEmptyLoadPath(result)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果LoadPath是NO_PATHS_SIGNAL</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="keyword">null</span>) {<span class="comment">//缓存没有，则创建</span></span><br><span class="line">    List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths =</span><br><span class="line">        getDecodePaths(dataClass, resourceClass, transcodeClass);</span><br><span class="line">    <span class="keyword">if</span> (decodePaths.isEmpty()) {</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      result =</span><br><span class="line">          <span class="keyword">new</span> LoadPath&lt;&gt;(</span><br><span class="line">              dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);</span><br><span class="line">    }</span><br><span class="line">    loadPathCache.put(dataClass, resourceClass, transcodeClass, result);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以主要看下<code>getDecodePath</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> &lt;Data, TResource, Transcode&gt; List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; getDecodePaths(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass) {</span><br><span class="line">  List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;Class&lt;TResource&gt;&gt; registeredResourceClasses =</span><br><span class="line">      decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Class&lt;TResource&gt; registeredResourceClass : registeredResourceClasses) {</span><br><span class="line">    List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses =</span><br><span class="line">        transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;Transcode&gt; registeredTranscodeClass : registeredTranscodeClasses) {</span><br><span class="line"></span><br><span class="line">      List&lt;ResourceDecoder&lt;Data, TResource&gt;&gt; decoders =</span><br><span class="line">          decoderRegistry.getDecoders(dataClass, registeredResourceClass);</span><br><span class="line">      ResourceTranscoder&lt;TResource, Transcode&gt; transcoder =</span><br><span class="line">          transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);</span><br><span class="line">      <span class="meta">@SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops")</span></span><br><span class="line">      DecodePath&lt;Data, TResource, Transcode&gt; path =</span><br><span class="line">          <span class="keyword">new</span> DecodePath&lt;&gt;(</span><br><span class="line">              dataClass,</span><br><span class="line">              registeredResourceClass,</span><br><span class="line">              registeredTranscodeClass,</span><br><span class="line">              decoders,</span><br><span class="line">              transcoder,</span><br><span class="line">              throwableListPool);</span><br><span class="line">      decodePaths.add(path);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> decodePaths;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getDecodePaths</code>函数中几个函数已经分析过了，说一下大概逻辑，<code>resourceClass=Object.class</code>、<code>transcodeClass=Drawable.class</code>。从<code>ModelLoader</code>列表开始，第一个<code>dataClass</code>取<code>ByteBufferFileLoader</code>的<code>ByteBuffer.class</code>。</p><ol><li><p>先通过<code>dataClass</code>和<code>resourceClass</code>去获取<code>registerResourceClass</code>列表。利用前面整理的Excel文件，筛选一下。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324205726.png" alt="image-20210324205726342"></p><p>去掉重复的，再根据<code>Key</code>的优先级排序，那么得到的<code>registerResourceClass</code>=[<code>GifDrawable.class</code>，<code>Bitmap.class</code>、<code>BitmapDrawable.class</code>]</p></li><li><p>遍历<code>registerResourceClass</code>列表，通过<code>registeredResourceClass</code>和<code>transcodeClass</code>获取<code>registeredTranscodeClasses</code>列表。</p><p>由于是遍历<code>registerResourceClass</code>列表，将会生成三个<code>registeredTranscodeClasses</code>列表。根据<code>transcoderRegistry.getTranscodeClasses</code>函数内容的处理规则，这个三个列表是相同的，且只持有一个<code>Drawable.class</code>元素。</p></li><li><p>然后再迭代每个<code>registeredTranscodeClasses</code>列表。</p><p>根据<code>dataClass</code>和<code>registeredResourceClass</code>获取<code>decoders</code>列表。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T, R&gt; List&lt;ResourceDecoder&lt;T, R&gt;&gt; getDecoders(</span><br><span class="line">    <span class="meta">@NonNull</span> Class&lt;T&gt; dataClass, <span class="meta">@NonNull</span> Class&lt;R&gt; resourceClass) {</span><br><span class="line">  List&lt;ResourceDecoder&lt;T, R&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String bucket : bucketPriorityList) {</span><br><span class="line">    List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket);</span><br><span class="line">    <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) {</span><br><span class="line">      <span class="keyword">if</span> (entry.handles(dataClass, resourceClass)) {</span><br><span class="line">        result.add((ResourceDecoder&lt;T, R&gt;) entry.decoder);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据<code>registeredResourceClass</code>和<code>registeredTranscodeClass</code>获取<code>transcoder</code>列表</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Z, R&gt; <span class="function">ResourceTranscoder&lt;Z, R&gt; <span class="title">get</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;Z&gt; resourceClass, <span class="meta">@NonNull</span> Class&lt;R&gt; transcodedClass)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (transcodedClass.isAssignableFrom(resourceClass)) {</span><br><span class="line">    <span class="keyword">return</span> (ResourceTranscoder&lt;Z, R&gt;) UnitTranscoder.get();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : transcoders) {</span><br><span class="line">    <span class="keyword">if</span> (entry.handles(resourceClass, transcodedClass)) {</span><br><span class="line">      <span class="keyword">return</span> (ResourceTranscoder&lt;Z, R&gt;) entry.transcoder;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">      <span class="string">"No transcoder registered to transcode from "</span> + resourceClass + <span class="string">" to "</span> + transcodedClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>ResourceRegister.getDecoders</code>函数和<code>TranscodeRegister.get</code>函数逻辑，再加上整理出的Excel表格，可以得出<code>decoders</code>列表和<code>transcoders</code>列表内容。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210324223542.png" alt="image-20210324223542318"></p><p>然后包装成<code>DecodePath</code>元素，添加到<code>decodePaths</code>列表中。最后将<code>decodePaths</code>列表返回。也就是图中三条横线边框就是三条<code>DecodePath</code>,这个方框就是<code>decodePaths</code>。</p></li></ol><p>回到<code>startNext</code>函数的步骤4中的<code>helper.hasLoadPath(loadData.fetcher.getDataClass())</code>返回true，然后调用<code>fetcher.loadData</code>函数加载数据。</p><h3 id="fetcherloaddata"><a class="markdownIt-Anchor" href="#fetcherloaddata"></a> <code>fetcher.loadData</code></h3><p>这里的<code>fetcher</code>通过上面的分析就是``ByteBufferFetcher<code>。查看</code>loadData`函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> ByteBuffer&gt; callback)</span> </span>{</span><br><span class="line">  ByteBuffer result;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    result = ByteBufferUtil.fromFile(file);</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to obtain ByteBuffer for file"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>ByteBufferUtil.fromFile(file)</code>正常的文件读取操作获取<code>ByteBuffer</code>数据。然后通过<code>callback.onDataReady(result)</code>回调。<code>ResourceCacheGenerator.startNext</code>函数也到此结束，完结撒花。</p><h3 id="resoucrcachegenerator小结"><a class="markdownIt-Anchor" href="#resoucrcachegenerator小结"></a> <code>ResoucrCacheGenerator</code>小结</h3><p><code>ResoucrCacheGenerator</code>主要通过<code>DataFetcher</code>从缓存文件获取采样和转化的数据资源。其<code>startNext</code>函数主要是通过<code>modelClass</code>和<code>resourceClass</code>、<code>transcodeClass</code>去获取合适的<code>modelLoader</code>、<code>decoder</code>和<code>transcoder</code>，并构成<code>DecodePaths</code>。这样在回调中，就可以通过这些<code>Paths</code>寻找到合适的去加载数据并采样，转化资源。</p><h2 id="datacachegenerator"><a class="markdownIt-Anchor" href="#datacachegenerator"></a> <code>DataCacheGenerator</code></h2><p>初始加载，那么<code>ResoucrCacheGenerator.startNext</code>函数将返回<code>false</code>,回到<code>DecodeJob</code>的<code>runGenerators</code>函数。此时获取到下一个Stage是<code>Stage.DATA_CACHE</code>，Generator是<code>DataCacheGenerator</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void runGenerators() {</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  boolean isStarted = false;</span><br><span class="line">  while (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != null</span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) {</span><br><span class="line">    stage = getNextStage(stage);//这里返回将是Stage.DATA_CACHE</span><br><span class="line">    currentGenerator = getNextGenerator();//这里返回的将是DataCacheGenerator</span><br><span class="line"></span><br><span class="line">    if (stage == Stage.SOURCE) {</span><br><span class="line">      reschedule();</span><br><span class="line">      return;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {</span><br><span class="line">    notifyFailed();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void reschedule() {</span><br><span class="line">  runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">  callback.reschedule(this);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>查看<code>DataCacheGenerator</code>的<code>startNext</code>函数。由于前面分析了<code>ResourceCacheGenerator</code>，所以下接下来回轻松很多。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) {</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">    Key originalKey = <span class="keyword">new</span> DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">    <span class="comment">//获取缓存文件</span></span><br><span class="line">    cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(</span><br><span class="line">            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>ResourceCacheGenerator</code>查找到的<code>cacheKeys</code>会保存在<code>DecodeHelper</code>中，避免每次都需要重新寻找。<code>DataCacheGenerator</code>的主要作用从缓存资源中获取原始数据，其<code>startNext</code>函数与ResocurceCacheGenerator非常相似，这里不作展开。</p><h2 id="sourcegeneator"><a class="markdownIt-Anchor" href="#sourcegeneator"></a> <code>SourceGeneator</code></h2><p>回到<code>DecodeJob</code>的<code>runGenerators</code>函数，那么将执行<code>SourceGenerator</code>函数，从数据来源获取数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) {</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) {</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      startNextLoad(loadData);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在前面分析中，<code>helper.getLoadData()</code>这里返回的是<code>LoadData</code>列表只有一个<code>LoadData</code>元素，而且其<code>DataFetcher</code>是<code>MultiFetcher</code>对象。且<code>MultiFetcher</code>对象持有<code>HttpUrlFetcher</code>对象。</p><p>再看上面代码，<code>helper.getDiskCacheStrategy().isDataCacheable</code>函数，默认情况下<code>DiskCacheStrategy</code>是<code>AUTOMATIC</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataCacheable</span><span class="params">(DataSource dataSource)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> dataSource == DataSource.REMOTE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再看<code>MultiFetcher</code>的<code>getDataSource</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> fetchers.get(<span class="number">0</span>).getDataSource();</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>调用<code>HttpUrlFetcher</code>的<code>getDataSource</code>函数，其返回的也是<code>DataSource.REMOTE</code>,所以该条件成立。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> DataSource.REMOTE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而<code>getDataClass</code>返回的是<code>InputStream.class</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;InputStream&gt; <span class="title">getDataClass</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> InputStream.class;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="startnextloadloaddata"><a class="markdownIt-Anchor" href="#startnextloadloaddata"></a> <code>startNextLoad(loadData)</code></h3><p>查看<code>startNextLoad(loadData)</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> </span>{</span><br><span class="line">  loadData.fetcher.loadData(</span><br><span class="line">      helper.getPriority(),</span><br><span class="line">      <span class="keyword">new</span> DataCallback&lt;Object&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> </span>{</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) {</span><br><span class="line">            onDataReadyInternal(toStart, data);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>{</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) {</span><br><span class="line">            onLoadFailedInternal(toStart, e);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>MultiFetcher</code>的<code>loadData</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> Data&gt; callback)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.priority = priority;</span><br><span class="line">  <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  exceptions = throwableListPool.acquire();</span><br><span class="line">  fetchers.get(currentIndex).loadData(priority, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isCancelled) {</span><br><span class="line">    cancel();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用<code>HttpUrlFetcher</code>的<code>loadData</code>函数。在<code>loadData</code>函数中，获取输入流无论成功与败将通过<code>callback</code>回掉通知。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>{</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {</span><br><span class="line">      Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见调用了<code>loadDataWithRedirects</code>函数并返回了数据。<code>loadDataWithRedirects</code>函数主要是通过<code>HttpURLConnection</code>来进行网络请求，并获取数据。同时也允许重定向，但次数不能超过5次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    URL url, <span class="keyword">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  <span class="comment">//重定向次数大于5抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Too many (&gt; "</span> + MAXIMUM_REDIRECTS + <span class="string">") redirects!"</span>, INVALID_STATUS_CODE);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">...</span><br><span class="line">  <span class="comment">//步骤1：创建HttpUrlConnection</span></span><br><span class="line">  urlConnection = buildAndConfigureConnection(url, headers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//连接网络并获取输入流</span></span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Failed to connect or obtain data"</span>, getHttpStatusCodeOrInvalid(urlConnection), e);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCancelled) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = getHttpStatusCodeOrInvalid(urlConnection);</span><br><span class="line">  <span class="keyword">if</span> (isHttpOk(statusCode)) {<span class="comment">//连接成功回调</span></span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) {<span class="comment">//重定向</span></span><br><span class="line">    String redirectUrlString = urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Received empty or null redirect url"</span>, statusCode);</span><br><span class="line">    }</span><br><span class="line">    URL redirectUrl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">    } <span class="keyword">catch</span> (MalformedURLException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Bad redirect url: "</span> + redirectUrlString, statusCode, e);</span><br><span class="line">    }</span><br><span class="line">    cleanup();</span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == INVALID_STATUS_CODE) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"Failed to get a response message"</span>, statusCode, e);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>步骤1：通过<code>connectionFactory.build</code>函数创建了<code>HttpURLConenction</code>实例，并配置了相关信息。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HttpURLConnection <span class="title">buildAndConfigureConnection</span><span class="params">(URL url, Map&lt;String, String&gt; headers)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  HttpURLConnection urlConnection;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">"URL.openConnection threw"</span>, <span class="comment">/*statusCode=*/</span> <span class="number">0</span>, e);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {</span><br><span class="line">    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">  }</span><br><span class="line">  urlConnection.setConnectTimeout(timeout);</span><br><span class="line">  urlConnection.setReadTimeout(timeout);</span><br><span class="line">  urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">  urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">  urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> urlConnection;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的<code>ConnectionFactory</code>实例我们使用了默认的<code>DefaultHttpUrlConnectionFactory</code>。其<code>build</code>函数通过<code>Url.openConnection</code>返回了一个网络连接。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpURLConnection <span class="title">build</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  <span class="keyword">return</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在判断请求成功，通过<code>getStreamForSuccessfulRequest</code>函数去获取输入流。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">getStreamForSuccessfulRequest</span><span class="params">(HttpURLConnection urlConnection)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> HttpException </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(urlConnection.getContentEncoding())) {</span><br><span class="line">      <span class="keyword">int</span> contentLength = urlConnection.getContentLength();</span><br><span class="line">      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {</span><br><span class="line">        Log.d(TAG, <span class="string">"Got non empty content encoding: "</span> + urlConnection.getContentEncoding());</span><br><span class="line">      }</span><br><span class="line">      stream = urlConnection.getInputStream();</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">"Failed to obtain InputStream"</span>, getHttpStatusCodeOrInvalid(urlConnection), e);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，也就从网络获取到图片的输入流，我们到此告一段落。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>把Glide数据来源整理一下，也是Glide的缓存机制。接下来的章节也将继续分析下图的问号？</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210402165140.png" alt="未命名绘图"></p><p>缓存总的来说应该只有内存缓存和硬盘缓存。而Glide在两个缓存上再各细分出两个缓存，总得来说就有四个缓存了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h1&gt;
&lt;p&gt;作为Glide的第二篇，主要分析了Glide请求中数据来源，或者说Glide的缓存机制。Glide构建过程会配置很多注册项，然后在获取数据时，会</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Glide" scheme="http://example.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide源码分析之流程</title>
    <link href="http://example.com/2021/03/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/03/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%B5%81%E7%A8%8B/</id>
    <published>2021-03-28T16:00:00.000Z</published>
    <updated>2021-03-29T10:17:31.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>Glide流程三步曲<code>with</code>、<code>load</code>、<code>into</code>三个函数，完成一次Glide请求。<code>with</code>的主要工作是首次创建Glide单例，并装配Glide各种配置参数和创建相关实例，这些都会在<code>into</code>函数中被使用到,第二个要点就是与Fragment的生命周期绑定，让Glide请求能感应到生命周期的变化，从而可以进行暂停，恢复，发起请求的一下操作。<code>load</code>函数则是构建本次<code>Glide</code>请求的相关信息，例如<code>RequestBuilder</code>、<code>RequestOptions</code>等。<code>into</code>函数则是Glide的核心，包括缓存，解码，采样转化，资源获取等等。</p><p>Glide源码分析基于<code>Glide 4.12.0</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.github.bumptech.glide:glide:4.12.0'</span></span><br><span class="line">annotationProcessor <span class="string">'com.github.bumptech.glide:compiler:4.12.0'</span></span><br></pre></td></tr></tbody></table></figure><p>由于源码分析阶段会有很多分支，很多的类型，所以在一些点会基于下面例子分析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val url=<span class="string">"http//:www.xxm-sz.githu.io/test.png"</span></span><br><span class="line">Glide.with(<span class="keyword">this</span>).load(url).into(imageView)</span><br></pre></td></tr></tbody></table></figure><h2 id="with函数"><a class="markdownIt-Anchor" href="#with函数"></a> <code>with</code>函数</h2><h3 id="glide单例的创建"><a class="markdownIt-Anchor" href="#glide单例的创建"></a> Glide单例的创建</h3><p><code>Glide.with</code>有很多重载函数。这里以<code>Activity</code>为例分析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Glide.with</code>的所有重载函数中的<code>getRetriever</code>都是调用<code>getRetriever</code>来生成<code>Glide</code>单例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> </span>{</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Glide.get(context)</code>通过<strong>双重检查</strong>实现单例模式，生成Glide实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (glide == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">//步骤1</span></span><br><span class="line">    GeneratedAppGlideModule annotationGeneratedModule =</span><br><span class="line">        getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">    <span class="keyword">synchronized</span> (Glide.class) {</span><br><span class="line">      <span class="keyword">if</span> (glide == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> glide;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>Application</code> 模块中，可创建一个添加有 <code>@GlideModule</code> 注解，继承自 <code>AppGlideModule</code> 的类，这样就可以通过流式API使用Glide。<code>GeneratedAppGlideModule</code>也就是对应该注解类的。</p><p><strong>步骤1：</strong> <code>getAnnotationGeneratedGlideModules</code>函数主要通过反射获取我们<code>AppGlideModule</code>实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GeneratedAppGlideModule <span class="title">getAnnotationGeneratedGlideModules</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">  GeneratedAppGlideModule result = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line">   Class&lt;GeneratedAppGlideModule&gt; clazz =</span><br><span class="line">        (Class&lt;GeneratedAppGlideModule&gt;)</span><br><span class="line">            Class.forName(<span class="string">"com.bumptech.glide.GeneratedAppGlideModuleImpl"</span>);</span><br><span class="line">   result =</span><br><span class="line">        clazz.getDeclaredConstructor(Context.class).newInstance(context.getApplicationContext());</span><br><span class="line"> ...</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤2：</strong> <code>checkAndInitializeGlide</code>函数最终会调用到<code>initializeGlide</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> GlideBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> GeneratedAppGlideModule annotationGeneratedModule)</span> </span>{</span><br><span class="line">  Context applicationContext = context.getApplicationContext();</span><br><span class="line">  List&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">  <span class="comment">//通过AndroidManifest文件解析Module</span></span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule == <span class="keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) {</span><br><span class="line">    manifestModules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//将AndroidManifest文件解析到的所有Module中剔除掉通过注解获取到的Module</span></span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">    Iterator&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">      com.bumptech.glide.<span class="keyword">module</span>.GlideModule current = iterator.next();</span><br><span class="line">      <span class="keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      iterator.remove();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">      annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">          ? annotationGeneratedModule.getRequestManagerFactory()</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line">  builder.setRequestManagerFactory(factory);</span><br><span class="line">  <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) {</span><br><span class="line">    <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) {</span><br><span class="line">    annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//通过GildeBuilder构建出Glide</span></span><br><span class="line">  Glide glide = builder.build(applicationContext);</span><br><span class="line">  <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">    } <span class="keyword">catch</span> (AbstractMethodError e) {</span><br><span class="line">    ...</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) {</span><br><span class="line">    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">  }</span><br><span class="line">  applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">  Glide.glide = glide;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实在没有定义<code>GlideModule</code>情况下，这段代码只有一个核心点，通过<code>GlideBuilder</code>构建Glide,为Glide创建默认的属性，例如缓存，引擎等等。创建的对象在后续<code>into</code>函数中被大量使用到。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (sourceExecutor == <span class="keyword">null</span>) {</span><br><span class="line">    sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diskCacheExecutor == <span class="keyword">null</span>) {</span><br><span class="line">    diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (animationExecutor == <span class="keyword">null</span>) {</span><br><span class="line">    animationExecutor = GlideExecutor.newAnimationExecutor();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memorySizeCalculator == <span class="keyword">null</span>) {</span><br><span class="line">    memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connectivityMonitorFactory == <span class="keyword">null</span>) {</span><br><span class="line">    connectivityMonitorFactory = <span class="keyword">new</span> DefaultConnectivityMonitorFactory();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">      bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arrayPool == <span class="keyword">null</span>) {</span><br><span class="line">    arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) {</span><br><span class="line">    memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) {</span><br><span class="line">    diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (engine == <span class="keyword">null</span>) {</span><br><span class="line">    engine =</span><br><span class="line">        <span class="keyword">new</span> Engine(</span><br><span class="line">            memoryCache,</span><br><span class="line">            diskCacheFactory,</span><br><span class="line">            diskCacheExecutor,</span><br><span class="line">            sourceExecutor,</span><br><span class="line">            GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">            animationExecutor,</span><br><span class="line">            isActiveResourceRetentionAllowed);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (defaultRequestListeners == <span class="keyword">null</span>) {</span><br><span class="line">    defaultRequestListeners = Collections.emptyList();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  GlideExperiments experiments = glideExperimentsBuilder.build();</span><br><span class="line">  RequestManagerRetriever requestManagerRetriever =</span><br><span class="line">      <span class="keyword">new</span> RequestManagerRetriever(requestManagerFactory, experiments);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Glide(</span><br><span class="line">      context,</span><br><span class="line">      engine,</span><br><span class="line">      memoryCache,</span><br><span class="line">      bitmapPool,</span><br><span class="line">      arrayPool,</span><br><span class="line">      requestManagerRetriever,</span><br><span class="line">      connectivityMonitorFactory,</span><br><span class="line">      logLevel,</span><br><span class="line">      defaultRequestOptionsFactory,</span><br><span class="line">      defaultTransitionOptions,</span><br><span class="line">      defaultRequestListeners,</span><br><span class="line">      experiments);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="requestmanager的创建"><a class="markdownIt-Anchor" href="#requestmanager的创建"></a> <code>RequestManager</code>的创建</h3><p><code>RequestManager</code>的创建涉及到与<code>Application</code>或<code>Fragment</code>生命周期的绑定，<code>RequestManager</code>可以用来开始和停止、管理本次Glide请求。</p><p>再回到<code>getRetriever(activity).get(activity)</code>的<code>get</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) {</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    frameWaiter.registerSelf(activity);</span><br><span class="line">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>Util.isOnBackgroundThread()</code>判断是否后台线程，如果不是则通过<code>supportFragmentGet</code>创建<code>RequestManager</code>。否则通过<code>get(activity)</code>的重载函数<code>get(Context)</code>获取<code>RequestManager</code>。查看<code>get()</code>的其他重载函数，如果在后台线程或者参数为<code>ApplicationContext</code>上下文，都通过<code>getApplicationManager(context)</code>来生成<code>RequestManager</code>，而其他情况则是<code>supportFragmentGet</code>函数。</p><h3 id="supportfragmentget"><a class="markdownIt-Anchor" href="#supportfragmentget"></a> <code>supportFragmentGet</code></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isParentVisible)</span> </span>{</span><br><span class="line">  <span class="comment">//步骤1:获取SupportRequestManagerFragment</span></span><br><span class="line">  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">  <span class="comment">//步骤2：获取RequestManager</span></span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) {</span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    <span class="keyword">if</span> (isParentVisible) {</span><br><span class="line">      requestManager.onStart();</span><br><span class="line">    }</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤1</strong>：通过<code>getSupportRequestManagerFragment</code>函数创建<code>SupportRequestManagerFragment</code>对象。<code>SupportRequestManagerFragment</code>是<code>Fragment</code>的子类，该<code>Fragment</code>对象是没有视图，作为发起<code>Glide</code>请求的<code>Activity</code>或<code>Fragment</code>的子<code>Fragment</code>，将持有<code>RequestManager</code>实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> <span class="keyword">final</span> FragmentManager fm, <span class="meta">@Nullable</span> Fragment parentHint)</span> </span>{</span><br><span class="line">  <span class="comment">//tag查找</span></span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">//HashMap查找</span></span><br><span class="line">    current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">//新建</span></span><br><span class="line">      current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先通过<code>FRAGMENT_TAG</code>标签在<code>FragmentMananger</code>中查找是否有已添加的<code>Fragment</code>实例。没有的话，在<code>endingSupportRequestManagerFragments</code>查找,<code>endingSupportRequestManagerFragments</code>是<code>HashMap</code>类型的,以<code>FragmentMananger</code>为<code>key</code>，<code>SupportRequestManagerFragment</code>为<code>Value</code>。没有的话，则新建实例，并添加<code>pendingSupportRequestManagerFragments</code>中，并通过<code>FragmentMananger</code>提交。这个创建逻辑也保证了在一个<code>Activity</code>中所发起的所有Glide请求都只有一个空白<code>Fragment</code>。</p><p>在创建<code>SupportRequestManagerFragment</code>时候，会创建一个新的<code>ActivityFragmentLifecycle</code>，用于跟踪和监听<code>Fragment</code>的生命周期事件。</p><p>**步骤2：**在步骤1获取到了<code>Fragment</code>后，获取其持有的<code>RequestManager</code>,如果<code>Fragment</code>是新建获得，那肯定是没有，只能通过新建<code>RequestManager</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br></pre></td></tr></tbody></table></figure><p>这里的<code>factory</code>是<code>RequestManagerFactory</code>，在构建Glide单例的时候会创建，默认情况下是<code>DEFAULT_FACTORY</code>。在创建<code>RequestManager</code>时不仅监听<code>Fragment</code>生命周期的变化，还会监听网络连接变化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY =</span><br><span class="line">  <span class="keyword">new</span> RequestManagerFactory() {</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Context context)</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode, context);</span><br><span class="line">    }</span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure><p>所以，当<code>Fragment</code>生命周期发生变化或者网络发生变化时，<code>RequestManager</code>根据不同场景去管理本次<code>Glide</code>请求。</p><p>在<code>View</code>场景下的<code>Glide.with()</code>稍微麻烦点，需要根据<code>View.getContext()</code>得到<code>Context</code>的类型,去查找不同的<code>get()</code>函数重载。而<code>Fragment</code>场景下，与<code>Actvity</code>发起的Glide请求大同小异。</p><h3 id="getapplicationmanager"><a class="markdownIt-Anchor" href="#getapplicationmanager"></a> <code>getApplicationManager</code></h3><p>在后台线程或<code>ApplicationContext</code>场景下，通过<code>getApplicationManager(context)</code>创建<code>RequestManager</code>。通过下面代码可以看到，<code>RequestManager</code>直接与<code>Application</code>的生命周期绑定。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) {</span><br><span class="line">        Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide,</span><br><span class="line">                <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而<code>ApplicationLifecycle</code>基本什么都没做，因为Glide请求与Application绑定，意味随着<code>Applilcation</code>的消亡而消亡。</p><p>到这里，<code>Glide.with()</code>的分析就完毕了，主要创建<code>Glide</code>单例，和为<code>Glide</code>请求创建<code>RequestManager</code>。在后台线程或者<code>ApplicationContext</code>情况下创建的<code>RequestManager</code>是与<code>Application</code>的生命周期绑定的，而其他情况下，通过创建一个无视图的<code>Fragment</code>的，并将<code>RequestManager</code>与其生命周期绑定。</p><h2 id="配置load"><a class="markdownIt-Anchor" href="#配置load"></a> 配置：load</h2><p><code>load</code>函数也有很多重载函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;XXX&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> XXX xxx)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(xxx);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以看一下<code>asDrawable()</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，<code>asDrawable</code>函数主要是创建了<code>RequestBuilder</code>对象，<code>RequestBuilder</code>是<code>BaseRequestOptions</code>的子类，用于保存Glide通用资源类型的配置参数。<code>BaseRequestOptions</code>的另外一个子类<code>RequestOptions</code>,通常用来配置一次独立的Glide请求配置参数。注意这里的<code>as</code>的参数<code>Drawable.class</code>，表明的是本次请求的目标资源是<code>Drawable.class</code>,即后续分析会看到<code>transcodeClass</code>就是该<code>Drawable.class</code>。仅下载情况是<code>File.class</code>，Gif图情况下是<code>GifDrawable.class</code>。</p><p>继续看<code>RequestBuilder</code>的<code>load</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (isAutoCloneEnabled()) {</span><br><span class="line">    <span class="keyword">return</span> clone().loadGeneric(model);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> selfOrThrowIfLocked();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主要是将我们设置的资源:<code>Glide.with(context).load(xxx)</code>中的<code>xxx</code>设置给<code>RequestBuilder</code>的<code>model</code>属性，并将<code>isModelSet</code>设置<code>true</code>。后续分析中<code>modelClass</code>就是这里<code>xxx</code>的类型。</p><p>假如这里<code>load(drawable)</code>或者<code>load(bitmap)</code>，会有多一个步骤：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Drawable drawable)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(drawable).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是多了<code>apply(options)</code>,跟我们自定义Glide请求配置是一致的。这里也会将<code>RequestOptions</code>缓存起来。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">apply</span><span class="params">(<span class="meta">@NonNull</span> BaseRequestOptions&lt;?&gt; o)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (isAutoCloneEnabled) {</span><br><span class="line">    <span class="keyword">return</span> clone().apply(o);</span><br><span class="line">  }</span><br><span class="line">  BaseRequestOptions&lt;?&gt; other = o;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, SIZE_MULTIPLIER)) {</span><br><span class="line">    sizeMultiplier = other.sizeMultiplier;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) {</span><br><span class="line">    useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, USE_ANIMATION_POOL)) {</span><br><span class="line">    useAnimationPool = other.useAnimationPool;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, DISK_CACHE_STRATEGY)) {</span><br><span class="line">    diskCacheStrategy = other.diskCacheStrategy;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PRIORITY)) {</span><br><span class="line">    priority = other.priority;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ERROR_PLACEHOLDER)) {</span><br><span class="line">    errorPlaceholder = other.errorPlaceholder;</span><br><span class="line">    errorId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~ERROR_ID;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ERROR_ID)) {</span><br><span class="line">    errorId = other.errorId;</span><br><span class="line">    errorPlaceholder = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~ERROR_PLACEHOLDER;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PLACEHOLDER)) {</span><br><span class="line">    placeholderDrawable = other.placeholderDrawable;</span><br><span class="line">    placeholderId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~PLACEHOLDER_ID;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PLACEHOLDER_ID)) {</span><br><span class="line">    placeholderId = other.placeholderId;</span><br><span class="line">    placeholderDrawable = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~PLACEHOLDER;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, IS_CACHEABLE)) {</span><br><span class="line">    isCacheable = other.isCacheable;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, OVERRIDE)) {</span><br><span class="line">    overrideWidth = other.overrideWidth;</span><br><span class="line">    overrideHeight = other.overrideHeight;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, SIGNATURE)) {</span><br><span class="line">    signature = other.signature;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, RESOURCE_CLASS)) {</span><br><span class="line">    resourceClass = other.resourceClass;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, FALLBACK)) {</span><br><span class="line">    fallbackDrawable = other.fallbackDrawable;</span><br><span class="line">    fallbackId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~FALLBACK_ID;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, FALLBACK_ID)) {</span><br><span class="line">    fallbackId = other.fallbackId;</span><br><span class="line">    fallbackDrawable = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~FALLBACK;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, THEME)) {</span><br><span class="line">    theme = other.theme;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION_ALLOWED)) {</span><br><span class="line">    isTransformationAllowed = other.isTransformationAllowed;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION_REQUIRED)) {</span><br><span class="line">    isTransformationRequired = other.isTransformationRequired;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION)) {</span><br><span class="line">    transformations.putAll(other.transformations);</span><br><span class="line">    isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {</span><br><span class="line">    onlyRetrieveFromCache = other.onlyRetrieveFromCache;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Applying options with dontTransform() is expected to clear our transformations.</span></span><br><span class="line">  <span class="keyword">if</span> (!isTransformationAllowed) {</span><br><span class="line">    transformations.clear();</span><br><span class="line">    fields &amp;= ~TRANSFORMATION;</span><br><span class="line">    isTransformationRequired = <span class="keyword">false</span>;</span><br><span class="line">    fields &amp;= ~TRANSFORMATION_REQUIRED;</span><br><span class="line">    isScaleOnlyOrNoTransform = <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  fields |= other.fields;</span><br><span class="line">  options.putAll(other.options);<span class="comment">//缓存RequestOptions</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> selfOrThrowIfLocked();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说<code>load</code>函数的主要工作是配置Glide请求的一些参数。</p><h2 id="核心into"><a class="markdownIt-Anchor" href="#核心into"></a> 核心：into</h2><p><code>into</code>函数也有很多重载函数，但我们最常用的就是<code>into(ImageView)</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) {</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从这里看到Glide只处理<code>View ScaleType</code>的<code>CENTER_CROP</code>、<code>CENTER_INSIDE、</code> <code>FIT_XY</code>，而<code>FIT_CENTER</code>、<code>FIT_START</code>、<code>FIT_END</code>都统一通过<code>optionalFitCenter</code>处理，而<code>CENTER</code>和<code>MATRIX</code>则直接忽略。然后调用<code>into</code>另外一个重载函数。先通过<code>glideContext.buildImageViewTarget</code>将<code>ImageView</code>封装成<code>ViewTarget</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> ImageView imageView, <span class="meta">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>{</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">  <span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> ImageView view, <span class="meta">@NonNull</span> Class&lt;Z&gt; clazz)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Bitmap.class.equals(clazz)) {</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) {</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Unhandled class: "</span> + clazz + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>ImageViewTargetFactory</code>工厂的<code>buildTarget</code>函数可以发现<code>ViewTarget</code>有两种类型:<code>BitmapImageViewTraget</code>和<code>DrawableImageViewTarget</code>。两者都是<code>ImageViewTarget</code>的子类，前者用于展示<code>Bitmap</code>，后者用于展示<code>Drawable</code>。另外一个子类<code>ThumbnailImageViewTarget</code>，用于在固定尺寸的<code>ImageView</code>展示多张图片，避免额外调用<code>requestLayout</code>，常用场景就是列表的缩略图设置。</p><p><code>into</code>函数的第三个参数<code>Executors.mainThreadExecutor()</code>,在主线程执行的线程池，也就是调用线程池的<code>execute</code>函数时，将<code>runable</code>对象通过<code>handler post</code>到主线程的队列,这样就在主线程执行了该任务。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">mainThreadExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> MAIN_THREAD_EXECUTOR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">mainThreadExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> MAIN_THREAD_EXECUTOR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor MAIN_THREAD_EXECUTOR =</span><br><span class="line">    <span class="keyword">new</span> Executor() {</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>{</span><br><span class="line">        Util.postOnUiThread(command);</span><br><span class="line">      }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOnUiThread</span><span class="params">(Runnable runnable)</span> </span>{</span><br><span class="line">  getUiThreadHandler().post(runnable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getUiThreadHandler</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (mainThreadHandler == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">synchronized</span> (Util.class) {</span><br><span class="line">      <span class="keyword">if</span> (mainThreadHandler == <span class="keyword">null</span>) {</span><br><span class="line">        mainThreadHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mainThreadHandler;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>继续看看<code>into</code>的重载函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//步骤1</span></span><br><span class="line">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"><span class="comment">//查看view的tag是否设置了Request</span></span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {</span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) {</span><br><span class="line">      previous.begin();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  <span class="comment">//步骤2</span></span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤1：</strong> 通过<code>buildRequest</code>创建了<code>Request</code>对象，<code>Request</code>代表了一次为目标<code>Target</code>加载图片资源<code>resource</code>的<code>Glide</code>请求。</p><h3 id="singlerequest的创建"><a class="markdownIt-Anchor" href="#singlerequest的创建"></a> SingleRequest的创建</h3><p>通过<code>buildRequest</code>函数会创建一个<code>Request</code>对象，该对象是<code>Request</code>的子类实例，可能<code>ThumbnailRequestCoordinator</code>或<code>ErrorRequestCoordinator</code>也有可能是<code>SingleRequest</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> buildRequestRecursive(</span><br><span class="line">      <span class="comment">/*requestLock=*/</span> <span class="keyword">new</span> Object(),</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      <span class="comment">/*parentCoordinator=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      transitionOptions,</span><br><span class="line">      requestOptions.getPriority(),</span><br><span class="line">      requestOptions.getOverrideWidth(),</span><br><span class="line">      requestOptions.getOverrideHeight(),</span><br><span class="line">      requestOptions,</span><br><span class="line">      callbackExecutor);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用了<code>buildRequestRecursive</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object requestLock,</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">  ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) {</span><br><span class="line">    errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(requestLock, parentCoordinator);</span><br><span class="line">    parentCoordinator = errorRequestCoordinator;</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//步骤A</span></span><br><span class="line">  Request mainRequest =</span><br><span class="line">      buildThumbnailRequestRecursive(</span><br><span class="line">          requestLock,</span><br><span class="line">          targ  et,</span><br><span class="line">          targetListener,</span><br><span class="line">          parentCoordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          priority,</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight,</span><br><span class="line">          requestOptions,</span><br><span class="line">          callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> mainRequest;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> errorOverrideWidth = errorBuilder.getOverrideWidth();</span><br><span class="line">  <span class="keyword">int</span> errorOverrideHeight = errorBuilder.getOverrideHeight();</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !errorBuilder.isValidOverride()) {</span><br><span class="line">    errorOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">    errorOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Request errorRequest =</span><br><span class="line">      errorBuilder.buildRequestRecursive(</span><br><span class="line">          requestLock,</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          errorRequestCoordinator,</span><br><span class="line">          errorBuilder.transitionOptions,</span><br><span class="line">          errorBuilder.getPriority(),</span><br><span class="line">          errorOverrideWidth,</span><br><span class="line">          errorOverrideHeight,</span><br><span class="line">          errorBuilder,</span><br><span class="line">          callbackExecutor);</span><br><span class="line">  errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">  <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤A:</strong> <code>buildThumbnailRequestRecursive</code>创建了<code>Request</code>,这里返回的<code>Request</code>有两种可能，一种是设置了加载缩略图和主图的，返回的<code>ThumbnailRequestCoordinator</code>,会协调好缩略图<code>SingleRequest</code>和主图<code>SingleRequest</code>的同时加载。另外一种是<code>SingleRequest</code>,单单加载主图，两者都是<code>Request</code>的子类。</p><p>如果有设置在发生错误时的请求也会在这里配置该请求，通过后面的分析，也就是每个<code>RequestBuilder</code>（不仅是主图，也可以是缩略图，错误提示图等）都会创建一个<code>SingleRequest</code>。</p><p>接着看<code>buildThumbnailRequestRecursive</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildThumbnailRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object requestLock,</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="comment">//由于没有设置缩略图，直接走else分支</span></span><br><span class="line">  <span class="keyword">if</span> (thumbnailBuilder != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// Recursive case: contains a potentially recursive thumbnail request builder.</span></span><br><span class="line">    <span class="keyword">if</span> (isThumbnailBuilt) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"You cannot use a request as both the main request and a "</span></span><br><span class="line">              + <span class="string">"thumbnail, consider using clone() on the request(s) passed to thumbnail()"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; thumbTransitionOptions =</span><br><span class="line">        thumbnailBuilder.transitionOptions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) {</span><br><span class="line">      thumbTransitionOptions = transitionOptions;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Priority thumbPriority =</span><br><span class="line">        thumbnailBuilder.isPrioritySet()</span><br><span class="line">            ? thumbnailBuilder.getPriority()</span><br><span class="line">            : getThumbnailPriority(priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();</span><br><span class="line">    <span class="keyword">int</span> thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)</span><br><span class="line">        &amp;&amp; !thumbnailBuilder.isValidOverride()) {</span><br><span class="line">      thumbOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">      thumbOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ThumbnailRequestCoordinator coordinator =</span><br><span class="line">        <span class="keyword">new</span> ThumbnailRequestCoordinator(requestLock, parentCoordinator);</span><br><span class="line">    Request fullRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            requestLock,</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            requestOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            priority,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight,</span><br><span class="line">            callbackExecutor);</span><br><span class="line">    isThumbnailBuilt = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//调用了thumbnailBuilder.buildRequestRecursive，此时是没有设置缩略图的，直接走else分支，返回了SingleRequest</span></span><br><span class="line">    Request thumbRequest =</span><br><span class="line">        thumbnailBuilder.buildRequestRecursive(</span><br><span class="line">            requestLock,</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            coordinator,</span><br><span class="line">            thumbTransitionOptions,</span><br><span class="line">            thumbPriority,</span><br><span class="line">            thumbOverrideWidth,</span><br><span class="line">            thumbOverrideHeight,</span><br><span class="line">            thumbnailBuilder,</span><br><span class="line">            callbackExecutor);</span><br><span class="line">    isThumbnailBuilt = <span class="keyword">false</span>;</span><br><span class="line">    coordinator.setRequests(fullRequest, thumbRequest);</span><br><span class="line">    <span class="keyword">return</span> coordinator;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (thumbSizeMultiplier != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">//缩略因子</span></span><br><span class="line">    ThumbnailRequestCoordinator coordinator =</span><br><span class="line">        <span class="keyword">new</span> ThumbnailRequestCoordinator(requestLock, parentCoordinator);</span><br><span class="line">    Request fullRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            requestLock,</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            requestOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            priority,</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight,</span><br><span class="line">            callbackExecutor);</span><br><span class="line">    BaseRequestOptions&lt;?&gt; thumbnailOptions =</span><br><span class="line">        requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);</span><br><span class="line"></span><br><span class="line">    Request thumbnailRequest =</span><br><span class="line">        obtainRequest(</span><br><span class="line">            requestLock,</span><br><span class="line">            target,</span><br><span class="line">            targetListener,</span><br><span class="line">            thumbnailOptions,</span><br><span class="line">            coordinator,</span><br><span class="line">            transitionOptions,</span><br><span class="line">            getThumbnailPriority(priority),</span><br><span class="line">            overrideWidth,</span><br><span class="line">            overrideHeight,</span><br><span class="line">            callbackExecutor);</span><br><span class="line"></span><br><span class="line">    coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class="line">    <span class="keyword">return</span> coordinator;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// Base case: no thumbnail.</span></span><br><span class="line">    <span class="keyword">return</span> obtainRequest(</span><br><span class="line">        requestLock,</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        requestOptions,</span><br><span class="line">        parentCoordinator,</span><br><span class="line">        transitionOptions,</span><br><span class="line">        priority,</span><br><span class="line">        overrideWidth,</span><br><span class="line">        overrideHeight,</span><br><span class="line">        callbackExecutor);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于没有设置缩略图，直接走<code>else</code>分支，通过<code>obtainRequest</code>获得<code>Request</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object requestLock,</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">      context,</span><br><span class="line">      glideContext,</span><br><span class="line">      requestLock,</span><br><span class="line">      model,</span><br><span class="line">      transcodeClass,</span><br><span class="line">      requestOptions,</span><br><span class="line">      overrideWidth,</span><br><span class="line">      overrideHeight,</span><br><span class="line">      priority,</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      requestListeners,</span><br><span class="line">      requestCoordinator,</span><br><span class="line">      glideContext.getEngine(),</span><br><span class="line">      transitionOptions.getTransitionFactory(),</span><br><span class="line">      callbackExecutor);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>SingleRequest.obtain</code>函数返回了<code>Request</code>对象。<code>obtain</code>函数直接创建了<code>Request</code>的子类<code>SingleRequest</code>对象。</p><p>这里<code>buildRequest</code>函数小结一下:</p><ul><li>如果设置了缩略图，返回<code>ThumbnailRequestCoordinator</code>对象，包含了主图和缩图两个独立的<code>SingleRequest</code>。</li><li>如果设置了错误占位图，返回的是<code>ErrorRequestCoordinator</code>,包含了上一步返回的<code>Request</code>对象和占位图的<code>SingleRequest</code>对象，</li><li>如果上两步都没有设置，返回主图的<code>SingleRequest</code>。</li></ul><p>继续分析<code>into</code>函数的<strong>步骤2：</strong></p><h3 id="requestmanagertrack"><a class="markdownIt-Anchor" href="#requestmanagertrack"></a> <code>requestManager.track</code></h3><p><code>track</code>函数分别用了<code>TragetTrack</code>和<code>RequestTrack</code>跟踪本次请求的<code>traget</code>和<code>request</code>对象。<code>RequestTrack</code>主要用于跟踪，取消和重启正在运行中的，已完成或者失败的请求。<code>TragetTrack</code>则持有当前活跃的<code>RequestManager</code>以及转发绑定的生命周期事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> </span>{</span><br><span class="line">  <span class="comment">//将Traget存放到set中</span></span><br><span class="line">  targetTracker.track(target);</span><br><span class="line"> <span class="comment">//开始请求 </span></span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看看<code>RequestTrack</code>的<code>runRequest</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> </span>{</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) {<span class="comment">//首次创建肯定是false</span></span><br><span class="line">    request.begin();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {</span><br><span class="line">      Log.v(TAG, <span class="string">"Paused, delaying request"</span>);</span><br><span class="line">    }</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看看<code>request.begin()</code>函数。我们这里直接定位到<code>SingleRequest</code>的<code>begin</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) {</span><br><span class="line"> ......</span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) {</span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) {</span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定位到<code>target.getSize(this)</code>获取<code>Target</code>尺寸大小，这里的<code>this</code>是<code>SizeReadyCallback</code>。也就是在获取到目标尺寸之后，通过<code>SizeReadyCallback</code>对象回调。这里的<code>Target</code>对象直接定位到<code>ViewTarget</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span> </span>{</span><br><span class="line">  sizeDeterminer.getSize(cb);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>getSize</code>函数的注释，就知道了Glide如何去获取尺寸的。</p><ul><li>直接获取View的宽高，如果都大于零或者等于原始尺寸，说明已经能获取到了。</li><li>直接获取View的LayotuParams，如果都大于零或者等于原始尺寸，说明已经能获取到了。</li><li>添加<code>addOnPreDrawListener</code>监听。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">(<span class="meta">@NonNull</span> SizeReadyCallback cb)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> currentWidth = getTargetWidth();</span><br><span class="line">  <span class="keyword">int</span> currentHeight = getTargetHeight();</span><br><span class="line">  <span class="keyword">if</span> (isViewStateAndSizeValid(currentWidth, currentHeight)) {</span><br><span class="line">    cb.onSizeReady(currentWidth, currentHeight);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We want to notify callbacks in the order they were added and we only expect one or two</span></span><br><span class="line">  <span class="comment">// callbacks to be added a time, so a List is a reasonable choice.</span></span><br><span class="line">  <span class="keyword">if</span> (!cbs.contains(cb)) {</span><br><span class="line">    cbs.add(cb);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (layoutListener == <span class="keyword">null</span>) {</span><br><span class="line">    ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class="line">    layoutListener = <span class="keyword">new</span> SizeDeterminerLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">    observer.addOnPreDrawListener(layoutListener);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以通过三个步骤，最终会获得ViewTarget的宽高，并通过<code>SizeReadyCallback</code>对象的<code>onSizeReady</code>函数回调。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>{</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            requestOptions.getSignature(),</span><br><span class="line">            <span class="keyword">this</span>.width,</span><br><span class="line">            <span class="keyword">this</span>.height,</span><br><span class="line">            requestOptions.getResourceClass(),</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            requestOptions.getDiskCacheStrategy(),</span><br><span class="line">            requestOptions.getTransformations(),</span><br><span class="line">            requestOptions.isTransformationRequired(),</span><br><span class="line">            requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">            requestOptions.getOptions(),</span><br><span class="line">            requestOptions.isMemoryCacheable(),</span><br><span class="line">            requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">            requestOptions.getUseAnimationPool(),</span><br><span class="line">            requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) {</span><br><span class="line">      loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以<code>onSizeReady</code>最重要的点就是调用了<code>engine.load</code>开始本次<code>Glide</code>请求。</p><h3 id="engineload"><a class="markdownIt-Anchor" href="#engineload"></a> <code>engine.load</code></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">    Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">    Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>{</span><br><span class="line">  <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  EngineKey key =</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="comment">//步骤1</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤1</strong>：调用<code>loadFromMemory</code>函数从内存获取缓存，如果没有拿到缓存资源，则通过<strong>步骤2：</strong><code>waitForExistingOrStartNewJob</code>函数从磁盘缓存或者网络获取。下节再分享这里的Glide缓存。最后拿到资源，则通过<code>cb.onResourceReady</code>函数回调，回到<code>SingleRequest</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Resource&lt;?&gt; resource, DataSource dataSource, <span class="keyword">boolean</span> isLoadedFromAlternateCacheKey)</span> </span>{</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  Resource&lt;?&gt; toRelease = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) {</span><br><span class="line">  ......</span><br><span class="line">      onResourceReady(</span><br><span class="line">          (Resource&lt;R&gt;) resource, (R) received, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (toRelease != <span class="keyword">null</span>) {</span><br><span class="line">      engine.release(toRelease);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>onResourceReady</code>这里对一些合法性的检查，然后调用<code>onResourceReady</code>的重载函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Resource&lt;R&gt; resource, R result, DataSource dataSource, <span class="keyword">boolean</span> isAlternateCacheKey)</span> </span>{</span><br><span class="line">...</span><br><span class="line">    target.onResourceReady(result, animation);</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重载的<code>onResourceReady</code>函数这里调用<code>target</code>的<code>onResourceReady</code>函数。这里定位到<code>ImageViewTarget</code>类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) {</span><br><span class="line">    setResourceInternal(resource);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实无论哪个分支，<code>maybeUpdateAnimatable</code>函数都会被执行，即判断当前资源是否可执行的动画。如果是的话，则直接开始执行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeUpdateAnimatable</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Animatable) {</span><br><span class="line">    animatable = (Animatable) resource;</span><br><span class="line">    animatable.start();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    animatable = <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而<code>setResourceInternal</code>函数,先调用了<code>setResouce</code>函数，猜测该函数设置资源给<code>Target</code>。再调用<code>maybeUpdateAnimatable</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>{</span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>setResource</code>在<code>ImageViewTarget</code>是一个抽象方法，看一下它的子类<code>BitmapImageViewTarget</code>的实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(Bitmap resource)</span> </span>{</span><br><span class="line">  view.setImageBitmap(resource);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>setResource</code>直接将<code>Bitmap</code>设置给了<code>ImageView</code>,那么图片也即将展示出来。</p><p>因为忽略了<code>engine.load</code>加载资源分析，所以<code>into</code>函数看起来很简单，但Glide的所有核心也正在这一部分，将通过后续文章分析该部分。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>简简单单分析了Glide的流程三部曲，每一步是责任分明，创建单例与绑定生命周期，配置参数，开始请求。但这才刚刚开始，后续将更加枯燥无趣，黯然无色。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;Glide流程三步曲&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;load&lt;/code&gt;、&lt;code&gt;into&lt;/code&gt;三个函数，完成一次</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Glide" scheme="http://example.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 源码分析</title>
    <link href="http://example.com/2021/03/18/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/03/18/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-03-17T16:00:00.000Z</published>
    <updated>2021-03-18T06:54:27.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>通过分析Retrofit源码，了解这款简洁的网络库如何提高我们的工作效率。通过动态代理技术，创建我们接口对象，以提供我们调用接口函数。通过解析接口定义的函数，装配成<code>OkHttp</code>网络请求所需的数据并发起网络请求。我们可以根据自己的需求，自定义请求适配器和响应转换器。</p><h2 id="流程分析"><a class="markdownIt-Anchor" href="#流程分析"></a> 流程分析</h2><h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3><p>我们定义了<code>service</code>接口，并通过<code>retrofit</code>对象的<code>create</code>函数创建了<code>service</code>类型的对象。通过该对象，我们可以调用在<code>service</code>接口定义的函数，从而发起定义的网络请求。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val service=retrofit.create(service::class.java)</span><br></pre></td></tr></tbody></table></figure><p><code>Retrofit</code>通过动态代理技术生成我们定义<code>service</code>接口代理对象，因此调用代理对象的函数时都会转发到<code>InvocationHandler</code>对象的<code>invoke</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>{</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] {service},</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">              <span class="comment">//判断是否Obect的默认方法</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) {</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              }</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              <span class="comment">//判断是否特定平台的方法，例如Android</span></span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            }</span><br><span class="line">          });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="loadservicemethod"><a class="markdownIt-Anchor" href="#loadservicemethod"></a> <code>loadServiceMethod</code></h3><p>在<code>invoke</code>函数，我们只关心<code>loadServiceMethod(method).invoke(args)</code>函数。<code>loadServiceMethod(method)</code>函数会返回一个<code>ServiceMethod</code>对象，<code>ServiceMethod</code>是一个抽象类，唯一直接实现类是<code>HttpServiceMethod</code>。也就是说这里调用了<code>HttpServiceMethod.invoke(args)</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) {</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>loadServiceMethod</code>函数主要先通过缓存<code>serviceMethodCache</code>获取<code>ServiceMethod</code>对象，如果缓存中没有获取到<code>ServiceMethod</code>对象，则通过<code>ServiceMethod.parseAnnotations</code>解析获取<code>ServiceMethod</code>对象，并将其放在缓存中。<code>serviceMethodCache</code>是一个<code>ConcurrentHashMap</code>，以<code>Method</code>为<code>Key</code>,<code>ServiceMethod</code>为<code>value</code>。<code>ServiceMethod.parseAnnotations(this, method)</code>主要是解析<code>Method</code>对象（我们定义的方法）的注解，参数及注解以及返回类型,然后通过<code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>生成<code>ServerMethod</code>对象。</p><h3 id="servicemethodparseannotations"><a class="markdownIt-Anchor" href="#servicemethodparseannotations"></a> <code>ServiceMethod.parseAnnotations</code></h3><p>该函数分别调用了<code>RequestFactory</code>类和<code>HttpServiceMethod</code>的<code>parseAnnotations</code>函数。<code>RequestFactory</code>类主要封装本次网络请求的大多数信息，例如<code>method</code>，<code>headers</code>,<code>httpMethod</code>等等。<code>HttpServiceMethod</code>是<code>ServerMethod</code>的子类，主要用来创建请求适配器和数据转换器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>{</span><br><span class="line">  <span class="comment">//解析方法的注解和参数的注解及值</span></span><br><span class="line">  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"><span class="comment">//解析方法的注解和参数的注解及返回值</span></span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) {</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        method,</span><br><span class="line">        <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">        returnType);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) {</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="requestfactoryparseannotations"><a class="markdownIt-Anchor" href="#requestfactoryparseannotations"></a> <code>RequestFactory.parseAnnotations</code></h3><p><code>RequestFactory.parseAnnotations(retrofit, method)</code>通过构建者模式创建<code>RequestFactory</code>对象。构建的过程主要是解析传递进来的参数<code>method</code>对象上相关信息，并赋值到<code>RequestFactory</code>对象相关属性上。<code>Method</code>对象代表着反射上的一个函数，包含这个该函数的相关信息，例如注解，参数，返回类型等。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Builder(Retrofit retrofit, Method method) {</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">//1、解析方法上注解</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) {</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  }</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) {</span><br><span class="line">      <span class="comment">//解析函数参数，包括其注解和值</span></span><br><span class="line">      parameterHandlers[p] =</span><br><span class="line">        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">  }</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>build</code>函数主要解析方法上的注解，参数注解。 <code>parseMethodAnnotation(annotation)</code>用来解析方法的注解，根据<code>anotation</code>的类型，例如<code>GET</code>、<code>POST</code>等等，然后根据这些方法类型在HTTP报文对应的特性，设置相关属性，例如<code>GET</code>类型的请求没有请求体<code>hasBody=false</code>,POST类型的<code>hasBody=true</code>。</p><p>通过<code>parseParameter</code>解析函数参数注解和获取对应的值。参数注解的解析和函数注解的解析类似，主要检查我们使用方式是否正确和设置相关属性。并且也会判断当前函数是否<code>Kotlin</code>协程中的挂起函数（后文分析）。</p><h3 id="httpservicemethodparseannotations"><a class="markdownIt-Anchor" href="#httpservicemethodparseannotations"></a> <code>HttpServiceMethod.parseAnnotations</code></h3><p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>又是干了什么呢？将上面解析生成的<code>RequestFactory</code>，生成请求适配器<code>CallAdapter</code>和响应转换器<code>Converter</code>,然后将三者封装到<code>HttpServiceMethod</code>的子类并返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>{</span><br><span class="line">   <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">   <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   Annotation[] annotations = method.getAnnotations();</span><br><span class="line">   Type adapterType;</span><br><span class="line">   <span class="keyword">if</span> (isKotlinSuspendFunction) {<span class="comment">//是否支持协程</span></span><br><span class="line">     Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">     Type responseType =</span><br><span class="line">         Utils.getParameterLowerBound(</span><br><span class="line">             <span class="number">0</span>, (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">     <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">       <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">       responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">       continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       <span class="comment">// TODO figure out if type is nullable or not</span></span><br><span class="line">       <span class="comment">// Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)</span></span><br><span class="line">       <span class="comment">// Find the entry for method</span></span><br><span class="line">       <span class="comment">// Determine if return type is nullable or not</span></span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">     annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     adapterType = method.getGenericReturnType(); <span class="comment">//获取方法的返回类型</span></span><br><span class="line">   }</span><br><span class="line"><span class="comment">//遍历Retrofit的CallAdapter列表，寻找是否有符合处理该adapterType的CallAdapter</span></span><br><span class="line">   CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">       createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">   Type responseType = callAdapter.responseType();</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line">       </span><br><span class="line"><span class="comment">//遍历Retrofit的转换器列表，寻找合适的转换器</span></span><br><span class="line">   Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">       createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">   okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">   <span class="keyword">if</span> (!isKotlinSuspendFunction) {</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<span class="comment">//非协程情况下，HtttpServerMethod的子类</span></span><br><span class="line">   } <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) {</span><br><span class="line">     <span class="comment">//使用了协程，且返回类型Response</span></span><br><span class="line">     <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">         <span class="keyword">new</span> SuspendForResponse&lt;&gt;(</span><br><span class="line">             requestFactory,</span><br><span class="line">             callFactory,</span><br><span class="line">             responseConverter,</span><br><span class="line">             (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     <span class="comment">//使用了协程，且返回类型ResponseBody</span></span><br><span class="line">     <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">         <span class="keyword">new</span> SuspendForBody&lt;&gt;(</span><br><span class="line">             requestFactory,</span><br><span class="line">             callFactory,</span><br><span class="line">             responseConverter,</span><br><span class="line">             (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">             continuationBodyNullable);</span><br><span class="line">   }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>在创建<code>CallAdatper</code>和<code>Converter</code>后,根据是否协程，返回不同的<code>HttpServiceMethod</code>子类。</p><h3 id="createcalladapter"><a class="markdownIt-Anchor" href="#createcalladapter"></a> <code>createCallAdapter</code></h3><p>其中<code>createCallAdapter(retrofit, method, adapterType, annotations);</code>创建<code>CallAdapted</code>对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>{</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  } <span class="keyword">catch</span> (RuntimeException e) { <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用<code>retrofit.callAdapter(returnType, annotations)</code>，根据返回类型<code>retrunType</code>选择合适的请求适配器。需要注意到的是，这里是从头开始遍历，如果前面适配器符合条件，意味着会被优先选用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {</span><br><span class="line">   <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(</span><br><span class="line">     <span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {</span><br><span class="line">......</span><br><span class="line">   <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) {</span><br><span class="line">     CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) {</span><br><span class="line">       <span class="keyword">return</span> adapter;</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">......</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>nextCallAdapter</code>函数主要通过循环遍历在构建<code>Retrofit</code>是保存在<code>callAdapterFactories</code>列表的<code>CallAdapter</code>,通过其<code>get</code>函数查看是否匹配。如果<code>Android SDK_INT&gt;=24</code>返回的是<code>CompletableFutureCallAdapterFactory</code>,否则返回的是<code>DefaultCallAdapterFactory</code>。</p><p>看看<code>CompletableFutureCallAdapterFactory</code>对象的<code>get</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">     Type returnType, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">   <span class="keyword">if</span> (getRawType(returnType) != CompletableFuture.class) {</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) {</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">"CompletableFuture return type must be parameterized"</span></span><br><span class="line">             + <span class="string">" as CompletableFuture&lt;Foo&gt; or CompletableFuture&lt;? extends Foo&gt;"</span>);</span><br><span class="line">   }</span><br><span class="line">   Type innerType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (getRawType(innerType) != Response.class) {</span><br><span class="line">     <span class="comment">// Generic type is not Response&lt;T&gt;. Use it for body-only adapter.</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> BodyCallAdapter&lt;&gt;(innerType);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Generic type is Response&lt;T&gt;. Extract T and create the Response version of the adapter.</span></span><br><span class="line">   <span class="keyword">if</span> (!(innerType <span class="keyword">instanceof</span> ParameterizedType)) {</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">         <span class="string">"Response must be parameterized"</span> + <span class="string">" as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"</span>);</span><br><span class="line">   }</span><br><span class="line">   Type responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) innerType);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ResponseCallAdapter&lt;&gt;(responseType);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><code>CompletableFutureCallAdapterFactory</code>的<code>get</code>函数根据函数返回类型是否与自己要处理的返回类型一致，不一致则返回null，表示不处理，例如这里是<code>CompletableFuture</code>。然后进一步检查返回值的合法性，例如是不是泛型对象。最终根据泛型对象最外层类型返回<code>CallAdapter</code>的子类<code>BodyCallAdapter</code>或<code>ResponseCallAdapter</code>。两者的主要区别是其<code>adapt</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BodyCallAdapter   </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;R&gt; <span class="title">adapt</span><span class="params">(<span class="keyword">final</span> Call&lt;R&gt; call)</span> </span>{</span><br><span class="line">  CompletableFuture&lt;R&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> BodyCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//ResponseCallAdapter</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Response&lt;R&gt;&gt; adapt(<span class="keyword">final</span> Call&lt;R&gt; call) {</span><br><span class="line">  CompletableFuture&lt;Response&lt;R&gt;&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> ResponseCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="loadservicemethodmethodinvokeargs"><a class="markdownIt-Anchor" href="#loadservicemethodmethodinvokeargs"></a> <code>loadServiceMethod(method).invoke(args)</code></h3><p>回到<code>loadServiceMethod(method).invoke(args)</code>，也就是说，这里实际调用了<code>CallAdapter</code>对象的<code>invoke</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>{</span><br><span class="line">Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line"><span class="keyword">return</span> adapt(call, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>invoke</code>函数主要是构建<code>OkHttpCall</code>并调用<code>adapt</code>函数。这里分析<code>ResponseCallAdapter</code>的<code>adapt</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Response&lt;R&gt;&gt; adapt(<span class="keyword">final</span> Call&lt;R&gt; call) {</span><br><span class="line">  CompletableFuture&lt;Response&lt;R&gt;&gt; future = <span class="keyword">new</span> CallCancelCompletableFuture&lt;&gt;(call);</span><br><span class="line">  call.enqueue(<span class="keyword">new</span> ResponseCallback(future));</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="网络请求"><a class="markdownIt-Anchor" href="#网络请求"></a> 网络请求</h3><p><code>adapt</code>函数调用了<code>OkHttpCall</code>的<code>enqueue</code>函数。是不是跟<code>OKHttp</code>的异步请求很相似。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>{</span><br><span class="line">  Objects.requireNonNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        throwIfFatal(t);</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failure != <span class="keyword">null</span>) {</span><br><span class="line">    callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) {</span><br><span class="line">    call.cancel();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  call.enqueue(</span><br><span class="line">      <span class="keyword">new</span> okhttp3.Callback() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>{</span><br><span class="line">          Response&lt;T&gt; response;</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            response = parseResponse(rawResponse);<span class="comment">//解析 原始数据，调用转化适配器</span></span><br><span class="line">          } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            throwIfFatal(e);</span><br><span class="line">            callFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          }</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">          } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            throwIfFatal(t);</span><br><span class="line">            t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>{</span><br><span class="line">          callFailure(e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>{</span><br><span class="line">          <span class="keyword">try</span> {</span><br><span class="line">            callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">          } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            throwIfFatal(t);</span><br><span class="line">            t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>enqueue</code>函数的简单分析，就是创建<code>OkHttp</code>的<code>Call</code>对象,并调用<code>enqueue</code>函数。然后发起网络请求，请求成功之后调用<code>parseResponse</code>解析响应数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">   ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">   rawResponse =</span><br><span class="line">       rawResponse</span><br><span class="line">           .newBuilder()</span><br><span class="line">           .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">           .build();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">   <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">       <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">       rawBody.close();</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) {</span><br><span class="line">     rawBody.close();</span><br><span class="line">     <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     T body = responseConverter.convert(catchingBody); <span class="comment">//转换响应数据</span></span><br><span class="line">     <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">   } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">     <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">     <span class="comment">// a runtime exception.</span></span><br><span class="line">     catchingBody.throwIfCaught();</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="createresponseconverter"><a class="markdownIt-Anchor" href="#createresponseconverter"></a> <code>createResponseConverter</code></h3><p>重点地方就是在函数最后的地方调用了<code>T body = responseConverter.convert(catchingBody);</code>将原始数据转化成我们需要的数据类型。在<code>HttpServiceMethod</code>的<code>parseAnnotations</code>函数中<code>createResponseConverter</code>创建响应数据转换器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     Retrofit retrofit, Method method, Type responseType)</span> </span>{</span><br><span class="line">   Annotation[] annotations = method.getAnnotations();</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">   } <span class="keyword">catch</span> (RuntimeException e) { <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">     <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>{</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) {</span><br><span class="line">     Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">         converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (converter != <span class="keyword">null</span>) {</span><br><span class="line">       <span class="comment">//noinspection unchecked</span></span><br><span class="line">       <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">......</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>响应转换器与请求适配器的创建过程很相似。在创建Retrofit对象时，会将相关转化器保存到<code>converterFactories</code>列表，通过转化器的<code>responseBodyConverter</code>函数判断是否处理该响应数据。这里看下<code>OptionalConverterFactory</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Converter.Factory INSTANCE = <span class="keyword">new</span> OptionalConverterFactory();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">      Type type, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">    <span class="keyword">if</span> (getRawType(type) != Optional.class) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Type innerType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) type);</span><br><span class="line">    Converter&lt;ResponseBody, Object&gt; delegate =</span><br><span class="line">        retrofit.responseBodyConverter(innerType, annotations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptionalConverter&lt;&gt;(delegate);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IgnoreJRERequirement</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    OptionalConverter(Converter&lt;ResponseBody, T&gt; delegate) {</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(delegate.convert(value));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>responseBodyConverter</code>逻辑很简单，判断放回类型<code>Type</code>是不是<code>Optional.class</code>,然后返回<code>OptionalConverter</code>。那么网络成功返回数据就会调用<code>convert</code>函数，而这个直接委托给下一个转化器。</p><p>而在构建<code>converterFactories</code>列表的时候，会优先添加<code>BuiltInConverters</code>,然后是我们自定义的转换器，最后如果Android SDK&gt;=24,才添加<code>OptionalConverterFactory</code>。也就是说从这里可以看到优先权。</p><p>而构建<code>callAdapterFactories</code>列表，则是先我们自定义的，再是平台默认的适配器。</p><p>通常情况下，我们都会添加<code>GsonConverterFactory</code>适配器，将<code>gson</code>转化成对象类型。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">    Type type, Annotation[] annotations, Retrofit retrofit) {</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>GsonResponseBodyConverter</code>的<code>convert</code>函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">  JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    T result = adapter.read(jsonReader);</span><br><span class="line">    <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">"JSON document was not fully consumed."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    value.close();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，Retrofit整个源码流程就分析完了。所以也应该学会了如何自定适配器和转换器了。</p><h2 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h2><p>Retrofit在目前版本2.6.0开始就已经支持协程，即允许在接口中定义挂起函数。那Retrofit如何确定接口定义的函数是挂起函数呢？</p><p>在上一节分析<code>RequestFactory.parseAnotations</code>中分析函数注解，说到<code>parseParameter</code>解析函数参数注解，有提到判断函数是否挂起函数。来看是如何判断的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="meta">@Nullable</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">     <span class="keyword">int</span> p, Type parameterType, <span class="meta">@Nullable</span> Annotation[] annotations, <span class="keyword">boolean</span> allowContinuation) {</span><br><span class="line">······</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span>) {<span class="comment">//参数没有注解</span></span><br><span class="line">     <span class="keyword">if</span> (allowContinuation) {<span class="comment">//参数为函数最后一个参数</span></span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">         <span class="keyword">if</span> (Utils.getRawType(parameterType) == Continuation.class) {<span class="comment">//参数类型为Continuation</span></span><br><span class="line">           isKotlinSuspendFunction = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         }</span><br><span class="line">       } <span class="keyword">catch</span> (NoClassDefFoundError ignored) {</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">throw</span> parameterError(method, p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>判断是否协程函数有三个条件：</p><ol><li>函数参数没有注解</li><li>该参数是在函数中的最后一个位置</li><li>该参数的类型是<code>Continuation.class</code></li></ol><p>但这跟我们理解中协程的挂起函数区别有点大啊。因为这是我们理解中的<code>Kotlin</code>挂起函数，当它编译后成Java字节码后，会自动在函数最后一个参数增加<code>Continuation</code>类型的参数。</p><p><code>Kotlin</code>函数</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span></span><br></pre></td></tr></tbody></table></figure><p><code>Java</code>函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void getData(Continuation c)</span><br></pre></td></tr></tbody></table></figure><p>通过解析接口中函数的最后一个参数没有注解，而且类型为<code>Continuation</code>时，就确定为了一个Kotlin协程挂起函数，并将<code>ReqeustFactory</code>的<code>isKotlinSuspendFunction</code>设置为<code>true</code>。</p><p>在<code>HttpServiceMethod.parseAnnotations</code>解析时根据<code>isKotlinSuspendFunction</code>来走不同的分支，例如<code>isKotlinSuspendFunction=true</code>情况下，返回的是<code>SuspendForResponse</code>,<code>=false</code>情况下，返回的是<code>CallAdapter</code>。看看具体处理了哪些工作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>{</span><br><span class="line">  <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">  <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  Type adapterType;</span><br><span class="line">   <span class="comment">//协程情况下，与非协程情况下类似，获取返回类型adapterType,用于创建CallAdapter</span></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) {</span><br><span class="line">    Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    Type responseType =</span><br><span class="line">        Utils.getParameterLowerBound(</span><br><span class="line">            <span class="number">0</span>, (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) {</span><br><span class="line">      <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">      responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">      continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// TODO figure out if type is nullable or not</span></span><br><span class="line">      <span class="comment">// Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)</span></span><br><span class="line">      <span class="comment">// Find the entry for method</span></span><br><span class="line">      <span class="comment">// Determine if return type is nullable or not</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">    annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    adapterType = method.getGenericReturnType();<span class="comment">//非协程情况</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">      </span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (!isKotlinSuspendFunction) {<span class="comment">//非协程情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) {</span><br><span class="line">    <span class="comment">////使用了协程，且返回类型Response</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForResponse&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">////使用了协程，且返回类型ResponseBody</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForBody&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">            continuationBodyNullable);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这里根据接口的函数返回类型的不同，返回<code>SuspendForResponse</code>或者<code>SuspendForBody</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForResponse</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">  SuspendForResponse(</span><br><span class="line">      RequestFactory requestFactory,</span><br><span class="line">      okhttp3.Call.Factory callFactory,</span><br><span class="line">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">      CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) {</span><br><span class="line">    <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>{</span><br><span class="line">    call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">    Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class="line">        (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See SuspendForBody for explanation about this try/catch.</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="keyword">return</span> KotlinExtensions.suspendAndThrow(e, continuation);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过调用<code>OkHttp</code>的<code>Call</code>扩展函数来实现网络请求。我们知道非协程下是通过创建OkHttpCall来实现的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">suspend fun &lt;T : Any&gt; Call&lt;T&gt;.await(): T {</span><br><span class="line">  <span class="keyword">return</span> suspendCancellableCoroutine { continuation -&gt;</span><br><span class="line">    continuation.invokeOnCancellation {</span><br><span class="line">      cancel()</span><br><span class="line">    }</span><br><span class="line">    enqueue(object : Callback&lt;T&gt; {</span><br><span class="line">      <span class="function">override fun <span class="title">onResponse</span><span class="params">(call: Call&lt;T&gt;, response: Response&lt;T&gt;)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful) {</span><br><span class="line">          val body = response.body()</span><br><span class="line">          <span class="keyword">if</span> (body == <span class="keyword">null</span>) {</span><br><span class="line">            val invocation = call.request().tag(Invocation::class.java)!!</span><br><span class="line">            val method = invocation.method()</span><br><span class="line">            val e = KotlinNullPointerException(<span class="string">"Response from "</span> +</span><br><span class="line">                method.declaringClass.name +</span><br><span class="line">                <span class="string">'.'</span> +</span><br><span class="line">                method.name +</span><br><span class="line">                <span class="string">" was null but response body type was declared as non-null"</span>)</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            continuation.resume(body)</span><br><span class="line">          }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          continuation.resumeWithException(HttpException(response))</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="function">override fun <span class="title">onFailure</span><span class="params">(call: Call&lt;T&gt;, t: Throwable)</span> </span>{</span><br><span class="line">        continuation.resumeWithException(t)</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说，非协程与协程下的Retrofit的工作流程差不多。协程情况下，在<code>RequestFactory</code>解析，确定是协程，在<code>HttpserviceMethod</code>解析走不同的路径，通过<code>Call</code>扩展函数实现网络请求。</p><h2 id="动态代理-2"><a class="markdownIt-Anchor" href="#动态代理-2"></a> 动态代理</h2><p>说到动态代理，总是离不开静态代理和代理模式。静态代理总是要写接口，然后代理类和被代理类实现该接口，客户端通过代理类使用接口提供的功能，而代理类把功能实际的工作转到被代理类。问题在哪里，每次我们都懂得去实现代理类和代理类，如果很多个接口，这样会很累的，毕竟程序员都是懒的。再说如果这样，用Retrofit这种第三方库，怎么知道用户创建什么样的接口，怎么去实现他们功能？那就是利用Java的动态代理技术了。动态代理在使用上也可以理解是一套模板。</p><p>首先，定义接口，以及实现类，也就是我们对外提供的功能。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Service {</span><br><span class="line">    void coding();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class CoderService implements Service {</span><br><span class="line">    @Override</span><br><span class="line">    public void coding() {</span><br><span class="line">        System.out.println("提供编程服务");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二，实现<code>InvocationHandler</code>的子类。核心点在于实现<code>invoke</code>函数，调用接口的函数都会转到这里来。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Object service)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"开发了"</span>);</span><br><span class="line">        method.invoke(service,objects);</span><br><span class="line">        System.out.println(<span class="string">"结束了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，创建<code>Proxy.newProxyInstance</code>接口对象。在Java中，接口和抽象类是不能被直接实例化的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Service service = <span class="keyword">new</span> CoderService();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> Handler(service);</span><br><span class="line">        Service se = (Service) Proxy.newProxyInstance(Service.class.getClassLoader(), <span class="keyword">new</span> Class[]{Service.class}, handler);</span><br><span class="line">        se.coding();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就可以通过实例化的接口对象，使用相关功能。</p><p><code>Retrofit</code>通过在<code>InvocationHandler</code>的<code>invoke</code>解析<code>Method</code>来获得网络请求所需要的的数据。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>Retrofit通过Java动态代理技术生成我们请求接口的对象，而我们调用对象的任何函数时，其实都转到<code>InvocationHandler</code>对象的<code>invoke</code>函数。而<code>invoke</code>函数的主要工作就是解析我们在接口中定义函数，包括解析注解，参数注解及值，以及返回类型，然后封装到<code>RequestFactory</code>，然后通过<code>HttpServiceMethod.parseAnnotations</code>函数，查找合适的请求适配器和响应转换器，最后将<code>RequestFactory</code>和适配器、转换器封装成<code>HttpServiceMethod</code>的子类，并调用其<code>invoke</code>函数，通过<code>OkHttp</code>发起网络请求。</p><p>通过源码分析，我们知道，一个优秀的的框架都会使用缓存，例如这里方法的解析，<code>OkHttp</code>请求的缓存。同时也知道Retrofit目前已经支持协程，即挂起函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;通过分析Retrofit源码，了解这款简洁的网络库如何提高我们的工作效率。通过动态代理技术，创建我们接口对象，以提供我们调用接口函数。通过解析接</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Retrofit" scheme="http://example.com/tags/Retrofit/"/>
    
    <category term="源码分析" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析</title>
    <link href="http://example.com/2021/03/15/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/03/15/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-03-18T10:08:16.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>本文主要是分析Android主流网络请求框架<code>OkHttp</code>源码，看看每天都在打交道的伙计到底在干什么。处理了网络中最根本的HTTP问题，如对HTTP请求报文和响应报文的处理。允许自定义拦截器实现特殊的需求，如日志打印，增加请求头等。默认六个拦截器处理网络请求，缓存复用，连接复用，数据转化，重试恢复机制。</p><h2 id="请求"><a class="markdownIt-Anchor" href="#请求"></a> 请求</h2><p><code>OkHttp</code>的异步请求主要了调用<code>Call</code>对象的<code>enqueue</code>函数，而<code>Call</code>接口唯一的实现类是<code>RealCall</code>。所以异步请求主要是调用了<code>RealCall</code>的<code>enqueue</code>函数，而同步请求则是<code>RealCall</code>对象的<code>execute</code>函数。</p><h3 id="realcall的enqueue与execute函数"><a class="markdownIt-Anchor" href="#realcall的enqueue与execute函数"></a> <code>RealCall</code>的enqueue与execute函数</h3><p>下面先分析异步请求：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> {</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) { <span class="string">"Already Executed"</span> }</span><br><span class="line"></span><br><span class="line">    callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><code>RealCall</code>调用<code>Dispatcher的enqueue</code>函数</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> {</span><br><span class="line">    synchronized(<span class="keyword">this</span>) {</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) {</span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>readyAsyncCalls</code>是一个队列，用于保存即将执行的<code>AsyncCall</code>。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> {</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) {</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) {</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"><span class="comment">//maxRequests默认最大网络请求数 64 </span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">//maxRequestsPerHost默认最大目的主机请求数5</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove()</span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    }</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span><span class="comment">//待运行+正在运行主机数</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) {</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    <span class="comment">//调用AsyncCall</span></span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>runningAsyncCalls</code> 是一个队列，保存<strong>正在执行</strong>的<code>AsyncCall</code>。<code>promoteAndExecute()</code>函数主要将<code>readyAsyncCalls</code>队列中待运行的请求添加到<code>runningAsyncCalls</code>队列中，并调用其<code>executeOn</code>函数。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> {</span><br><span class="line">  client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//将AsyncCall添加到线程池中</span></span><br><span class="line">    executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">    success = <span class="literal">true</span></span><br><span class="line">  } <span class="keyword">catch</span> (e: RejectedExecutionException) {</span><br><span class="line">    <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">    ioException.initCause(e)</span><br><span class="line">    noMoreExchanges(ioException)</span><br><span class="line">    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (!success) {</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>executeOn</code>函数主要是将<code>AsyncCall</code>添加到线程池中。此时看看<code>AsyncCall</code>的<code>run</code>函数如何实现。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">  threadName(<span class="string">"OkHttp <span class="subst">${redactedUrl()}</span>"</span>) {</span><br><span class="line">    <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">    timeout.enter()</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">//在这里返回了响应数据</span></span><br><span class="line">      <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">      signalledCallback = <span class="literal">true</span></span><br><span class="line">      responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">    } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">      <span class="keyword">if</span> (signalledCallback) {</span><br><span class="line">        <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">        Platform.<span class="keyword">get</span>().log(<span class="string">"Callback failure for <span class="subst">${toLoggableString()}</span>"</span>, Platform.INFO, e)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (t: Throwable) {</span><br><span class="line">      cancel()</span><br><span class="line">      <span class="keyword">if</span> (!signalledCallback) {</span><br><span class="line">        <span class="keyword">val</span> canceledException = IOException(<span class="string">"canceled due to <span class="variable">$t</span>"</span>)</span><br><span class="line">        canceledException.addSuppressed(t)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">throw</span> t</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>run</code>函数，通过<code>getResponseWithInterceptorChain()</code>函数返回了响应数据，可见在该函数里面进行了网络请求。</p><p>再回到同步请求中，即调用<code>realCall</code>的<code>execute</code>函数。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response {</span><br><span class="line">  check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) { <span class="string">"Already Executed"</span> }</span><br><span class="line"></span><br><span class="line">  timeout.enter()</span><br><span class="line">  callStart()</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，同步请求直接调用了<code>getResponseWithInterceptorChain()</code>函数，而不是交给线程池去执行。因此同步请求 的时候记得切换到子线程执行。</p><h3 id="getresponsewithinterceptorchain"><a class="markdownIt-Anchor" href="#getresponsewithinterceptorchain"></a> <code>getResponseWithInterceptorChain</code></h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response {</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) {</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  }</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) {</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  } <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) {</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>getResponseWithInterceptorChain()</code>函数先是将我们自定义的拦截器和默认的拦截器添加到集合中，并创建<code>RealInterceptorChain</code>对象<code>chain</code>，即所谓的拦截链。然后调用<code>chain.proceed(originalRequest)</code>返回响应数据。每一个拦截器都会实现自己特定的功能，并在自己的重载的<code>intercept</code>函数中调用<code>chain.proceed(request)</code>函数去调用下一个拦截器的<code>intercept</code>函数。这里<code>request</code>已经不再是原始的<code>originalRequest</code>，而且经过当前拦截器改造，假如需要的话。先不管每个拦截器分做了什么，大概就知道了拦截链的调用图。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210302114511.png" alt="未命名绘图"></p><h2 id="拦截链"><a class="markdownIt-Anchor" href="#拦截链"></a> 拦截链</h2><p>在<code>OkHttp</code>中，最重要的就是拦截链中每个拦截器的工作。例如发起网络请求的<code>CallServerInterceptor</code>,网络连接的<code>ConnectInterceptor</code>,缓存策略的<code>CacheInterceptor</code>,桥接模式的<code>BridgeInterceptor</code>,重试恢复的<code>RetryAndFollowUpInterceptor</code>。以及我们自定义的<code>Interceptor</code>,可以用来打印日志等。从它们在拦截链的不同位置，以及所做的事情，可以掌握更好的自定义的Interceptor。</p><h3 id="网络请求callserverinterceptor"><a class="markdownIt-Anchor" href="#网络请求callserverinterceptor"></a> 网络请求：<code>CallServerInterceptor</code></h3><p>那么，我们假装所有拦截器都会调用下一个拦截器，直到最后的<code>CallServerInterceptor</code>拦截器。作为拦截链最后一个拦截器，只重写了<code>intercept</code>函数，并进行真正的网络请求。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">   <span class="keyword">val</span> exchange = realChain.exchange!!</span><br><span class="line">   <span class="keyword">val</span> request = realChain.request</span><br><span class="line">   <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">   <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">   exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> invokeStartEvent = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">     <span class="comment">//除了head+get,其他返回false，因为其他需要请求体</span></span><br><span class="line">   <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) {</span><br><span class="line">     <span class="comment">//客户端请求头携带"Expect: 100-continue"表示告诉服务器，客户端有一个期望值（例如请求体很大），希望得到服务器能否妥善处理该请求，响应报文状态码：100能417不能</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) {</span><br><span class="line">       exchange.flushRequest()</span><br><span class="line">       <span class="comment">//responseBuilder=null表示服务器能处理</span></span><br><span class="line">       responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">       invokeStartEvent = <span class="literal">false</span></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) {</span><br><span class="line">       <span class="keyword">if</span> (requestBody.isDuplex()) {</span><br><span class="line">         <span class="comment">//Http 2.0全双工，发送请求，并将请求体写到底层TCP发送缓存</span></span><br><span class="line">         exchange.flushRequest()</span><br><span class="line">         <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">         requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">//服务器能处理`"Expect: 100-continue"`期望，将请求体写到底层TCP发送缓存</span></span><br><span class="line">         <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">         requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">         bufferedRequestBody.close()</span><br><span class="line">       }</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       exchange.noRequestBody()</span><br><span class="line">       <span class="keyword">if</span> (!exchange.connection.isMultiplexed) {</span><br><span class="line">          <span class="comment">//非100-continue情况下，防止HTTP/1.1的使用</span></span><br><span class="line">         exchange.noNewExchangesOnConnection()</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     exchange.noRequestBody()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) {</span><br><span class="line">     exchange.finishRequest()</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//开始获取响应头</span></span><br><span class="line">   <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) {</span><br><span class="line">     responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">     <span class="keyword">if</span> (invokeStartEvent) {</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">       invokeStartEvent = <span class="literal">false</span></span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">       .request(request)</span><br><span class="line">       .handshake(exchange.connection.handshake())</span><br><span class="line">       .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">       .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">       .build()</span><br><span class="line">   <span class="keyword">var</span> code = response.code</span><br><span class="line">   <span class="comment">//服务器响应：Expect：100-continue </span></span><br><span class="line">   <span class="keyword">if</span> (code == <span class="number">100</span>) {</span><br><span class="line">  <span class="comment">//重新读取响应头</span></span><br><span class="line">     responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">     <span class="keyword">if</span> (invokeStartEvent) {</span><br><span class="line">       exchange.responseHeadersStart()</span><br><span class="line">     }</span><br><span class="line">     response = responseBuilder</span><br><span class="line">         .request(request)</span><br><span class="line">         .handshake(exchange.connection.handshake())</span><br><span class="line">         .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build()</span><br><span class="line">     code = response.code</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//响应头读取结束</span></span><br><span class="line">   exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">   response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) {</span><br><span class="line">     <span class="comment">// 表示服务器支持协议升级，切换到websocket或者HTTP 2。</span></span><br><span class="line">     response.newBuilder()</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .build()</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">     response.newBuilder()</span><br><span class="line">         .body(exchange.openResponseBody(response)) <span class="comment">//获取响应数据真正地方</span></span><br><span class="line">         .build()</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">       <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) {</span><br><span class="line">     exchange.noNewExchangesOnConnection()<span class="comment">//关闭连接</span></span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) {</span><br><span class="line">     <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">         <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">${response.body?.contentLength()}</span>"</span>)</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> response</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>整块代码看下来，主要是为了区别下面几种情况：</p><ul><li><p><strong>Expect：100-continue</strong>: 客户端请求报文携带该请求头字段，表示期望服务器能处理客户端的某个期望，例如大报文。如果能满足该条件，服务器则返回状态码是100的响应报文。</p><p><code>OKHttp</code>的处理是，如果满足该条件，直接发送请求，开始等待服务器响应，若服务器支持，则直接将请求报文数据写到发送缓存中。</p></li><li><p><strong>全双工 HTTP2.0</strong>：因为目前HTTP中只有2.0版本支持全双工，全双工的过程中，请求报文与响应报文的传输会有交差的情况，HTTP/1.1 半双工不存在这种情况。</p><p><code>OKHttp</code>的处理是，如果满足该条件，直接发送请求，开始等待服务器响应，若服务器支持，则直接将请求报文数据写到发送缓存中。</p></li><li><p><strong>一般情况</strong>：直接调用<code>exchange.noRequestBody()</code>进行请求。</p></li></ul><p>最后通过根据响应头判断是否需要协议升级，否则通过<code>exchange.openResponseBody(response)</code>获取响应数据部分。</p><p>所以大概流程就是：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">exchange.flushRequest()</span><br><span class="line"><span class="comment">//写请求数据部分</span></span><br><span class="line"><span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">requestBody.writeTo(bufferedRequestBody)</span><br><span class="line"><span class="comment">//结束请求</span></span><br><span class="line">exchange.finishRequest()</span><br><span class="line"><span class="comment">//开始读取响应头</span></span><br><span class="line">exchange.responseHeadersStart()</span><br><span class="line"><span class="comment">//读取响应头</span></span><br><span class="line">exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line"><span class="comment">//结束读取响应头</span></span><br><span class="line">exchange.responseHeadersEnd(response)</span><br><span class="line"><span class="comment">//读取响应体</span></span><br><span class="line">exchange.openResponseBody(response)</span><br></pre></td></tr></tbody></table></figure><p>而在正常获得响应数据后，回调<code>Callback</code>对象的<code>onResponse</code>函数。到此，整个过程也就结束了。</p><h3 id="连接复用connectinterceptor"><a class="markdownIt-Anchor" href="#连接复用connectinterceptor"></a> 连接复用：<code>ConnectInterceptor</code></h3><p><code>ConnectInterceptor</code>连接拦截器的<code>intercept</code>函数非常简单，但却涉及到<code>OkHttp</code>的一个重要概念，<strong>连接复用</strong>。众所周知，HTTP是基于运输层的TCP协议（HTTP/3将基于UDP协议），意味着TCP三次握手建立连接和4次挥手断开连接，以及拥塞机制的慢启动阶段,都会影响到APP性能和数据响应速度。通过TCP连接的复用，能有效提高效率和降低时延。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">  <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">  <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>intercept</code>函数中最重要的代码<code>realChain.call.initExchange(chain)</code>，创建或复用一条TCP连接进行HTTP请求或响应。这里有条调用链：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealCall.initExchange-&gt;ExchangeFinder.find-&gt;ExchangeFinder.findHealthyConnection</span><br><span class="line">-&gt;ExchangeFinder.findConnection</span><br></pre></td></tr></tbody></table></figure><p>在<code>findConnection</code>函数中，查找有用的连接步骤：</p><ol><li>复用当前请求<code>RealCall</code>的连接。如果当前<code>RealCall</code>携带的连接<code>connection</code>不为<code>null</code>，且端口号与主机与当前主机请求一致。判断是否有其他请求<code>call</code>在该<code>connection</code>与服务器交互，没有的情况下通知连接池释放该连接，并返回Socket，并复用该<code>connection</code>。</li><li>在连接池中寻找。遍历连接池中所有的<code>connection</code>，通过<code>connection.isEligible</code>来判断是否可以复用该<code>connection</code>。<code>isEligible</code>函数会检查很多东西，例如域名、域名、代理、DNS等等是否一致。甚至HTTP/2的<code>connect</code>的一些要求，例如证书。</li><li>创建新的连接。如果在前两步没有找到合适的<code>connection</code>，只能创建新的<code>connection</code>了。在创建新的连接前，还会在创建路由后，再尝试在连接池中寻找合适的<code>connection</code>。否则会为当前请求<code>call</code>创建新的<code>connection</code>并添加在连接池。</li></ol><p><strong>连接池：<code>RealConnectionPool</code></strong></p><p><code>RealConnectionPool</code>内部有一个<code>ConcurrentLinkedQueue&lt;RealConnection</code>类型的<code>connections</code>，用于持有所有连接。在创建<code>OkHttpClient</code>时，会创建默认的最大空闲连接数为5，存活时间为5分钟的连接池。</p><h3 id="缓存策略cacheinterceptor"><a class="markdownIt-Anchor" href="#缓存策略cacheinterceptor"></a> 缓存策略：<code>CacheInterceptor</code></h3><p>缓存拦截器通常情况下只支持<code>GET</code>方法请求的缓存，每次请求都会先根据URL计算出key,然后在<code>DiskLruCache</code>中获取缓存快照（上次请求缓存的数据），假如有的话。然后根据缓存快照和请求报文，生成缓存策略，即根据请求报文和响应报文的首部行中相关字段（<code>Cache-Control</code>、<code>Etag</code>等等）来生成策略。根据不同的缓存策略进行不同的操作。</p><ol><li><p>通过url的md5+hex获取缓存快照</p><p>通过<code>Request</code>的<code>URL</code>计算出的<code>md5</code>的<code>hex</code>值作为<code>key</code>，来获取<code>DiskLruCache</code>中的缓存快照<code>SnapShot</code>。<code>Snapshot</code>缓存了请求报文和响应报文的相关数据，例如请求报文的请求行和响应报文的状态行。通过<code>SnapShot</code>构建<code>Entry</code>对象，该对象主要存储了请求报文和响应报文的首部信息。最后通过<code>Entry</code>和<code>SnapShot</code>的创建出缓存响应<code>Response</code>。</p><p><code>SnapShot</code>通过<code>snapshot.getSource(ENTRY_METADATA)</code>获取首部元数据信息，和<code>snapshot.getSource(ENTRY_BODY)</code>获取缓存的响应报文数据部分。</p></li><li><p><code>CacheStrategy.Factory</code>计算缓存策略</p><p>通过<code>CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</code>生成的<code>CacheStartegy</code>对象含有两个属性<code>networkRequest</code>和<code>cacheResponse</code>,当<code>cacheResponse==null</code>表示不使用缓存，从服务器拉取数据；当<code>networkRequest==null</code>表示强制使用缓存。同时为<code>null</code>,表示不满足<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>only-if-cached</code></a>。<code>compute</code>函数主要是根据请求报文和响应报文的请求头来生成缓存策略。</p><p>**<code>cacheResponse==null</code>**情况：</p><ul><li>本地没有缓存，即第一步得出的<code>cacheCandidate==nll</code>。</li><li>HTTP中不支持缓存的报文或者请求报文和响应报文首部行设置了<code>Cache-Control:no-store</code></li><li>缓存的响应报文请求头都没设置<code>ETag</code>,<code>Last-Modified</code>,<code>Date</code>字段。</li></ul><p>**<code>networkRequest==null</code>**情况：</p><ul><li>request设置了<code>Cache-Control:only-if-cached</code>。</li><li>使用协商缓存，且缓存未过期。</li></ul></li><li><p>判断<code>networkRequest==null</code>的情况，表示只使用缓存。</p></li><li><p>发起网络请求，若服务器响应304且本地缓存不为null，则使用本地缓存，并更新本地缓存。</p></li><li><p>最后将请求报文和响应报文存放到缓存中，仅支持<strong>GET缓存</strong>。</p></li></ol><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> call = chain.call()</span><br><span class="line">   <span class="comment">//第一步:通过url的md5+hex获取缓存快照</span></span><br><span class="line">   <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"><span class="comment">//计算缓存策略</span></span><br><span class="line">   <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">   <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">   <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">   cache?.trackResponse(strategy)</span><br><span class="line">   <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) {</span><br><span class="line">     <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">     cacheCandidate.body?.closeQuietly()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//请求报文使用缓存，即请求头携带`Cache-Control：if-only-cached`</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">return</span> Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">         .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build().also {</span><br><span class="line">           listener.satisfactionFailure(call, it)</span><br><span class="line">         }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// networkRequest==null表示不使用网络请求</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build().also {</span><br><span class="line">           listener.cacheHit(call, it)</span><br><span class="line">         }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">     listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">   } <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) {</span><br><span class="line">     listener.cacheMiss(call)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">     <span class="comment">//发起网络请求，也就是会调用CallServerInterceptor的intercept函数</span></span><br><span class="line">       networkResponse = chain.proceed(networkRequest)</span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">     <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">     <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) {</span><br><span class="line">       cacheCandidate.body?.closeQuietly()</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果有本地缓存，且服务器返回304报文的，则使用响应报文</span></span><br><span class="line">   <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) {</span><br><span class="line">       <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build()</span><br><span class="line"></span><br><span class="line">       networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">       <span class="comment">//更新缓存</span></span><br><span class="line">       cache!!.trackConditionalCacheHit()</span><br><span class="line">       cache.update(cacheResponse, response)</span><br><span class="line">       <span class="keyword">return</span> response.also {</span><br><span class="line">         listener.cacheHit(call, it)</span><br><span class="line">       }</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       cacheResponse.body?.closeQuietly()</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {</span><br><span class="line">       <span class="comment">//存放缓存</span></span><br><span class="line">       <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">       <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also {</span><br><span class="line">         <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) {</span><br><span class="line">           <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">           listener.cacheMiss(call)</span><br><span class="line">         }</span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">  <span class="comment">//仅支持GET缓存</span></span><br><span class="line">     <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) {</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">         cache.remove(networkRequest)</span><br><span class="line">       } <span class="keyword">catch</span> (_: IOException) {</span><br><span class="line">         <span class="comment">// The cache cannot be written.</span></span><br><span class="line">       }</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> response</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="桥接模式bridgeinterceptor"><a class="markdownIt-Anchor" href="#桥接模式bridgeinterceptor"></a> 桥接模式：BridgeInterceptor</h3><p>之所以将它称为桥接模式拦截器，是因为它将应用发起的请求转化成HTTP请求所需的内容，将网络响应数据转化成应用数据。其实也没那么神奇，就是已有的Request，判断请求报文是否添加一些头部信息，没有话就帮我们添加，如：<code>Content-Type</code>、<code>Content-Length</code>等等。</p><p>请求报文首部行：</p><ul><li><code>Content-Type</code>:如果在<code>ReqeuestBody</code>添加了<code>ContentType</code>,则帮我们添加到<code>header</code>。</li><li><code>Content-Length</code>:如果<code>ReqeuestBody</code>的<code>contentLength</code>没有设置，则添加<code>Transfer-Encoding:chunked</code>,否则添加到<code>header</code>。</li><li><code>Transfer-Encoding:chunked</code>,在没有<code>ReqeuestBody</code>情况下才会设置该请求头。</li><li><code>Host:域名</code></li><li><code>Connection:Keep-Alive</code></li><li><code>Accept-Encoding: gzip</code>如果帮我们添加了该请求头，还要负责帮我们解压缩。</li><li><code>Cookie:XXX</code> 假如有的话</li><li><code>User-Agent:okhttp/${OkHttp.VERSION}</code></li></ul><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">   <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">   <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> body = userRequest.body </span><br><span class="line">   <span class="keyword">if</span> (body != <span class="literal">null</span>) {</span><br><span class="line">     <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">     <span class="keyword">if</span> (contentType != <span class="literal">null</span>) {</span><br><span class="line">       requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">     <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) {</span><br><span class="line">       requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">       requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//Host:域名 请求头</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">   }</span><br><span class="line"><span class="comment">//Connection:Keep-Alive HTTP1.1 短连接请求头</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">   <span class="comment">// the transfer stream.</span></span><br><span class="line">   <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     transparentGzip = <span class="literal">true</span></span><br><span class="line">     requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">   <span class="keyword">if</span> (cookies.isNotEmpty()) {</span><br><span class="line">     requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) {</span><br><span class="line">     requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">   cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">       .request(userRequest)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">       <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">       networkResponse.promisesBody()) {</span><br><span class="line">     <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">     <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) {</span><br><span class="line">       <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">       <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">           .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">           .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">           .build()</span><br><span class="line">       responseBuilder.headers(strippedHeaders)</span><br><span class="line">       <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">       responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="重试恢复retryandfollowupinterceptor"><a class="markdownIt-Anchor" href="#重试恢复retryandfollowupinterceptor"></a> 重试恢复：RetryAndFollowUpInterceptor</h3><p>该拦截器在客户端允许重试恢复机制下，主要根据网络请求抛出的一些异常类型或者响应报文的状态码，进行重试恢复请求。如果该异常或者状态码不支持恢复，或者重试次数达到了设置次数，则抛出异常，本次客户端发起的请求。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response {</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) {</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      } <span class="keyword">catch</span> (e: RouteException) {</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) {</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        }</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      } <span class="keyword">catch</span> (e: IOException) {</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) {</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        }</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">//while是一个死循环</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) {</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">//判读一些常见的网络错误或者重定向，例如400，然后尝试新建request的恢复连接</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) {</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        }</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) {</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) {</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>recover</code>函数主要检测发生的异常是否属于可以恢复的类型。如果设置了<code>client.retryOnConnectionFailure=false</code>,直接抛出异常不会重新进行请求。主要是根据一些错误的类型，来判断该错误是否避免，如果不能避免就直接抛异常，可以的话重新进入下次<code>while</code>循环。</p><h2 id="自定义拦截器"><a class="markdownIt-Anchor" href="#自定义拦截器"></a> 自定义拦截器</h2><p>我们自定的拦截器有两种，一种是普通的应用拦截器，也就是拦截链最开始的地方。第二种是网络拦截器，在拦截链倒数第二，即发起网络前。前者处于拦截链的前端，可以多次调用拦截链后续的拦截器，但拦截不到它们处理的内容。后者只有发起网络才会被拦截到，例如命中缓存的话，并不会调用到。因此在自定义拦截器时，要根据具体的需求实现不同拦截器。</p><h2 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h2><p>OkHttp的拦截链使用了责任链设计模式，将一个请求交给多个对象处理，解耦了请求的发送者和接收者。将对象构成链，并将请求沿着该链传递，直到某个处理对象终止该请求。例如缓存拦截器命中缓存后终止将请求交付给下个一个处理对象。</p><p>每个处理对象根据自己的特性，即处理能力，当请求满足自身条件，则进行处理而不继续传递。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p>通过分析OkHttp的源码，发现大部分的HTTP知识点，也就是OkHttp自己实现了一套从低到上的网络请求框架。以前总以为OkHttp应该很复杂，毕竟那么流行。却没想到如此的基础和稳定，学习了，不要惧怕源码，勇敢过去学。</p><hr><p><strong>【相关连接】</strong></p><p><a href="https://xxm-sz.github.io/2021/03/06/Http%E4%B8%8EHttps/">HTTP与HTTPS</a></p><p><a href="https://xxm-sz.github.io/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/">运输层TCP</a></p><p><a href="https://xxm-sz.github.io/2021/03/02/OkHttp%E4%BD%BF%E7%94%A8/#%E6%91%98%E8%A6%81">OkHttp使用</a></p><p>欢迎<strong>点赞+关注+评论三连击</strong></p><p>【<a href="https://github.com/xxm-sz">Github</a>】【<a href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a href="https://xxm-sz.github.io/">博客</a>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;本文主要是分析Android主流网络请求框架&lt;code&gt;OkHttp&lt;/code&gt;源码，看看每天都在打交道的伙计到底在干什么。处理了网络中最根本</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="OkHttp" scheme="http://example.com/tags/OkHttp/"/>
    
    <category term="源码分析" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS</title>
    <link href="http://example.com/2021/03/06/Http%E4%B8%8EHttps/"/>
    <id>http://example.com/2021/03/06/Http%E4%B8%8EHttps/</id>
    <published>2021-03-05T16:00:00.000Z</published>
    <updated>2021-03-18T09:56:34.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>本文主要是HTTP/1.1以及HTTP/2和HTTP/3的一些要点，版本的更新都是为了升级和迭代旧版本。HTTP一直在不停的优化升级，以提高带宽利用和降低请求与响应的延迟。通过SSL\TLS协议加密HTTP传输数据，让传输数据更安全。</p><h2 id="超文本传输协议http"><a class="markdownIt-Anchor" href="#超文本传输协议http"></a> 超文本传输协议HTTP</h2><p>HTTP协议是客户端与Web服务器之间的应用层通信协议。从最开始用于万维网传输文本到现在传输多媒体资源。从HTTP/1.0最简单的一次请求对应一次TCP连接，再到HTTP/1.1在短时间内复用TCP连接进行持续传输数据，再到HTTP/2面向一次TCP连接全双攻交换所有数据，到目前HTTP/3基于改TCP为UDP数据报传输数据。HTTP一直在为了降低时延，提高响应和提高资源利用率而不停的优化和升级中。</p><h3 id="http11版本"><a class="markdownIt-Anchor" href="#http11版本"></a> HTTP/1.1版本</h3><p>HTTP/1.0 作为HTTP的第一个版本，存在的两个主要问题：</p><ul><li>每次请求，都需要建立TCP连接。这样旧的TCP无法复用，导致资源浪费。TCP三次握手建立连接和四次挥手断开都需要消耗性能。</li><li><code>head of line blocking</code>，导致带宽浪费。即第一个请求被阻塞，后续请求需要等待第一个响应报文，才能继续发送请求，这种就浪费了带宽，增加时延。</li></ul><p><strong>HTTP/1.1协议改进</strong>:</p><ul><li>连接可复用，增加管线化技术。这样在复用TCP连接后，后续请求报文可以沿着连接发送给服务器，降低延迟。同时也会造成的问题，TCP连接在有限时间内会关闭，对于闲散的请求不合适，例如移动端；前面的请求阻塞导致后续请求也被搁置，浪费带宽。</li><li>支持响应分块。</li><li>缓存控制机制</li><li>内容协商机制，例如请求头协商编码，类型等等。</li><li>增加Host头，能够使不同域名配置在同一个IP地址的服务器上。</li></ul><p>为了解决TCP连接没复用，HTTP/1.1在请求头加入<code>Connection:Keep-Alive</code>,表示在一定时间内复用连接，具体时长服务端设置。如果要关闭连接复用需要显式的设置``Connection:Close`。但其实这种持续连接对浏览器请求来说作用比较大，因为浏览器在发起对一个网站链接请求时，很发出很多HTTP请求，那么对同个域名的请求就可以复用同个链接。而对移动端应用来说，HTTP请求一般比较分散。</p><p>目前HTTP/1.1广泛应用在互联网中，默认的HTTP请求与响应都基础HTTP/1.1。</p><p><strong>请求报文格式</strong>：</p><p>HTTP报文分为两种：<strong>请求报文</strong>，<strong>响应报文</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210302212947.png" alt="image-20210302212455000"></p><p>在<strong>请求报文</strong>中，第一行称为请求行，分别由方法、URL、版本以及它们之间的空格组成。</p><ul><li>方法 ：即HTTP定义的<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code>。而最常见就是<code>GET</code>和<code>POST</code>。</li><li>URL: 这里的URL是相对URL，就是去掉域名后剩下的相对路径。例如<code>http://xxm-sz.com/dreamter/http</code>,这里的URL就是<code>dreamter/http</code>。</li><li>版本：现在普遍使用和默认都是HTTP/1.1版本，但在不久的将来，很快就升级到HTTP/2版本，甚至HTTP/3版本。</li></ul><p>在请求行后便是<strong>首部行</strong>，通常由多条请求头组成，例如<code>Connection: keep-alive</code>,<code>Host:www.baidu.com</code></p><p>在首部行结束后，换行便是请求报文的数据部分，但不一定都会携带数据部分，例如<code>GET</code>请求。</p><p>在<strong>响应报文</strong>中，第一行称为响应行，分别由版本、状态码、短语组成。版本对请求报文相对应。状态码表示服务器对请求报文的处理结果，而短语便是对状态码简短的秒速。</p><p>状态码都是三位数：</p><ul><li>1xx表示通知信息，如请求收到了或正在进行处理。例如客户端发送请求报文中请求头携带：<code>Expect:100-Continue</code>，服务器一般要回复状态100的响应报文表示接受或者状态码417响应报文拒绝该报文。</li><li>2xx 表示成功，如接受了或知道了。常返回200表示成功。</li><li>3xx表示重定向，例如302重定向要Location的URL。</li><li>4xx表示客户端差错，例如404表示客户端请求的URL不存在。</li><li>5xx表示服务器差错。例如程序运行出异常。</li></ul><p>响应头部与请求头类似，由键值对组成，如常见的<code>Content-Encoding:gzip</code>,<code>Connection：keep-alive</code>。响应报文的最后部分便是响应数据，同样也有可能不存在。</p><hr><h3 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP/2</h3><p>HTTP/2 基于``SPDY`协议,客户端与服务器通信是全双工，意味着在建立连接后，不仅客户端可以请求服务器数据，服务器也可以主动推送信息到客户端。HTTP/1.1如果要并发请求，就需要建立多个TCP连接，就会消耗很多的资源，且大多数浏览器为了控制本地资源的使用情况会控制同个域名下TCP连接的数量。通过多路复用，所有通信都可以在单个连接完成，且无任何通信容量的限制。</p><p>在HTTP/2通信中建立起来的TCP连接就相当于一个流，每一个流都有自己的唯一标识符。而在流上交互的数据称为信息，由一个或多个二进制帧所组成，帧是通信的最小单元，帧最终在通信双方能按序组装成信息。</p><p>同时，在连接过程中，客户端和服务器会建立<code>首部表</code>来缓存请求头和响应头，避免每次请求都要携带重复的请求头信息，起到压缩头部作用。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210302225847.png" alt="image-20210302225847911"></p><p>在Android上，只要服务器支持，通过<code>OkHttp</code>已经完全可以支持HTTP/2.0了。</p><hr><p>HTTP/3 之前版本基于TCP，享受TCP提供的数据可靠性传输，也要承担其带来的副作用，例如三次握手，四次挥手导致的时延，流量控制，拥塞机制导致传输效率有限。HTTP/3将运输层使用的TCP改为UDP用户数据报，通过QUIC保证稳定性。</p><h2 id="ssltls"><a class="markdownIt-Anchor" href="#ssltls"></a> SSL\TLS</h2><p><strong>安全套接字层SSL</strong>协议作用在端系统应用层HTTP和运输层之间，在TCP之上建立一个安全通道，为通过TCP传输的应用层数据提供安全保障。而<strong>运输层安全TLS</strong>是SSL协议的升级版本。</p><p>SSL/TLS提供的安全服务：</p><ul><li>服务器鉴别，允许用户证实服务器的身份。通过服务器的证书来鉴别服务器身份和获得公钥。</li><li>客户鉴别，SSL的可选安全服务，允许服务器证实客户的身份。</li><li>加密的SSL会话，加密客户与服务器之间发送的所有信息。并检测报文是否被篡改。</li></ul><p><strong>工作简要流程</strong>：</p><ol><li><strong>协商算法</strong>。浏览器A向服务器B发送SSL的版本号和可选的加密算法。服务器B选择自己支持的算法（例如RSA），并告知A。</li><li><strong>服务器鉴别</strong>。服务器B向客户端A发送包含其RSA公钥的数字证书，客户端A使用发布该证书的认证机构CA公开发布的RSA公钥对B的数字证实进行验证。</li><li><strong>会话密钥计算</strong>。客户端A随机生成一个秘密数，用B的公钥加密后发送给B。双方根据协商的算法产生共享的对称会话密钥（即A和B分别用第一步确定的算法对秘密书进行计算生成会话密钥）。</li><li><strong>安全数据传输</strong>。双方用会话密钥生加密和解密传输数据并验证完整性。</li></ol><h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h2><p>在HTTP1.1以文本形式，HTTP2以二进制形式传输数据，但两者都是明文传输数据，HTTP2只需借助特定工具就能翻译能明文。因为传输数据被第三方盗取后，非常容易获取传输内容。因此需要对HTTP所传输的数据进行加密，例如采用DES,RSA等加密算法。</p><p>HTTPS是在HTTP的基础上，通过SSL/TLS层与运输层TCP通信。也就是说：HTTPS=HTTP+SSL\TLS。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210302231129.png" alt="image-20210302231129599"></p><p>HTTP与HTTPS的区别：</p><p>1、HTTPS协议需要到ca申请证书。</p><p>2、HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSl/TLS加密传输协议。</p><p>3、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p><h2 id="http缓存原理与机制"><a class="markdownIt-Anchor" href="#http缓存原理与机制"></a> HTTP缓存原理与机制</h2><p>通过本地缓存机制，客户端在请求数据时，不必每次都需要向服务器拉去数据，而是先检查本地缓存是否可用。这样非常有力的提高客户端的响应速度。HTTP的缓存存在两种类型：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><p>客户端可以在HTTP请求中使用的<code>Cache-Control</code>指令：</p><ul><li>max-age：缓存有效期，超过设置的时间表示该缓存已经过期。</li><li>max-stale：表明客户端愿意接收一个已经过期的资源。可以设置秒数，表示过期时长不能超过该秒数。</li><li>min-fresh：客户端希望获取一个能在指定的秒数内保持其最新状态的响应</li><li>no-cache：不缓存任何内容，包括请求报文和响应报文。</li><li>nostore：发送缓存前，需要与服务器协商缓存验证。</li><li>no-transform：不得对资源进行转换或转变。<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等HTTP头不能由代理修改</li><li>on-if-cached：表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。</li></ul><p>服务器可以在响应中使用的<code>Cache-Control</code>指令：</p><ul><li>must-revalidate：一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</li><li>no-cache：发送缓存前，需要与服务器协商缓存验证。</li><li>no-store：不缓存任何内容，包括请求报文和响应报文。</li><li>no-transform：不得对资源进行转换或转变。<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等HTTP头不能由代理修改。</li><li>public 可缓存指令，表示响应报文可以被任何对象缓存。</li><li>private 可缓存指令，表示响应报文只能被单个用户缓存，即客户端，不能作为共享缓存，例如代理服务器。</li><li>proxy-revalidate：与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</li><li>max-age：缓存有效期，超过设置的时间表示该缓存已经过期。</li><li>s-maxage：覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</li></ul><p>当服务器的响应报文请求头携带<code>max-age=xxx</code>，表示该报文数据在<code>xxx</code>秒服务器不会更改，意味着在这段时间，如果客户端请求了相同的数据，则直接从本地缓存取数据即可，并不需要向服务器拉取数据。这就是<strong>强制缓存</strong>。</p><p><strong>协商缓存</strong>指的是当<code>Cache-Control:no-cache</code>或者本地缓存超过<code>max-age=xxx</code>锁设置的时间，在获取本地缓存时，需要先将个缓存的标识<code>Etag</code>发给服务器，由服务器验证该数据是否过期失效。如果失效，则返回新数据的且状态码为200的响应报文；如果未失效，返回状态码304的响应报文，告诉客户端使用本地缓存。</p><p>关于协商缓存流程：</p><ul><li>第一次请求数据，响应报文会携带<code>Last-Modified</code>字段和<code>Etag</code>标识字段，表示该数据在服务器最后修改时间和唯一标识，客户会缓存该数据。</li><li>在再请求相同数据时，客户端请求报文请求头会携带<code>If-Modified-Since</code>的字段和<code>If-None-Match</code>字段，取值则分别是第一次服务器响应报文的<code>Last-Modified</code>和<code>Etag</code>的值。</li><li>服务器收到请求报文后，将<code>If-Modified-Since</code>的值与本地资源修改时间对比后。如果未被修改则返回状态码304的响应报文，否则返回状态码200的响应报文，并携带服务器修改后的本地资源。</li><li>客户端收到200的响应报文，则直接使用本地缓存。收到304的响应报文则使用报文中的数据，并缓存。</li></ul><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>相关参考资料</p><p><a href="https://zhuanlan.zhihu.com/p/27395037">https</a></p><p><a href="https://imququ.com/post/http2-resource.html">HTTP/2 资料汇总</a></p><p><a href="https://www.zhihu.com/question/34074946">HTTP/2 相比 1.0 有哪些重大改进？</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a></p><p>欢迎<strong>点赞+关注+评论三连击</strong></p><p>【<a href="https://github.com/xxm-sz">Github</a>】【<a href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a href="https://xxm-sz.github.io/">博客</a>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;本文主要是HTTP/1.1以及HTTP/2和HTTP/3的一些要点，版本的更新都是为了升级和迭代旧版本。HTTP一直在不停的优化升级，以提高带宽</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Compose 状态与组合</title>
    <link href="http://example.com/2021/03/04/Compose%E7%8A%B6%E6%80%81%E4%B8%8E%E7%BB%84%E5%90%88/"/>
    <id>http://example.com/2021/03/04/Compose%E7%8A%B6%E6%80%81%E4%B8%8E%E7%BB%84%E5%90%88/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-03-04T05:18:24.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>本文主要介绍的是，在Compose实际编程中，当数据发生变更后，怎么去刷新界面。Compose通过可观察的状态，来触发组合的重组。将状态的显示与状态的存储和更改解耦，通过观察者模式来驱动界面变化。</p><p>在<code>Android</code>的视图层次结构中，界面是通过一个个的<code>View</code>,例如<code>LinearLayout</code>、<code>TextView</code>等搭建而成，我们对其的修改，都是通过<code>findViewById</code>找到该<code>View</code>的引用后设置它的内部状态，例如设置<code>TextView</code>的文本。而Jetpack Compose是一个适用于<code>Android</code>的新式声明性工具包，那么组合与状态解耦之后，它们如何协作。或者简单说，在Compose中，我如何去更新<code>Text</code>的文本？</p><h2 id="三个概念"><a class="markdownIt-Anchor" href="#三个概念"></a> 三个概念</h2><p>学习<code>Compose</code>，我想应该要明白三个概念，即<strong>组合</strong>，<strong>状态</strong>，<strong>事件</strong>。组合是用于描述界面，通过可运行组合项生成。组合是描述界面的可组合项的树结构。应用中的状态是指可以随时间变化的任何值。例如动画，网络请求后的数据。事件由用户或程序产生，例如点击事件。在Compose中，状态与事件分开，状态表示可更改的值，而事件则表示有情况发生的通知。而将状态与事件分开，可以将状态的显示与状态的存储和更改方式解耦。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> count= remember{ mutableStateOf(<span class="number">0</span>) }</span><br><span class="line"></span><br><span class="line">Column() {</span><br><span class="line">    Button(onClick = { count.value++ }) {</span><br><span class="line">    }</span><br><span class="line">    Text(text = <span class="string">"<span class="subst">${count.value}</span>"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，将点击数状态与点击事件解耦后，点击数就可以单独拎出来，同时Text文本的点击数状态显示与其更改方式也解耦了。</p><p><code>remeber</code>可以用来存储单个对象，系统会在初始期存储由<code>remember</code>计算的值，并在重组时返回所存储的值。存储对象可以是可变对象，也可以是不可变对象。</p><h2 id="状态存储与更改"><a class="markdownIt-Anchor" href="#状态存储与更改"></a> 状态存储与更改</h2><p>通过<code>remember</code>存储可变对象时，会向可组合项添加内部状态。例如上一小节中就给Text设置一个单独的状态。<code>mutableStateOf</code>函数会创建可观察的<code>MutableState&lt;T&gt;</code>对象，是Compose运行时集成的可观察类型，同时还有它的父接口<code>State&lt;T&gt;</code>。Compose建议将状态设置为可观察的，这样当状态发生更改时，Compose可以自动重组界面。</p><p>除了``MutableState<t><code>来存储状态，我们也可以使用我们熟悉的</code>LiveData<code>,</code>Flow<code>,</code>RxJava`。</t></p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData= MutableLiveData&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> text <span class="keyword">by</span> liveData.observeAsState()</span><br></pre></td></tr></tbody></table></figure><p><code>observeAsState</code>函数是<code>LiveData</code>的扩展函数，将<code>LiveData</code>对象转化成<code>State</code>对象。</p><p><strong><code>Flow</code></strong></p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> value: String <span class="keyword">by</span> stateFlow.collectAsState()</span><br></pre></td></tr></tbody></table></figure><p><strong><code>RxJava</code></strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val completed by completable.subscribeAsState()</span><br></pre></td></tr></tbody></table></figure><p>Compose通过扩展函数，将已有框架的可观察类转化成<code>State&lt;T&gt;</code>对象，并由可组合函数读取，因此，我们可以通过扩展函数将自己的可观察类转化成<code>State&lt;T&gt;</code>对象。</p><p>如果需要手动触发重组，例如在从服务器获取数据的情况下，通过使用<code>currentRecomposeScope.invalidate()</code>。</p><h3 id="状态的提升"><a class="markdownIt-Anchor" href="#状态的提升"></a> 状态的提升</h3><p>状态的提升指的是一种将状态移至可组合项的调用方以使可组合项无状态的模式。一来调用方可以通过状态修改组合项，而不止是组合项自身调用。二来不同组合项可以复用同个状态。</p><p>状态提升一般是将状态变量替换成两个参数：</p><ul><li><strong><code>value: T</code></strong>：要显示的当前值</li><li><strong><code>onValueChange: (T) -&gt; Unit</code></strong>：请求更改值的事件，其中 <code>T</code> 是建议的新值。</li></ul><h2 id="重组"><a class="markdownIt-Anchor" href="#重组"></a> 重组</h2><blockquote><p>在初始组合期间，Jetpack Compose 将跟踪您为了描述组合中的界面而调用的可组合项。然后，当应用的状态发生变化时，Jetpack Compose 会安排重组。重组过程中会运行可能已更改的可组合项以响应状态变化，Jetpack Compose 会更新组合以反映所有更改。</p></blockquote><p>通过重组来刷新界面树中状态已经发生变化的微件。重组是智能的，系统会根据需要使用新数据重新绘制（组合函数发出的）微件，而不依赖新数据的（组合函数发出的）微件则不会被重绘。</p><p>在Compose编程中，也要注意到以下几点：</p><ul><li><p>可组合函数可以按任何顺序执行。意味着程序顺序一致性在可组合函数中是不存在，所以不能在Compose可组合函数设置某个全局变量，而是在它们调用方。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Column() {</span><br><span class="line">    Text(text = <span class="string">"我是Text1"</span>)</span><br><span class="line">    Text(text = <span class="string">"我是Text2"</span>)</span><br><span class="line">    Text(text = <span class="string">"我是Text3"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例如这里的三个Text，并不是一定先调用了Text1,再调用Text2,再到Text3函数，它们可能是乱序调用。但它们最终的组合顺序还是被<code>Column</code>布局一样，分别从上到下。</p></li><li><p>可组合函数可以并发执行。意味着Compose可以利用CPU多核心功能，通过并行运行可组合函数来优化重组。</p></li><li><p>重组会跳过尽可能多的内容。Compose会尽力只重组需要更新的部分，也就是会跳过尽可能多的可组合项。每个可组合函数和lambda都可以自行重组。</p></li><li><p>可组合函数可能会非常频繁运行</p><p>在某些情况下，可能对针对界面动画的每一帧运行一个可组合函数。如果在改组合函数执行成本高昂的操作（例如网络请求，从文件读取数据），可能会造成界面卡顿。所以应该将成本高昂的操作迁移到其他线程，在通过<code>ViewModel</code>或<code>LiveData</code>将数据传递给可组合函数。</p></li></ul><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>本文来自<a href="https://developer.android.com/jetpack/compose/state?hl=zh-cn#use-other-types-of-state-in-jetpack-compose">官方文档</a>的状态与组合资料的学习，同时由于版本的升级，一些信息已经变更，需要参考<a href="https://developer.android.com/jetpack/androidx/releases/compose-foundation?hl=zh-cn#1.0.0-alpha11">文档更新记录</a></p><p>欢迎<strong>点赞+关注+评论三连击</strong></p><p>【<a href="https://github.com/xxm-sz">Github</a>】【<a href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a href="https://xxm-sz.github.io/">博客</a>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;本文主要介绍的是，在Compose实际编程中，当数据发生变更后，怎么去刷新界面。Compose通过可观察的状态，来触发组合的重组。将状态的显示与</summary>
      
    
    
    
    <category term="Jetpack" scheme="http://example.com/categories/Jetpack/"/>
    
    
    <category term="Jetpack Compose" scheme="http://example.com/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp的使用</title>
    <link href="http://example.com/2021/03/02/OkHttp%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/03/02/OkHttp%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-01T16:00:00.000Z</published>
    <updated>2021-03-02T02:18:37.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>本文是介绍<code>OKHttp</code>的简单使用。<code>OkHttp</code>目前作为Android网络请求的主力框架，学习和深入<code>OkHttp</code>是非常必要的。目前<code>OkHttp</code>已经更新到<code>4.9.0</code>版本，从<code>4.0</code>版本开始已经采用<code>Kotlin</code>开发，充分利用了<code>Kotlin</code>的特性，如扩展函数，所以与以前版本的使用有一点区别，但框架和思路是没有变化的。本文简单的介绍的<code>GET</code>、<code>POST</code>请求，图片上传还有图文上传的使用，是作为<code>OkHttp</code>系列文章的开篇。</p><h2 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h2><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># okhttp 4.9版本的依赖</span><br><span class="line">implementation(<span class="string">"com.squareup.okhttp3:okhttp:4.9.0"</span>)</span><br><span class="line">#网络请求日志拦截器</span><br><span class="line">implementation(<span class="string">"com.squareup.okhttp3:logging-interceptor"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="入门与使用"><a class="markdownIt-Anchor" href="#入门与使用"></a> 入门与使用</h2><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder().url(<span class="string">"http://192.168.1.151:8080/get"</span>).<span class="keyword">get</span>().build()</span><br></pre></td></tr></tbody></table></figure><h3 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread(start = <span class="literal">true</span>) {</span><br><span class="line">    client.newCall(request).execute().use {</span><br><span class="line">        Log.d(TAG, it.body?.string()?:<span class="string">"null"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).enqueue(<span class="keyword">object</span> : Callback {</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> {</span><br><span class="line">        Log.d(TAG, e.message!!)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> {</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.tv).text = response.body.string()</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="request"><a class="markdownIt-Anchor" href="#request"></a> Request</h3><p>通过<code>Request.Builder</code>,可以设置网络网络请求的<code>url</code>,<code>method</code>,<code>headers</code>,<code>tag</code>,<code>body</code>，其中<code>tag</code>主要用于跟踪该请求状态，方便debug等。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .tag(<span class="string">"test"</span>)<span class="comment">//添加标签</span></span><br><span class="line">        .addHeader(<span class="string">"token"</span>,<span class="string">"xxm-sz"</span>)<span class="comment">//添加请求头</span></span><br><span class="line">        <span class="comment">//headers会清空之前已设置的header,例如token会被清空</span></span><br><span class="line">        .headers(Headers.Builder().add(<span class="string">"accept-encoding"</span>,<span class="string">"application/json"</span>).build())</span><br><span class="line">        .url(<span class="string">"http://192.168.1.151:8080/get"</span>)<span class="comment">//请求地址</span></span><br><span class="line">        .<span class="keyword">get</span>()<span class="comment">//请求方法</span></span><br><span class="line">        .build()</span><br></pre></td></tr></tbody></table></figure><p>如果自定义请求头与默认的相同，则默认的请求头会被修改。下面是Post请求，<code>RequestBody</code>相对于Java语言而言，大多数方法被声明为扩展函数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val requestBody="data".toRequestBody(null)</span><br><span class="line"></span><br><span class="line">val postRequest = Request.Builder()</span><br><span class="line">        .url("http://192.168.1.151:8080/post")</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build()</span><br></pre></td></tr></tbody></table></figure><p>图片上传：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file=File(<span class="string">"/storage/emulated/0/Download/Screenshot_1614074735.png"</span>)</span><br><span class="line"><span class="keyword">val</span> fileBody=file.asRequestBody()</span><br><span class="line"><span class="keyword">val</span> filePart=MultipartBody.Builder().addFormDataPart(body = fileBody,name = <span class="string">"image"</span>,filename =<span class="string">"test.png"</span>).build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fileRequest = Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://192.168.1.151:8080/file"</span>)<span class="comment">//请求地址</span></span><br><span class="line">        .post(filePart)</span><br><span class="line">        .build()</span><br></pre></td></tr></tbody></table></figure><p>文件与参数上传：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadFileAndParams</span><span class="params">(url: <span class="type">String</span>,filePath: <span class="type">String</span>,paramsMap:<span class="type">HashMap</span>&lt;<span class="type">String</span>,String&gt;,callback: <span class="type">HttpCallback</span>)</span></span>{</span><br><span class="line">    <span class="keyword">val</span> builder=MultipartBody.Builder().setType(MultipartBody.FORM)</span><br><span class="line">    <span class="keyword">val</span> file = File(filePath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.exists() || file.isDirectory) {</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">"the file isn't exit or is directory"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileBody = file.asRequestBody()</span><br><span class="line">    builder.addFormDataPart(body = fileBody, name = <span class="string">"image"</span>, filename = <span class="string">"test.png"</span>).build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">in</span> paramsMap){</span><br><span class="line">        builder.addFormDataPart(entry.key,entry.value)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">val</span> fileRequest = Request.Builder()</span><br><span class="line">        .url(<span class="string">"<span class="subst">${baseUrl}</span><span class="subst">${url}</span>"</span>)<span class="comment">//请求地址</span></span><br><span class="line">        .post(builder.build())</span><br><span class="line">        .build()</span><br><span class="line">    realRequest(fileRequest,callback)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span>  <span class="title">realRequest</span><span class="params">(request: <span class="type">Request</span>, callback: <span class="type">HttpCallback</span>)</span></span> {</span><br><span class="line">    httpCient.newCall(request).enqueue(<span class="keyword">object</span> : Callback {</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> {</span><br><span class="line">            callback(<span class="literal">false</span>, <span class="literal">null</span>, <span class="string">"call:<span class="subst">${call.request().url}</span>,error:<span class="subst">${e.message}</span>"</span>)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> {</span><br><span class="line">            <span class="keyword">if</span> (response.code == <span class="number">200</span>) {</span><br><span class="line">                callback(<span class="literal">true</span>, response.body?.string(), response.message)</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                callback(<span class="literal">false</span>, <span class="literal">null</span>, <span class="string">"call:<span class="subst">${call.request().url}</span>,error:<span class="subst">${response.message}</span>"</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;本文是介绍&lt;code&gt;OKHttp&lt;/code&gt;的简单使用。&lt;code&gt;OkHttp&lt;/code&gt;目前作为Android网络请求的主力框架，学习</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="OkHttp" scheme="http://example.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>网络层IP、ARP、RIP、OSPF</title>
    <link href="http://example.com/2021/03/01/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/03/01/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-03-01T04:31:45.946Z</updated>
    
    <content type="html"><![CDATA[<p>网络层负责主机到主机的逻辑通信，而端到端系统的逻辑通信交给了运输层。网络层对运输层只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。也就是说网络层不提供可靠的数据交付服务保证。</p><p>网络层主要存在四个协议：IP,ARP,ICMP,IGMP</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223124010.png" alt="image-20210223124010575"></p><p><strong>网际协议IP</strong>: 是TCP/IP体系中两个最主要的协议之一。是网络层为运输层提供的数据运输的基础。</p><p><strong>地址解析协议ARP</strong>：将网络的层的IP地址转化为链路层的硬件地址。</p><p><strong>网际控制报文协议ICMP</strong>：允许主机或路由器报告网络的状态，有效提高分组的到达率。</p><p><strong>路由选择协议</strong>：解决分组如何从一台主机到另外一台主机的过程。<strong>RIP</strong>基于距离选择的AS内部路由选择协议，根据距离来选择分组下一跳路由器；<strong>OSPF</strong>基于链路状态选择的AS内部路由选择协议，基于链路的代价（距离，费用，耗时等等）来选择路由；<strong>BGP</strong>基于向量距离选择的AS之间的路由选择协议。</p><h2 id="一-ip协议"><a class="markdownIt-Anchor" href="#一-ip协议"></a> 一、IP协议</h2><h3 id="ip地址的三种编址方法历史阶段"><a class="markdownIt-Anchor" href="#ip地址的三种编址方法历史阶段"></a> IP地址的三种编址方法（历史阶段）</h3><ul><li>分类IP地址</li><li>子网划分</li><li>构成超网</li></ul><h3 id="分类地址"><a class="markdownIt-Anchor" href="#分类地址"></a> 分类地址</h3><p>网络号标识当前主机（或路由器）所连接到的网络，一个网络号在整个互联网是唯一。主机号则代表当前主机在所连接的网络是是唯一的。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210224101705.png" alt="image-20210224101658424"></p><p>其中ABC类地址是最常用的单播地址。（其实目前大多数使用无分类IP地址进行路由选择）</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210224101910.png" alt="image-20210224101910179"></p><p>从IP地址的前四位默认分配可以快速定位该IP地址的类别，例如128开头的B类地址，192开始C类地址</p><p>判断多台主机是否在同个网络的依据网络号相同，通过桥接，转发器连接的网络还是在同个网络中。</p><h3 id="子网"><a class="markdownIt-Anchor" href="#子网"></a> 子网</h3><p>说到底，就是分类地址的基础上，借用主机号的若干位数来划分网络，形成内部的网络。对外来说，分组还是到达网络号还在网络，再到子网，最后到主机。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225103005.png" alt="image-20210225103005869"></p><p>从分组的目的地址和源地址是无法区分是否划分子网。需要借助子网掩码。</p><h3 id="无分类编址超网cidr"><a class="markdownIt-Anchor" href="#无分类编址超网cidr"></a> 无分类编址（超网，CIDR）</h3><p>从子网的三级编址又回到二级编制，只是不再分类罢了。</p><ul><li>消除分类地址和子网划分；</li><li>网络前缀相同的连续IP地址组成“CIDR地址块”，可以计算出最大、最小IP地址；</li><li>同样存在掩码，但不存在子网。但分配到CIDR地址的单位可以自己划分子网，也就是单位内部的网络前缀大于分配到的CIDR地址前缀；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225113153.png" alt="image-20210225113153793"></p><p>路由表中利用CIDR地址块来查找目的网络，即<strong>路由聚合</strong>（构成超网）。意味着路由表的记录条目变小，因为一个记录相比原有代替了一整块IP地址。</p><p>路由表每个项目由网络前缀和下一跳地址组成，匹配结果应该选择最长的网络前缀路由，即<strong>最长前缀网络匹配</strong>，即前缀越长，地址越少，目的地址越具体。二叉线索查找路由表，将IP地址32位从左到右，按位与树的度进行查找，左0右1，如果有匹配的路径，所以存在该前缀，再与对应的掩码按位与得出网络前缀N，如果N与目的地址网络前缀一致，说明找到下一跳地址。</p><h3 id="ip数据包格式"><a class="markdownIt-Anchor" href="#ip数据包格式"></a> IP数据包格式</h3><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210224112437.png" alt="image-20210224112437735"></p><ul><li><p><strong>版本</strong>：IP协议版本，通信双方IP协议版本必须一致，例如IPv4,IPv6</p></li><li><p><strong>首部长度</strong>：占4位，最大代表十进制15，单位为32位字长，即4个字节，所有首部最长60个字节。首部固定部分20个字节，所以该字段最小值5。首部长度不是4字节整数倍，需要通过填充字段加入填充。</p></li><li><p><strong>总长度</strong>：包括首部和数据部分， 16位，单位为字节，2^16-1字节。但不能超过链路层的MTU值，例如互联网MTU=1500字节，否则需要进行分片处理。分片后的总长度指的新的分组总长度。</p></li><li><p><strong>标识</strong>：数据包分片后，具有相同的标识，用于重装会数据报。</p></li><li><p><strong>标志</strong>： 3位，最低位标识MF=1表示还有分片；中间位DF=0表示允许分片。</p></li><li><p><strong>片偏移</strong>：数据报在分片后，在原数据报的的偏移，片偏移以8个字节为单位，即每个分片分组是8字节数的整数倍。</p></li><li><p><strong>生存时间</strong>：或跳数限制，在发送方设置，每经过路由器，则减1，小于零则丢弃该分组。</p></li><li><p><strong>协议</strong>：协议字段支出该分组携带的数据属于何种协议，让网络层知道如何上交给运输层的何种协议。</p></li><li><p><strong>首部检验和</strong>：只检验首部，不检验数据部分。每经过路由器，都需重新计算检验和。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225094743.png" alt="image-20210225094736211"></p></li></ul><h3 id="路由器分组转发算法"><a class="markdownIt-Anchor" href="#路由器分组转发算法"></a> 路由器分组转发算法</h3><ol><li>从分组提取目的IP地址D，得出目的网络地址N;</li><li>若N是与路由器直接相连的网络地址，则直接交付目的主机，否则间接交付，下一步；</li><li>若路由表有的目的地址D,则将分组交给路由器所指明的下一跳路由器，否则下一步；</li><li>若路由表有到达网络N的路由，则将分组交给路由器所指明的下一跳路由器，否则下一步；</li><li>若路由表有默认路由，则将分组交给路由器所指明的默认路由，否则下一步；</li><li>报告分组出错。</li></ol><h2 id="二-地址解析协议arp"><a class="markdownIt-Anchor" href="#二-地址解析协议arp"></a> 二、地址解析协议ARP</h2><p>从网络层使用的IP地址，解析出数据链路层的使用的硬件地址。在主机的ARP高速缓存总存放着一个从IP地址到硬件地址的映射表。</p><p>映射表数据填充：</p><p>1、查询主机的ARP进程在局域网广播ARP请求分组</p><p>2、其他主机的ARP进程收到该请求分组，如果收到的请求分组携带的查询IP地址一致，则将自身的硬件地址写入到ARP响应分组中，并发送给查询主机；同时会将查询主机的硬件地址插入到自己的映射表中。否则忽略该分组</p><p>3、查询主机收到响应分组，则将硬件地址插入到映射表中。</p><p>每个映射表每条记录都有一个生存时间，超过该时间未使用，则会被删除。</p><p>其实所有的分组都需要经过路由器进行转发的，不在同个局域网的寻址就交个路由器进行寻址。</p><h2 id="三-icmp网际控制报文协议"><a class="markdownIt-Anchor" href="#三-icmp网际控制报文协议"></a> 三、ICMP网际控制报文协议</h2><p>允许主机或路由器报告差错情况和提供有关异常情况的报告，更有效转发IP分组和提高交付成功机会。ICMP作为分组数据部分被传递。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225165549.png" alt="image-20210225165549591"></p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225165701.png" alt="image-20210225165701465"></p><h3 id="差错报告报文"><a class="markdownIt-Anchor" href="#差错报告报文"></a> 差错报告报文</h3><ul><li><strong>终点不可达</strong>：当路由器或主机不能交付分组时则向源点发送终点不可达报文。</li><li><strong>时间超过</strong>：当路由器收到生存时间为零的分组需要向源点发送时间超过报文，并丢弃该分组。</li><li><strong>参数问题</strong>：当路由器或者目的主机收到分组首部有字段值不正确，需要向源点发送参数问题报文，并丢弃该分组。</li><li><strong>改变路由（重定向）</strong>：路由器吧改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。</li></ul><p>差错报告报文的数据部分：分组的首部+分组数据部分前8个字节（运输层的目的端口和源端口，序号）</p><h3 id="询问报文"><a class="markdownIt-Anchor" href="#询问报文"></a> 询问报文</h3><ul><li><p><strong>回送请求和回答</strong>： 回送请求报文是主机或路由器向特定的目的主机发出的询问报文，收到报文的主机需要回送回答报文。用来测试目的站是否可达以及相关状态。</p></li><li><p><strong>时间戳请求和回答报文</strong>： 请某台主机或路由器回答当前日期和时间。用于时钟同步和时间测量。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225173124.png" alt="image-20210225173124635"></p></li></ul><h2 id="四-路由选择协议"><a class="markdownIt-Anchor" href="#四-路由选择协议"></a> 四、路由选择协议</h2><p>计算路由器中路由表的各项目。</p><h3 id="分层次的路由选择协议"><a class="markdownIt-Anchor" href="#分层次的路由选择协议"></a> 分层次的路由选择协议</h3><p>互联网把路由选择协议划分两大类：</p><ul><li><p><strong>内部网关协议IGP</strong>：自治系统内部使用的路由选择协议，与其它自治系统无关，例如RIP，OSPF协议</p></li><li><p><strong>外部网关协议EGP</strong>：若源主机和目的主机在不同的自治系统中，不同自治系统的边界就需要使用该协议将路由选择信息传递给对方。例如BGP-4协议。</p></li></ul><h3 id="内部网关协议rip"><a class="markdownIt-Anchor" href="#内部网关协议rip"></a> 内部网关协议RIP</h3><p>RIP是一种分布式的基于距离向量的路由选择协议。RIP协议维护从自己到其他目的网络的距离记录，也称为跳数，每经过一个路由器距离加1，RIP允许一条路径最长15，超过即不可达，因此只适合在小型网络。那么RIP协议就是在记录中找到最短距离的路径。RIP协议和下文的OSPF协议都需要和其他路由器交互路由信息。</p><p>RIP协议特点：</p><ul><li>仅和相邻路由器交换信息。</li><li>交换信息为当前路由器所知道的全部信息，即自己现在的路由表。</li><li>按固定的时间间隔交换路由器信息。</li></ul><p>通过路由信息的交换，可以得出到达本自治系统中任何一个网络的最短距离和下一跳路由地址。这种路由交换信息页称为<strong>距离向量算法</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210225182347.png" alt="image-20210225182347527"></p><h3 id="内部网关协议ospf"><a class="markdownIt-Anchor" href="#内部网关协议ospf"></a> 内部网关协议OSPF</h3><p><strong>开发最短路径优先OSPF</strong>是基于Dijkstra提出的<strong>最短路径算法PSF</strong>，使用分布式的<strong>链路状态协议</strong>。</p><ul><li>使用洪泛法向本自治系统中所有路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，链路状态指出相邻的路由器和该链路的度量，例如费用、距离、时延、带宽等等。</li><li>只有链路状态发生变化，路由器才使用洪泛法向所有路由器发送此信息。</li></ul><p>通过频繁的交换链路状态信息，每个路由器都能建立起链路状态数据库，也是全网的拓扑图。相比RIP,器链路状态能更快的更新，以及知道自治系统的主机数，之间链路的代价。</p><p>采用层次结构的区域划分来限制一个较小范围的链路状态信息库，避免每次广播整个自治系统。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210226163148.png" alt="image-20210226163148632"></p><p>OSPF直接使用IP数据报传送，作为IP数据报的数据部分，此时IP数据报协议字段为89。分组使用24字节的固定长度。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210301102527.png" alt="image-20210301102520551"></p><ul><li><p><strong>版本</strong>：当前版本号2；</p></li><li><p><strong>类型</strong>：五种类型分组的一种。</p><ul><li><strong>类型1</strong>：问候分组，用来发现和维持领站的可达性。每10秒就要交换1次，确认链路可达，若40秒未收到问候分组，则认为不可达。</li><li><strong>类型2</strong>：数据库描述分组，向领站给出自己的链路状态数据库的全部链路状态项目的摘要信息。</li><li><strong>类型3</strong>：链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。</li><li><strong>类型4</strong>：链路状态更新分组，用洪泛方对全网更新链路状态。OSPF协议的核心部分，也是最浮渣的。</li><li><strong>类型5</strong>：链路状态确认分组，对链路更新分组的确认。</li></ul></li><li><p><strong>分组长度</strong>：包括首部在内的分组长度，字节为单位。</p></li><li><p><strong>路由器标识符</strong>: 标志发送该分组的路由器的接口的IP地址。即源地址的IP地址了。</p></li><li><p><strong>区域标识符</strong>：分组所属区域的标识符。</p></li><li><p><strong>校验和</strong>：用来检测分组的差错。</p></li><li><p><strong>鉴别类型</strong>： 只有两只0（不用）或1（口令）。</p></li><li><p><strong>鉴别</strong>：鉴别类型0就填0,1则填8个字符的口令。</p></li></ul><h3 id="外部网关协议bgp"><a class="markdownIt-Anchor" href="#外部网关协议bgp"></a> 外部网关协议BGP</h3><p><strong>边界网关协议BGP</strong>主要应用在不同自治系统之间的中间路由选择协议，而RIP和OSPF则是应用在自治系统内部的。</p><p>BGP力求寻找一条能够到达目的网络的且比较好的路由，而并非要找一条最佳路由。采用了路径<strong>向量路由器选择协议</strong>。</p><p>自治系统的管理人员需要配置至少一个路由器作为该系统的”BGP发言人“。通过发言人与其它AS的发言人通过TCP连接交互BGP报文，建立起BGP会话后交换路由信息。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210301112132.png" alt="image-20210301112132805"></p><p>BGP分组有19个字节的首部，基于TCP数据报传输，作为TCP数据报的数据部分。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210301112659.png" alt="image-20210301112659615"></p><h2 id="五-ip多播"><a class="markdownIt-Anchor" href="#五-ip多播"></a> 五、IP多播</h2><p>采用IP多播，即一对多广播，可显著减轻网络中各种资源的消耗。D类IP一个地址代表一个多播组，且多播地址作用于目的地址，不能是源地址。多播路由器指的是支持转发和复制多播分组的路由器。</p><h3 id="网际组管理协议igmp"><a class="markdownIt-Anchor" href="#网际组管理协议igmp"></a> 网际组管理协议IGMP</h3><p>IGMP协议让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出某个多播组。</p><p>工作阶段：</p><ul><li>当某台主机加入新的多播组时，向该多播组的多播地址发送广播，声明加入该广播组。本地多播路由器接收到ICMP报文后，还需要通过多播路由选择协议转发到其他网络上的多播路由器。</li><li>组成员关系是动态的。本地多播路由器要周期探寻本地局域网上的主机，确定是否还有成员参加多播。只要接收一个相应，认为该多播组是活跃的。</li></ul><p>具体措施：</p><ol><li>主机和多播路由器之间所有通信都是IP多播；尽力采用硬件多播，这样没有参加多播的主机就接收不到IGMP报文。</li><li>多播路由器在探询成员关系，只需要对所有的组发送一个请求信息的询问报文。而不需要对每一个组发送一个询问报文。且间隔125秒一次。</li><li>若一个网络多个多播路由器时，选择一个探询主机的成员关系。</li><li>询问报文中有一个数值N,指明最长响应时间。收到询问报文的主机，应该在0和N之间随机选择发送响应所需经过的时延，对最小时延的响应应该最先发送。</li><li>同个组内的每一台主机都要监听响应，只要本组其他主机先发送了响应，就不再发响应。</li></ol><h3 id="多播路由选择协议"><a class="markdownIt-Anchor" href="#多播路由选择协议"></a> 多播路由选择协议</h3><p>在多播过程一个多播组中的成员是动态变化的。多播路由选择就是要找出以源主机为根节点的多播转发树。在多播转发树是哪个，每一个多播路由器向树的叶节点向方向转发收到的多播分组，但转发树上的路由器不会收到重复的多播分组。</p><p>常见的多播路由选择协议常用一下三种方法来转发多播数据报：</p><ul><li><strong>洪泛与剪除</strong>：使用较小多播组，所以成员接入的局域网也是相邻的。路由器转发分组采用洪泛的方法，采用<strong>反向路径广播RPB</strong>来判断该多播分组是否从原点径最短路径转发而来，如果是在，则转发给其他路由器，不是则丢弃。从而得出多播组的多播转发树。最后如果某个路由器发现下游树枝已经没有该多播组的成员，则把自身和下游的树枝剪除。</li><li><strong>隧道技术</strong>：使用与多播组的位置比较分散的情况。即两个支持多播组的网络之间隔着不支持多播组的网络，将多播分组封装成普通的单播数据报，发送到目的网络。</li><li><strong>基于核心的发现技术</strong>：适合多播组大小在较大范围内发送变化的情况。为多播组指定核心路由器，给出它IP单播地址。核心路由器通过<strong>洪泛</strong>得出多播转发树。其他路由器发往核心路由器的数据报都要被经过的路由器检查。在这个过程中，如果经过是参加了多播组的路由器接收到，路由器就会处理该数据报。如果是该数据报是该多播组的多播数据报，则会进行转发；如果是加入该多播组的请求数据报，则加入到自己的路由中，后续通过<strong>隧道技术</strong>向该数据报的源路由转发该多播组的数据报。</li></ul><h2 id="六-多协议标记交互mpls"><a class="markdownIt-Anchor" href="#六-多协议标记交互mpls"></a> 六、多协议标记交互MPLS</h2><p>多协议意味着上层可以采用多种协议。利用面向连接技术，使每个分组携带一个叫做标记的小整数。当分组到达交换机时，交换机读取分组标记，并用标记值来检索分组转发表。比查找路由转发表快得多。</p><p>在MPLS域入口给分组打上固定长度的标记，在链路层通过硬件转发，在域出口去除标记。</p><h3 id="工作过程"><a class="markdownIt-Anchor" href="#工作过程"></a> 工作过程</h3><p>MPLS域中所有路由器都支持MPLS技术，故称为标记交换路由器LSR,同时具有标记转换和路由选择功能。</p><ul><li>LSR使用标记分配协议LDP交换报文，并找出和特定路径相对应的路径：标记交换路径LSP。根据这些标记和路径构造出转发表。</li><li>域入口结点给外部到来的IP数据报打上标记，并按照转发表转发给下个LSR。</li><li>一个标记仅在两台LSR之间才有意义，LSR对分组所做的就是：转发和更换新的标记。</li><li>域出口结点把数据报的标记去除，交付给其他主机或路由器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210226144941.png" alt="image-20210226144940982"></p><p><strong>转发等价类FEC</strong></p><p>路由器按照同样方式对待的IP数据报的集合。即从同样的接口转发到同样的下一跳地址，并且具有同样服务类型和同样丢弃优先级等。</p><p>FEC例子：</p><ul><li>目的IP地址与某一特定IP地址的前缀匹配的IP数据报</li><li>所有源地址与目的地址都相同的数据报</li><li>具有某种服务质量的IP数据报</li></ul><p>在MPLS情况下，将属于同样的FEC的IP数据报都指定同样的标记，从而走其他路径到达目的网络，而不止是最短路径，可以使网络负载较为均衡，更好管理网络资源，这种做法也称为<strong>流量工程TE</strong>或<strong>通信量工程</strong>。</p><h3 id="mpls位置与首部格式"><a class="markdownIt-Anchor" href="#mpls位置与首部格式"></a> MPLS位置与首部格式</h3><p>MPLS首部位于数据链路层和网络层之间，在IP数据报首部前，MAC帧首部之后插入4个字节的MPLS首部。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210226143206.png" alt="image-20210226143206895"></p><ul><li><strong>标记值</strong>：通常需要管理员人工管理和设置每条交换路径</li><li><strong>试验</strong>： 保留用于试验</li><li><strong>栈S</strong>: 有标记栈的时候使用</li><li><strong>生存时间TTL</strong>: 防止分组兜圈子。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络层负责主机到主机的逻辑通信，而端到端系统的逻辑通信交给了运输层。网络层对运输层只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。也就是说网络层不提供可靠的数据交付服务保证。&lt;/p&gt;
&lt;p&gt;网络层主要存在四个协议：IP,ARP,ICMP,IGMP&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络层" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Compose ConstraintLayout 详讲</title>
    <link href="http://example.com/2021/02/28/ConstraintLayout/"/>
    <id>http://example.com/2021/02/28/ConstraintLayout/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T06:34:49.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介与依赖"><a class="markdownIt-Anchor" href="#简介与依赖"></a> 简介与依赖</h2><p><code>Compose ConstraintLayout</code>约束布局主要应用在构建复杂布局，避免使用<code>Column</code>、<code>Row</code>、<code>Box</code>多层嵌套，同时也能提高开发效率。</p><p>开始使用之前需要添加对<code>ConstraintLayout</code>的依赖：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha03'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>需要注意的</strong>：截止本文发稿，<code>Compose</code>和<code>Constraintlayout</code>都还没有到稳定版本，所以对相关库的依赖一定都要更新到最新版本(或者相适配版本)，不然可能存在不兼容问题。</p><p>查看<code>ConstraintLayout</code>的<a href="https://github.com/androidx/constraintlayout">最新地址</a></p><h2 id="入门与深入"><a class="markdownIt-Anchor" href="#入门与深入"></a> 入门与深入</h2><h3 id="引用创建"><a class="markdownIt-Anchor" href="#引用创建"></a> 引用创建</h3><p>在<code>View</code>系统的<code>ConstraintLayout</code>在<code>xml</code>布局中，需要通过id进行相关引用，在<code>Compose</code>也是类似的。通过<code>createRefs</code>函数或<code>createRef</code>函数为不同的<code>View</code>预定一个引用。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="绑定引用"><a class="markdownIt-Anchor" href="#绑定引用"></a> 绑定引用</h3><p>将通过<code>constrainAs</code>函数将引用与<code>View</code>绑定，相当于给<code>View</code>赋值了一个<code>id</code>。另外,<code>constarinAs</code>有时在编写代码并不能自动提示，需要自己手刃代码哦。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">        </span><br><span class="line">        Image(painter = painterResource(id = puppy.avatar),</span><br><span class="line">                contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .constrainAs(avatar) {}<span class="comment">//通过constrainAs将Image与imageRef绑定</span></span><br><span class="line">                    .size(<span class="number">100.</span>dp)</span><br><span class="line">                    .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">                contentScale = ContentScale.Crop)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>linkTo</code>函数将<code>view</code>与其他<code>view</code>或者<code>parent</code>约束。这里的<code>parent</code>指的就是<code>ConstraintLayout</code>本身。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">        </span><br><span class="line">        Image(painter = painterResource(id = puppy.avatar),</span><br><span class="line">                contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .constrainAs(avatar) {</span><br><span class="line">                    top.linkTo(parent.top)</span><br><span class="line">                    start.linkTo(parent.start)</span><br><span class="line">                    end.linkTo(parent.end)</span><br><span class="line">                    bottom.linkTo(parent.bottom)</span><br><span class="line">                    }<span class="comment">//通过constrainAs将Image与imageRef绑定,并增加约束</span></span><br><span class="line">                    .size(<span class="number">100.</span>dp)</span><br><span class="line">                    .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">                contentScale = ContentScale.Crop)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>constrainAs</code>函数中的<code>start</code>、<code>top</code>、<code>end</code>、<code>bottom</code>分别代表<code>view</code>的左、上、右、下四条边，<code>linkTo</code>表示相互作用。例如代码中的<code>top.linkTo(parent.top)</code>表示<code>Image</code>的顶边和<code>ConstraintLayout</code>的顶边对齐，和<code>view</code>系统中的<code>layout_constraintTop_toTopOf="parent"</code>是一致。接下来再增加两个<code>Text</code>。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">        <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">        <span class="keyword">val</span> (imageRef, nameRef, descRef) = createRefs()</span><br><span class="line"></span><br><span class="line">        Image(painter = painterResource(id = R.mipmap.dog_avatar),</span><br><span class="line">            contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .constrainAs(imageRef) {<span class="comment">//通过constrainAs将Image与imageRef绑定,并增加约束</span></span><br><span class="line">                    top.linkTo(parent.top)</span><br><span class="line">                    start.linkTo(parent.start)</span><br><span class="line">                    bottom.linkTo(parent.bottom)</span><br><span class="line">                }</span><br><span class="line">                .size(<span class="number">100.</span>dp)</span><br><span class="line">                .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">            contentScale = ContentScale.Crop)</span><br><span class="line"></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">"名称"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .constrainAs(nameRef) {</span><br><span class="line">                    top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">                    start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">                    end.linkTo(parent.end)</span><br><span class="line">                    width = Dimension.fillToConstraints</span><br><span class="line">                }</span><br><span class="line">                .fillMaxWidth(),</span><br><span class="line">            fontSize = <span class="number">18.</span>sp,</span><br><span class="line">            maxLines = <span class="number">1</span>,</span><br><span class="line">            textAlign = TextAlign.Left,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Text(text = <span class="string">"描述"</span>, modifier = Modifier</span><br><span class="line">            .constrainAs(descRef) {</span><br><span class="line">                top.linkTo(nameRef.bottom, <span class="number">5.</span>dp)</span><br><span class="line">                start.linkTo(nameRef.start)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                width = Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">            .fillMaxWidth(),</span><br><span class="line">            maxLines = <span class="number">1</span>,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">            style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面代码中，在<code>ConstrantLayout</code>中创建了<code>Image</code>和两个<code>Text</code>组件。在<code>Text</code>的约束，通过<code>start.linkTo(imageRef.end, 12.dp)</code>约束条件，将<code>nameRef Text</code>位与<code>Image</code>的右边，并增加了12dp的<code>margin</code>。</p><h3 id="约束尺寸"><a class="markdownIt-Anchor" href="#约束尺寸"></a> 约束尺寸</h3><p>注意到，给<code>Text</code>的宽度增加了<code>width = Dimension.fillToConstraints</code>约束，让<code>Text</code>文本过长时，不超出约束条件。</p><p>例如，默认情况下：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将nameRef Text的约束改成下面代码</span></span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称是否是否所发生的方法是否是否"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>通过效果图看到，Text文本过长时不仅超过了<code>ConstraintLayout</code>，还超出了屏幕。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228101824.png" alt="image-20210228101817679"></p><p>将代码改成如下：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称是否是否所发生的方法是否是否"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            end.linkTo(parent.end,<span class="number">12.</span>dp)</span><br><span class="line">            width=Dimension.fillToConstraints</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228102243.png" alt="image-20210228102243362"></p><p><code>Dimension</code>取值如下：</p><ul><li><p><strong><code>fillToConstraints</code></strong> 填充约束条件下所剩的可用空间，如上面例子。</p></li><li><p><strong><code>preferredWrapContent</code></strong> 内容自适应，但受约束条件影响，也就是说，当宽小于约束条件下可用的宽时，则view的宽就是自身的宽，但大于的时候，则受约束条件影响。高也是如此。</p><p>例如：小于约束所剩宽时：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称负少测试赛"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            width=Dimension.preferredWrapContent</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图:</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228103814.png" alt="image-20210228103814863"></p><p>增加文本内容，增加右边与<code>parent</code>对齐。通过效果图，可见文本换行处理。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称负少发发发发发发付付付付付付测试赛"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            end.linkTo(parent.end)</span><br><span class="line">            width=Dimension.preferredWrapContent</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228104214.png" alt="image-20210228104214386"></p></li><li><p><strong><code>wrapContent</code></strong> 内容自适应，不受约束条件影响。</p></li><li><p><strong><code>preferredValue</code></strong> 指定固定值大小，受约束条件影响。</p></li><li><p><strong><code>value</code></strong> 指定固定值大小，不受约束条件影响。</p></li></ul><h3 id="居中对齐"><a class="markdownIt-Anchor" href="#居中对齐"></a> 居中对齐</h3><p>当然，<code>Compose ConstraintLayout</code>也提供居中对齐，<code>centerTo</code>、<code>centerHorizontallyTo</code>、<code>centerVerticallyTo</code>。</p><p>例如：再增加两个Text,使其水平居中对齐。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Text(text = <span class="string">"年龄"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(ageRef) {</span><br><span class="line">        top.linkTo(descRef.bottom, <span class="number">5.</span>dp)</span><br><span class="line">        start.linkTo(nameRef.start)</span><br><span class="line"></span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Text(text = <span class="string">"颜色"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(colorRef) {</span><br><span class="line">        start.linkTo(ageRef.end,<span class="number">10.</span>dp)</span><br><span class="line">        centerVerticallyTo(ageRef)</span><br><span class="line">        width = Dimension.fillToConstraints</span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228110133.png" alt="image-20210228110133202"></p><h3 id="引导-栅栏与链"><a class="markdownIt-Anchor" href="#引导-栅栏与链"></a> 引导、栅栏与链</h3><p>由于年龄和颜色有时为了突出显示，设置不同的大小和颜色，而时间Text想根据两者的底部处于最下的来对齐。此时就需要<strong>栅栏</strong>。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bottomBarrier=createBottomBarrier(ageRef,colorRef,margin = <span class="number">5.</span>dp)</span><br><span class="line"></span><br><span class="line">Text(text = <span class="string">"2021-02-28"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(timeRef) {</span><br><span class="line">        start.linkTo(nameRef.start)</span><br><span class="line">        top.linkTo(bottomBarrier)</span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228111617.png" alt="image-20210228111617491"></p><p>当然，可以通过<code>createStartBarrier()</code>、<code>createTopBarrier()</code>、<code>createEndBarrier()</code>创建不同方向的栅栏。</p><p>随着右侧文本的增加，可恶的项目经理有时要求垂直方向中间压缩，有时要求平均整个<code>Constraintlayout</code>的高度。这时候就需要<strong>链</strong>出场了。通过<code>createVerticalChain</code>和<code>createHorizontalChain</code>创建垂直和水平方向的链。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createVerticalChain(nameRef,descRef,ageRef,timeRef,chainStyle = ChainStyle.Spread)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228112727.png" alt="image-20210228112727041"></p><p>**<code>ChainStyle</code>**的取值：</p><ul><li><p><strong><code>Packed</code></strong>： 压缩</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228113247.png" alt="image-20210228113247668"></p></li><li><p><strong><code>Spread</code></strong>：平分</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228112727.png" alt="image-20210228112727041"></p></li><li><p><strong><code>SpreadInside</code></strong> 上下两边留View，中间View平分</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228113747.png" alt="image-20210228113747133"></p><p>从效果图<code>SpreadInside</code>可以看到并不是很理想，这是因为一些上下相互约束条件没有设置好。例如调整后：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228114104.png" alt="image-20210228114104764"></p><p>也可以通过<code>createGuidelineFromBottom</code>,一起相关类似的<code>api</code>来创建<strong>引导线</strong>。引导线是不可见，起到<code>View</code>的对齐参考作用。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>其实，整体使用下来的感受，<code>Compose ConstraintLayout</code>约束条件的使用和<code>View</code>系统的<code>ConStraintLayout</code>是一致，简单熟悉一下API基本可以上手。如果不熟悉<code>View</code>系统的<code>ConStraintLayout</code>,建议先阅读<a href="https://juejin.cn/post/6854573221312725000">Constraintlayout 2.0：你们要的更新来了</a>。如果对一些API不存在或报错，建议查找<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#9">官方文档</a>，查看版本是否更新或者API更换或废弃。</p><p>另外：由于<code>Compose</code>已经优化深层布局嵌套，所以也就不存在使用<code>Compose ConstraintLayout</code>比多层嵌套使用<code>Column</code>和<code>Row</code>等等布局存在性能优势问题。只是更方便我们开发复杂布局，对齐边缘等。</p><h2 id="constraintset"><a class="markdownIt-Anchor" href="#constraintset"></a> <code>ConstraintSet</code></h2><p><code>ConstraintSet</code>主要说来做动画处理，一个<code>ConstraintSet</code>保存一个布局的约束状态，通过约束状态的切换，来实现同个布局状态切换效果。</p><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228141826.gif" alt="1"></p><p>代码实现：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintSet</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> orientation = remember { mutableStateOf(<span class="number">1</span>)}</span><br><span class="line">    </span><br><span class="line">    ConstraintLayout(</span><br><span class="line">        getConstraintLayout(orientation),</span><br><span class="line">        Modifier</span><br><span class="line">            .padding(<span class="number">16.</span>dp, <span class="number">0.</span>dp, <span class="number">16.</span>dp, <span class="number">0.</span>dp)</span><br><span class="line">            .background(color = colorEFEFEF, shape = RoundedCornerShape(<span class="number">5.</span>dp))</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .padding(<span class="number">12.</span>dp, <span class="number">12.</span>dp, <span class="number">12.</span>dp, <span class="number">12.</span>dp)</span><br><span class="line">    ) {</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.mipmap.dog_avatar),</span><br><span class="line">            contentDescription = <span class="string">"效果图片"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .layoutId(<span class="string">"imageRef"</span>)</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .clickable {</span><br><span class="line">                    <span class="keyword">if</span> (orientation.value==<span class="number">0</span>){</span><br><span class="line">                        orientation.value=<span class="number">1</span></span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        orientation.value=<span class="number">0</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">            contentScale = ContentScale.FillWidth</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">"泰迪犬其实是贵宾犬的一种。根据体型大小被分为四类，最受欢迎的是体型较小的品种：迷你贵宾犬和玩具贵宾犬。其中玩具贵宾犬是体型最小的一种，个性好动、欢快、非常机警、聪明、喜欢外出、性格脾气好、适应力强。贵宾犬不脱毛，是极好的宠物犬。如果红色玩具贵宾犬不剃胡须和嘴边的毛可以长成动漫画里面泰迪熊的模样，所以红色（褐色）玩具贵宾犬又叫“泰迪"</span>,</span><br><span class="line">            modifier = Modifier.layoutId(<span class="string">"titleRef"</span>),</span><br><span class="line">            fontSize = <span class="number">18.</span>sp,</span><br><span class="line">            textAlign = TextAlign.Left,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">            maxLines =<span class="keyword">if</span> (orientation.value==<span class="number">0</span>) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> <span class="number">4</span>,)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getConstraintLayout</span><span class="params">(orientation:<span class="type">MutableState</span>&lt;<span class="type">Int</span>&gt;)</span></span>:ConstraintSet{</span><br><span class="line">    <span class="keyword">return</span> ConstraintSet {</span><br><span class="line">        <span class="keyword">val</span> imageRef= createRefFor(<span class="string">"imageRef"</span>)</span><br><span class="line">        <span class="keyword">val</span> titleRef= createRefFor(<span class="string">"titleRef"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (orientation.value==<span class="number">0</span>){</span><br><span class="line">            constrain(imageRef){</span><br><span class="line">                start.linkTo(parent.start)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                top.linkTo(parent.top)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            constrain(titleRef){</span><br><span class="line">                start.linkTo(imageRef.start)</span><br><span class="line">                end.linkTo(imageRef.end)</span><br><span class="line">                top.linkTo(imageRef.bottom,<span class="number">16.</span>dp)</span><br><span class="line">                width= Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            constrain(imageRef){</span><br><span class="line">                start.linkTo(parent.start)</span><br><span class="line">                top.linkTo(parent.top)</span><br><span class="line">                width=Dimension.value(<span class="number">100.</span>dp)</span><br><span class="line">                height=Dimension.value(<span class="number">100.</span>dp)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            constrain(titleRef){</span><br><span class="line">                start.linkTo(imageRef.end,<span class="number">8.</span>dp)</span><br><span class="line">                top.linkTo(imageRef.top,<span class="number">2.</span>dp)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                bottom.linkTo(imageRef.bottom,<span class="number">8.</span>dp)</span><br><span class="line">                width= Dimension.fillToConstraints</span><br><span class="line">                height= Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>本文所有代码<a href="https://github.com/xxm-sz/ComposeDemo">仓库地址</a></p><p>欢迎<strong>点赞+关注+评论三连击</strong></p><p>【<a href="https://github.com/xxm-sz">Github</a>】【<a href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a href="https://xxm-sz.github.io/">博客</a>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介与依赖&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介与依赖&quot;&gt;&lt;/a&gt; 简介与依赖&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose ConstraintLayout&lt;/code&gt;约束布局主要应用在构建复杂布局，避免使用&lt;code&gt;</summary>
      
    
    
    
    <category term="Jetpack" scheme="http://example.com/categories/Jetpack/"/>
    
    
    <category term="Jetpack Compose" scheme="http://example.com/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>运输层的TCP与UDP</title>
    <link href="http://example.com/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/"/>
    <id>http://example.com/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/</id>
    <published>2021-02-22T16:00:00.000Z</published>
    <updated>2021-02-23T03:43:09.041Z</updated>
    
    <content type="html"><![CDATA[<p>运输层提供了端与端系统之间的逻辑通信（主机内部），而运输层提供了主机之间的逻辑通信，也就意味着运输层不存在中间路由器中。运输层在应用层与网络层之间至少提供最基础的多路复用和多路分解的服务，通过socket将应用层多个进程的数据收集交付网络层；或将网络层数据交付到不同的端口号的socket，提供给应用层的进程。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>不可靠，面向无连接，首部字段少（8个字段）。UDP中只有源端口和目的端口，从网络层到达数据，只要目的端口一样，不管源端口是否一致，都会将数据提供给同个socket。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210221100950.png" alt="image-20210221100943848"></p><p>校验和：检验报文段在传输到目的端口前，32比特是否发生了改变。</p><p>​    发生方：会将源端口，目的端口，长度三个16位的比特分别相加，如果发生溢出，则末位加1。然后将结果取反，作为检验和的内容。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>面向连接，可靠的运输层传输控制协议。</p><h4 id="一、TCP报文段格式"><a href="#一、TCP报文段格式" class="headerlink" title="一、TCP报文段格式"></a>一、TCP报文段格式</h4><p>虽然TCP面向字节流，但TCP传输的数据单元却是报文段。TCP报文段分为TCP首部和数据部分，TCP报文段首部的前20个字节是固定的，后面有4*n字节根据需要动态添加的选项，最大长度为40字节。<br><img src="https://user-gold-cdn.xitu.io/2019/7/13/16bea56ed5a68bb6?w=615&amp;h=400&amp;f=png&amp;s=88136"></p><ul><li><strong>源端口和目的端口</strong> 各占两个字节，TCP的分用功能也是通过端口实现的。</li><li><strong>序号</strong> 占4个字节，范围是[0,2<sup>32</sup>],TCP是面向字节流的，每个字节都是按顺序编号。例如一个报文段，序号字段是201，携带数据长度是100，那么第一个数据的序号就是201，最后一个就是300。当达到最大范围，又从0开始。</li><li><strong>确认号</strong> 占4个字节，是期望收到对方下一个报文段的第一个字节的序号。若确认号=N,则表示序号N前所有的数据已经正确收到了。</li><li><strong>数据偏移</strong> 占4位，表示报文段的数据部分的起始位置，距离整个报文段的起始位置的距离。间接的指出首部的长度。</li><li><strong>保留</strong> 占6位，保留使用，目前为0.</li><li><strong>URG（紧急）</strong> 当URG=1,表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。</li><li><strong>ACK(确认)</strong> 仅当ACK=1时，确认号才有效，连接建立后，所有的报文段ACK都为1。</li><li><strong>PSH(推送)</strong> 接收方接收到PSH=1的报文段，会尽快交付接收应用经常，不再等待整个缓存填满再交付。实际较少使用。</li><li><strong>RST(复位)</strong> RST=1时，表明TCP连接中出现严重差错，必须是否连接，再重连。</li><li><strong>SYN(同步)</strong> 在建立连接时用来同步序号。当SYN=1,ACK=0，则表明是一个连接请求报文段。SYN=1,ACK=1则表示对方同意连接。TCP建立连接用到。</li><li><strong>FIN(终止)</strong> 用来释放一个连接窗口。当FIN=1时，表明此报文段的发送方不再发送数据，请求释放单向连接。TCP断开连接用到。</li><li><strong>窗口</strong> 占2个字节，表示发送方自己的接收窗口，窗口值用来告诉对方允许发送的数据量。</li><li><strong>校验和</strong> 占2字节，检验和字段查验范围包括首部和数据部分。</li><li><strong>紧急指针</strong> 占2字节，URG=1时，紧急指针指出本报文段中的紧急数据的字节数（紧急字节数结束后为普通字节）。</li><li><strong>选项</strong> 长度可变，最长可达40字节。例如最大报文段长度MSS。MSS指的是数据部分的长度而不是整个TCP报文段长度，MSS默认为536字节长。窗口扩大，时间戳选项等。</li></ul><h4 id="二、丢包情况"><a href="#二、丢包情况" class="headerlink" title="二、丢包情况"></a>二、丢包情况</h4><p>由于网络层的丢包并不会显式告知运输层，TCP推断丢包主要通过超时和三次冗余ACK报文段两种方式来推断网络出现丢包。</p><p><strong>超时/重传机制解决报文段丢失问题</strong> 。超时时长需要大于发送方发送报文段到接收该报文段的确认的往返时间RTT。而RTT在不同时刻会有较大的波动，需要在某个时刻测量报文段的往返时间，称之为样本往返时间<code>SampleRTT</code>。</p><p><code>SampleRTT</code>并不能反映一段时间内RTT的波动情况，因此需要求个均值：<br>$$<br>EstimatedRTT=(1-a)<em>EstimatedRTT+a</em>SampleRTT<br>$$</p><p>a的参考值为0.125。</p><p>$$<br>EstimatedRTT=0.875<em>EstimatedRTT+0.125</em>SampleRTT<br>$$</p><p>测量<code>SampleRTT</code>的偏差情况也是有帮助的：</p><p>$$<br>DevRTT=（1-a)<em>DevRTT+a</em>|SmapleRTT-EstimatedRTT|<br>$$</p><p>a的推荐之为0.25</p><p>在上述相关时间的确定下，TCP超时时隔的设置：<br>$$<br>EstimatedRTT+4*DevRTT<br>$$</p><h4 id="三、连接管理"><a href="#三、连接管理" class="headerlink" title="三、连接管理"></a>三、连接管理</h4><h5 id="1、连接建立：三次握手"><a href="#1、连接建立：三次握手" class="headerlink" title="1、连接建立：三次握手"></a><strong>1、连接建立：三次握手</strong></h5><p>三次握手图例如下,与文字解释配合使用效果更佳。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112735.png"><br><strong>第一次</strong>：客户端发送连接请求报文给服务端，其中SYN=1,seq=x。发送完毕后进入SYN_END状态。</p><p><strong>第二次</strong>：服务端接收到报文后，发回确认报文，其中ACK=1,ack=x+1，因为需要客户端确认，所以报文中也有SYN=1,seq=y的信息。发送完后进入SYN_RCVD状态。</p><p><strong>第三次</strong>:客户端接收到报文后,发送确认报文，其中ACK=1,ack=y+1。发送完客户端进入<code>ESTABLISHED</code>状态，服务端接收到报文后，进入<code>ESTABLISHED</code>状态。到此，连接建立完成。</p><p><strong>三次握手原因</strong></p><p>避免资源被浪费掉。如果在第二步握手时，由于网络延迟导致确认包不能及时到达客户端，那么客户端会认为第一次握手失败，再次发送连接请求，服务端收到后再次发送确认包。在这种情况下，服务端已经创建了两次连接，等待两个客户端发送数据，而实际却只有一个客户端发送数据。</p><h5 id="2、连接断开：四次挥手"><a href="#2、连接断开：四次挥手" class="headerlink" title="2、连接断开：四次挥手"></a><strong>2、连接断开：四次挥手</strong></h5><p>四次挥手指客户端和服务端各发送一次请求终止连接的报文，同时双方响应彼此的请求。<br>四次挥手图例如下，请配置文字解释使用哦。<br><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112847.png" alt="四次挥手图例"><br><strong>第一次挥手</strong>：客户端发送FIN=1，seq=x的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭。发送完后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次挥手</strong>：服务端收到请求包后，发回ACK=1,ack=x+1的确认包，表示确认断开连接。服务端进<code>入CLOSE_WAIT</code>状态。客户端收到该包后，进入<code>FIN_WAIT_2</code>状态。此时客户端到服务端的数据连接已断开。</p><p><strong>第三次挥手</strong>：服务端发送FIN=1,seq=y的包给客户端，表示自己没有数据要给客户端了。发送完后进入<code>LAST_ACK</code>状态，等待客户端的确认包。</p><p><strong>第四次挥手</strong>：客户端收到请求包后，发送ACK=1,ack=y+1的确认包给服务端，并进入<code>TIME_WAIT</code>状态，有可能要重传确认包。服务端收到确认包后，进入<code>CLOSED</code>状态，服务端到客户端的连接已断开。客户端等到一段时间后也会进入<code>CLOSED</code>状态。</p><p><strong>四次挥手原因</strong><br>由于TCP的连接是全双工，双方都可以主动传输数据，一方的断开需要告知对方，让对方可以相关操作，负责任的表现。</p><h4 id="四、流量控制"><a href="#四、流量控制" class="headerlink" title="四、流量控制"></a>四、流量控制</h4><p> 原因：解决由于发送方发送数据速率与接收方接收数据数据不一致问题。</p><p>接收方接收窗口大小等于接收缓存大小减去已接收未被Socket读取的字节大小。<br>$$<br>rwnd=receiverBuff-unReadByte<br>$$<br>而发送方的发送窗口大小受限于<strong>拥塞窗口</strong>和<strong>接收窗口</strong>大小,即取两者最小值：<br>$$<br>swnd=min(rwnd,cwnd)<br>$$<br>流量控制主要采用了滑动窗口协议进行控制：</p><p>对于发送方接收缓存数据存在三种状态：</p><p><strong>发送已确认</strong> 、<strong>发送未确认</strong>、<strong>未发送</strong></p><p>而发送方接收缓存中数据存在两种状态：</p><p><strong>已接收和确认但未被上层读取</strong>、<strong>接收未确认</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112138.png"></p><h4 id="五、拥塞机制"><a href="#五、拥塞机制" class="headerlink" title="五、拥塞机制"></a>五、拥塞机制</h4><p>网络拥塞会导致路由器缓存溢出，而造成丢包，导致数据不可靠传输。而拥塞机制也正是解决该问题，告知TCP发送方如何调整发送速率，以将适量的数据交付到网络中，避免不要丢包，或者在丢包后，发送方应该如何调整速率。</p><p><strong>网络拥塞带来的代价</strong>：</p><ul><li>当分组到达速率接近链路容量时，分组会经历巨大的时延；</li><li>发送方必须执行重传已补偿因为缓存溢出而丢弃（丢失）的分组；</li><li>发送方遇到大时延所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组；</li><li>当一个分组沿一条路被丢弃时，每个上游路由器用于转发改分组到丢弃该分组而使用的传输容量被浪费掉；</li></ul><p>由于运输层无法显式从网络层获取到网络拥塞相关反馈，所有TCP只能借用超时和三个冗余ACK两种丢包情况来推断网络出现拥塞，从而进行端到端的拥塞控制。</p><p><strong>TCP拥塞控制算法</strong></p><p>分为三步骤：慢启动，拥塞避免，快速恢复</p><ul><li><p>1、慢启动</p><p>拥塞窗口cwnd以一个MSS开始，每收到一个ACK报文段，则增1个MSS，即数据成指数增长。</p><p>以下三种情况会结束慢启动状态：</p><ul><li><p><strong>超时丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</p></li><li><p><strong>三次冗余ACK</strong>:此时判断网络出现拥塞而丢包，执行快速重传，进入快速恢复状态；</p></li><li><p><strong>到达阈值</strong>：结束慢启动，进入拥塞避免；</p></li></ul></li><li><p>2、拥塞避免</p><p>到达拥塞避免阶段，拥塞窗口在每个RTT内以1个MSS增长，成线性增长。</p><ul><li><strong>超时丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</li><li><strong>三次冗余ACK</strong>:此时判断网络出现拥塞而丢包，将拥塞窗口减少一半，进入快速恢复状态；</li></ul></li><li><p>3、快速恢复</p><p>此时<code>ssthresh=cwnd/2</code>，</p><p>在Reno版本，如果接收到对丢包的报文段的冗余ACK报文段，拥塞窗口则增加一个MSS。拥塞窗口<code>cwnd=cwnd/2+3MSS(3次冗余ACK确认增加)</code>,然后线性增加。（拥塞避免）</p><p>在Tahoe版本，拥塞窗口<code>cwnd=1MSS</code>，指数增长，达到<code>ssthresh</code>进入线性增长。（慢启动操作，目前已弃用）</p><ul><li><strong>丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223111340.png"></p><p>​    </p></li></ul><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>  1、TCP判断可能出现丢包两种情况：</p><ul><li><p>定时器超时</p></li><li><p>接收到三次冗余ACK(即对一个报文段接收到4次ACK报文段)</p><p>2、流量控制和拥塞控制都是为了让TCP能进行可靠数据传输，流量控制是为了解决接收方接收速率与发送方速率不一致问题，通过接收窗口大小告知发生方还能接收多大字节流。而拥塞控制是为了解决网络拥塞导致丢包问题，通过拥塞窗口扼制发送方发送过多分组到网络中。发送方的发送窗口大小受限于接收窗口和拥塞窗口的最小值。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112241.png"></p><h4 id="七、相关连接"><a href="#七、相关连接" class="headerlink" title="七、相关连接"></a>七、相关连接</h4><p><a href="https://juejin.cn/post/6844903889146216456">个人往期文章总结：TCP与UDP</a></p><p>参考数据：《计算机网络 自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运输层提供了端与端系统之间的逻辑通信（主机内部），而运输层提供了主机之间的逻辑通信，也就意味着运输层不存在中间路由器中。运输层在应用层与网络层之间至少提供最基础的多路复用和多路分解的服务，通过socket将应用层多个进程的数据收集交付网络层；或将网络层数据交付到不同的端口号</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://example.com/2020/12/20/Threadlocal/"/>
    <id>http://example.com/2020/12/20/Threadlocal/</id>
    <published>2020-12-20T04:12:57.000Z</published>
    <updated>2021-02-05T08:43:51.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是ThreadLocal"><a href="#一、什么是ThreadLocal" class="headerlink" title="一、什么是ThreadLocal"></a>一、什么是ThreadLocal</h3><p>ThreadLocal用于保存线程全局变量，以方便调用。即，当前线程独有，不与其他线程共享；可在当前线程任何地方获取到该变量。</p><h3 id="二、ThreadLocal的使用"><a href="#二、ThreadLocal的使用" class="headerlink" title="二、ThreadLocal的使用"></a>二、ThreadLocal的使用</h3><h4 id="1、如何保存内容"><a href="#1、如何保存内容" class="headerlink" title="1、如何保存内容"></a>1、如何保存内容</h4><p>创<code>ThreadLocal</code>实例，并调用<code>set</code>函数，保存<code>中国</code>字符串，分别在当前线程和<code>new-thread</code>线程获取该值。通过打印结果可以看到，虽然引用的是同个对象，但<code>new-thread</code>线程获取到的值却是<code>null</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115104823.png" alt="use"></p><p>运行结果:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main 中国</span><br><span class="line">MainActivity: new-thread null</span><br></pre></td></tr></tbody></table></figure><p>这是什么情况呢？</p><p>在<code>ThreadLocal</code>的<code>set</code>函数中，获取当前线程的<code>ThreadLocalMap</code>实例，如何当前线程第一次使用<code>ThreadLocal</code>,则需要创建<code>ThreadLocalMap</code>实例，否则直接通过<code>ThreadLocalMap</code>实例的<code>set</code>函数进行保存。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115103657.png" alt="set"></p><h4 id="2、如何获取内容"><a href="#2、如何获取内容" class="headerlink" title="2、如何获取内容"></a>2、如何获取内容</h4><p>由于<code>main</code>线程前面<code>set</code>函数将内容保存到<code>ThreadLocalMap</code>实例中，已经可以获取到<code>中国</code>字符串。而在<code>new-thread</code>线程中，由于是第一次使用<code>ThreadLocalMap</code>，所以此时<code>map</code>是<code>null</code>，并调用<code>setInitialValue</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115111259.png" alt="get"></p><p>在<code>setInitialValue</code>函数中,调用了<code>initialValue</code>函数，该函数直接返回了<code>null</code>，这就是为什么在<code>new-thread</code>线程获取的值是<code>null</code>。因此<code>setInitialValue</code>函数主要为当前线程创建<code>ThreadLocalMap</code>对象。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115112648.png" alt="setInitialValue"></p><h4 id="3、ThreadLocalMap"><a href="#3、ThreadLocalMap" class="headerlink" title="3、ThreadLocalMap"></a>3、ThreadLocalMap</h4><p><code>ThreadLocalMap</code>内部持有一个数组<code>table</code>，用于保存<code>Entry</code>元素。<code>Entry</code>继承至<code>WeakReference</code>,并以<code>ThreadLcoal</code>实例作为<code>key</code>，和保存内容 T作为<code>value</code>。当发生GC时，<code>key</code>就会被回收,从而导致该Entry过期。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118144659.png" alt="Entry"></p><p>每一个线程都持有一个<code>ThreadLocalMap</code>局部变量<code>threadLocas</code>，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118113312.png" alt="image-20210118113312896"></p><h5 id="3-1-ThreadLocalMap的创建"><a href="#3-1-ThreadLocalMap的创建" class="headerlink" title="3.1 ThreadLocalMap的创建"></a>3.1 ThreadLocalMap的创建</h5><p>ThreadLocalMap对象的创建，也就是ThreadLocal 对象调用了自身的<code>createMap</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115114648.png" alt="createMap"></p><p>ThreadLocalMap的构造函数，创建了一个保存Entry对象的table数组，默认大小16。并通过<code>threadLocal</code>的<code>threadLocalHashCode</code>属性计算出Entry在数组的小标，进行保存，并计算出阈值<code>INITIAL_CAPACITY</code>的2/3。</p><p><code>threadLocalHashCode</code>属性在ThreaLocal对象创建时会自动计算得出.</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115145913.png" alt="threadLocalHashCode"></p><p><code>threadLocalHashCode</code>作为ThreadLocal的唯一实例变量，在不同的实例中是不同的，通过<code>nextHashCode.getAndAdd</code>已经定义了下一个ThreadLcoal的实例的<code>threadLocalHashCode</code>值，而第一个ThreadLocal的<code>threadLocalHashCode</code>值则是从0开始，与下一个<code>threadLocalHashCode</code>间隔<code>HASH_INCREMENT</code>。</p><p>通过<code>threadLocalHashCode &amp; (len-1)</code>计算出来的数组下标，分发很均匀，减少冲突。但是呢，冲突时还是会出现，如果发生冲突，则将新增的Entry放到后侧<code>entry=null</code>的地方。</p><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><h4 id="1、ThreadLocalMap的set函数"><a href="#1、ThreadLocalMap的set函数" class="headerlink" title="1、ThreadLocalMap的set函数"></a>1、ThreadLocalMap的set函数</h4><p>在上一节中，分析了<code>ThreadLocal</code>实例的<code>set</code>函数，最终是调用了<code>ThreadLocalMap</code>实例的<code>set</code>函数进行保存。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116153208.png" alt="mapset"></p><p>通过代码分析可知，<code>ThreadLocalMap</code>的<code>set</code>函数主要分为三个主要步骤：</p><ol><li><p>计算出当前<code>ThreadLocal</code>在<code>table</code>数组的位置，然后向后遍历，直到遍历到的<code>Entry</code>为<code>null</code>则停止，遍历到<code>Entry</code>的<code>key</code>与当前<code>threadLocal</code>实例的相等，直接更替value；</p></li><li><p>如果遍历到<code>Entry</code>已过期（<code>Entry</code>的<code>key</code>为<code>null</code>），则调用<code>replaceStaleEntry</code>函数进行替换。</p></li><li><p>在遍历结束后，未出现1和2两种情况，则直接创建新的<code>Entry</code>，保存到数组最后侧没有Entry的位置。</p></li></ol><p>在第2步骤和最后都会清理过期的<code>Entry</code>，这个稍后分析，先看看第2步骤，在检测到过期的Entry，会调用<code>replaceStaleEntry</code>函数进行替换。</p><p>   <img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116152455.png" alt="replaceStaleEntry"></p><p><code>replaceStaleEntry</code>函数，主要分为两次遍历，以当前过期的Entry为分割线，一次向前遍历，一次向后遍历。</p><p>在向前遍历过程，如果发现有过期的<code>Entry</code>，则保留其位置<code>slotToExpunge</code>，直到有<code>Entry</code>为<code>null</code>为止。这里只是判断<code>staleSlot</code>前方是否有过期的<code>Entry</code>，然后方便后面进行清理。</p><p>在向后遍历过程，如果发现有<code>key</code>相同的<code>Entry</code>，直接与<code>staleSlot</code>位置的<code>Entry</code>交换<code>value</code>（上图注释有问题）。如果没有碰到相同的<code>key</code>，则创建新的<code>Entry</code>保存到<code>staleSlot</code>位置。与此同时，如果向前遍历没有发现过期Entry，而在向后遍历发现过期的<code>ntry</code>，则需要更新过期位置<code>slotToExpunge</code>，因为后面的清除内容是需要<code>slotToExpunge</code>。</p><h4 id="2、ThreadLocalMap清除过期Entry"><a href="#2、ThreadLocalMap清除过期Entry" class="headerlink" title="2、ThreadLocalMap清除过期Entry"></a>2、ThreadLocalMap清除过期Entry</h4><p>在上一小节中，会通过<code>expungeStaleEntry</code>函数和<code>cleanSomeSlots</code>函数清理过期的Entry，它们又是如何实现呢？</p><p><code>expungeStaleEntry</code>函数清理过期<code>Entry</code>过程被称为：<strong>探测式清理</strong>。函数传递进来的参数是过期的<code>Entry</code>的位置，工作过程是先将该位置置为<code>null</code>，然后遍历数组后侧所有位置的Entry，如果遍历到有<code>Entry</code>过期,则直接置<code>null</code>，否则将它移到合适的位置：<code>hash</code>计算出来的位置或离该<code>hash</code>位置最近的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116165619.png" alt="expungeStaleEntry"></p><p>经过这么一次经历，<code>staleSlot</code>位置到后侧最近<code>entry=null</code>的位置就不存在过期的<code>entry</code>，而每个<code>entry</code>要么在原有<code>hash</code>位置，要么离原有<code>hash</code>位置最近。</p><p><code>expungeStaleEntry</code>函数的工作范围：</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116174219.png" alt="expungeStaleEntry (1)"></p><p><code>expungeStaleEntry</code>函数一开始会将起点，即数组第3的位置设置为<code>null</code>。然后开始遍历数组后侧元素，4和5位置无论是否在它的<code>hash</code>位置，在这里都保持不变。遍历到第6时，发现<code>entry</code>已过期，将第6设置为<code>null</code>。此时3和6位置变成白色了。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116175944.png" alt="image-20210116175944199"></p><p>A、遍历到第7的时候，假设<code>h != i</code>成立，那么第7位置的<code>entry</code>将被移到第6位置，空出第7位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116180006.png" alt="image-20210116180006575"></p><p>B、接着遍历到第8位置，假设<code>h != i</code>不成立，则第8的<code>entry</code>的位置不变。</p><p>接着继续遍历后侧元素，重复着A和B步骤，直到碰到entry为null，退出遍历。例如这里的第10位置，entry=null。</p><p>由于探测性清理，碰到<code>entry=null</code>的情况就会结束。而通过<code>cleanSomeSlots</code>函数进行<strong>启发式清理</strong>，碰到<code>entry=null</code>不停止，而是由控制条件n决定，而在这个过程中，碰到过期<code>entry</code>，n又恢复到数组长度,加大清理范围。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118101626.png" alt="clean"></p><p>在启发式清理过程，如果碰到过期<code>Entry</code>，会导致控制条件<code>n</code>恢复到数组长度<code>len</code>，从而导致循环次数增加，则往后<code>nextIndex</code>次数增加，从而增加清理范围。这种方式也不一定能完整清理后面所有过期元素，例如在控制<code>n</code>右移所有过程中，没有碰到过期的<code>entry</code>，就结束了。</p><h4 id="3、ThreadLocalMap的扩容机制"><a href="#3、ThreadLocalMap的扩容机制" class="headerlink" title="3、ThreadLocalMap的扩容机制"></a>3、ThreadLocalMap的扩容机制</h4><p>在第1节，调用<code>ThreadLocalMap</code>的<code>set</code>函数最后，会调用<code>reHash</code>函数进行扩容。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118110300.png" alt="rehash"></p><p>在外层进行启发式清理后，如果<code>size&gt;threshold</code>则会进行rehash，而在<code>rehash</code>中，会清理整个数组的过期<code>Entry</code>，如果清理后，数组长度还大于<code>3/4*threshod</code>，则进行扩容<code>resize</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118111623.png" alt="resize"></p><p><code>resize</code>函数直接创建新的数组，长度为旧数组的两倍。然后重新计算旧数组元素在新数组的位置，复制。</p><h3 id="四、内存泄露"><a href="#四、内存泄露" class="headerlink" title="四、内存泄露"></a>四、内存泄露</h3><p>正常情况下，用完ThreadLocal实例,将其置为null，在发生GC时，ThreadLocal对象就会被回收。但是此时如果线程还存活(例如线程池线程的复用)，就会导致Entry的value对象得不到释放，会造成内存泄露。所以，在使用完ThreadLocal实例后，调用<code>remove</code>函数清除一下。</p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>发生GC的时候，Key会被回收么，还能获取到值么？</p><p>正常情况下，如果ThreadLocal实例同时被强引用，所以在发生GC的时候，是不会回收的，也就是此时<code>WeakReference.get</code>是有返回值的，不会被回收。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118174100.png" alt="gc"></p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118175757.png" alt="image-20210118175757028"></p><p><a href="https://zhuanlan.zhihu.com/p/58931565?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1182794502313586688">推荐阅读：Java引用与ThreadLocal</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、什么是ThreadLocal&quot;&gt;&lt;a href=&quot;#一、什么是ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ThreadLocal&quot;&gt;&lt;/a&gt;一、什么是ThreadLocal&lt;/h3&gt;&lt;p&gt;ThreadLocal用于保</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
</feed>
