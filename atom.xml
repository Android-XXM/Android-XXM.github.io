<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新小梦</title>
  
  <subtitle>热爱 • 编程</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T06:34:49.912Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zhangws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Compose ConstraintLayout 详讲</title>
    <link href="http://example.com/2021/02/28/ConstraintLayout/"/>
    <id>http://example.com/2021/02/28/ConstraintLayout/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T06:34:49.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介与依赖"><a class="markdownIt-Anchor" href="#简介与依赖"></a> 简介与依赖</h2><p><code>Compose ConstraintLayout</code>约束布局主要应用在构建复杂布局，避免使用<code>Column</code>、<code>Row</code>、<code>Box</code>多层嵌套，同时也能提高开发效率。</p><p>开始使用之前需要添加对<code>ConstraintLayout</code>的依赖：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'androidx.constraintlayout:constraintlayout-compose:1.0.0-alpha03'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>需要注意的</strong>：截止本文发稿，<code>Compose</code>和<code>Constraintlayout</code>都还没有到稳定版本，所以对相关库的依赖一定都要更新到最新版本(或者相适配版本)，不然可能存在不兼容问题。</p><p>查看<code>ConstraintLayout</code>的<a href="https://github.com/androidx/constraintlayout">最新地址</a></p><h2 id="入门与深入"><a class="markdownIt-Anchor" href="#入门与深入"></a> 入门与深入</h2><h3 id="引用创建"><a class="markdownIt-Anchor" href="#引用创建"></a> 引用创建</h3><p>在<code>View</code>系统的<code>ConstraintLayout</code>在<code>xml</code>布局中，需要通过id进行相关引用，在<code>Compose</code>也是类似的。通过<code>createRefs</code>函数或<code>createRef</code>函数为不同的<code>View</code>预定一个引用。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="绑定引用"><a class="markdownIt-Anchor" href="#绑定引用"></a> 绑定引用</h3><p>将通过<code>constrainAs</code>函数将引用与<code>View</code>绑定，相当于给<code>View</code>赋值了一个<code>id</code>。另外,<code>constarinAs</code>有时在编写代码并不能自动提示，需要自己手刃代码哦。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">        </span><br><span class="line">        Image(painter = painterResource(id = puppy.avatar),</span><br><span class="line">                contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .constrainAs(avatar) {}<span class="comment">//通过constrainAs将Image与imageRef绑定</span></span><br><span class="line">                    .size(<span class="number">100.</span>dp)</span><br><span class="line">                    .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">                contentScale = ContentScale.Crop)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>linkTo</code>函数将<code>view</code>与其他<code>view</code>或者<code>parent</code>约束。这里的<code>parent</code>指的就是<code>ConstraintLayout</code>本身。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span>{</span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">    <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">    <span class="keyword">val</span> (image,name,desc)=createRefs()</span><br><span class="line">        </span><br><span class="line">        Image(painter = painterResource(id = puppy.avatar),</span><br><span class="line">                contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .constrainAs(avatar) {</span><br><span class="line">                    top.linkTo(parent.top)</span><br><span class="line">                    start.linkTo(parent.start)</span><br><span class="line">                    end.linkTo(parent.end)</span><br><span class="line">                    bottom.linkTo(parent.bottom)</span><br><span class="line">                    }<span class="comment">//通过constrainAs将Image与imageRef绑定,并增加约束</span></span><br><span class="line">                    .size(<span class="number">100.</span>dp)</span><br><span class="line">                    .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">                contentScale = ContentScale.Crop)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>constrainAs</code>函数中的<code>start</code>、<code>top</code>、<code>end</code>、<code>bottom</code>分别代表<code>view</code>的左、上、右、下四条边，<code>linkTo</code>表示相互作用。例如代码中的<code>top.linkTo(parent.top)</code>表示<code>Image</code>的顶边和<code>ConstraintLayout</code>的顶边对齐，和<code>view</code>系统中的<code>layout_constraintTop_toTopOf="parent"</code>是一致。接下来再增加两个<code>Text</code>。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintLayout</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    ConstraintLayout() {</span><br><span class="line">        <span class="comment">//通过createRefs创建三个引用</span></span><br><span class="line">        <span class="keyword">val</span> (imageRef, nameRef, descRef) = createRefs()</span><br><span class="line"></span><br><span class="line">        Image(painter = painterResource(id = R.mipmap.dog_avatar),</span><br><span class="line">            contentDescription = <span class="string">"dog avatar"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .constrainAs(imageRef) {<span class="comment">//通过constrainAs将Image与imageRef绑定,并增加约束</span></span><br><span class="line">                    top.linkTo(parent.top)</span><br><span class="line">                    start.linkTo(parent.start)</span><br><span class="line">                    bottom.linkTo(parent.bottom)</span><br><span class="line">                }</span><br><span class="line">                .size(<span class="number">100.</span>dp)</span><br><span class="line">                .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">            contentScale = ContentScale.Crop)</span><br><span class="line"></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">"名称"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .constrainAs(nameRef) {</span><br><span class="line">                    top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">                    start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">                    end.linkTo(parent.end)</span><br><span class="line">                    width = Dimension.fillToConstraints</span><br><span class="line">                }</span><br><span class="line">                .fillMaxWidth(),</span><br><span class="line">            fontSize = <span class="number">18.</span>sp,</span><br><span class="line">            maxLines = <span class="number">1</span>,</span><br><span class="line">            textAlign = TextAlign.Left,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Text(text = <span class="string">"描述"</span>, modifier = Modifier</span><br><span class="line">            .constrainAs(descRef) {</span><br><span class="line">                top.linkTo(nameRef.bottom, <span class="number">5.</span>dp)</span><br><span class="line">                start.linkTo(nameRef.start)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                width = Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">            .fillMaxWidth(),</span><br><span class="line">            maxLines = <span class="number">1</span>,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">            style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面代码中，在<code>ConstrantLayout</code>中创建了<code>Image</code>和两个<code>Text</code>组件。在<code>Text</code>的约束，通过<code>start.linkTo(imageRef.end, 12.dp)</code>约束条件，将<code>nameRef Text</code>位与<code>Image</code>的右边，并增加了12dp的<code>margin</code>。</p><h3 id="约束尺寸"><a class="markdownIt-Anchor" href="#约束尺寸"></a> 约束尺寸</h3><p>注意到，给<code>Text</code>的宽度增加了<code>width = Dimension.fillToConstraints</code>约束，让<code>Text</code>文本过长时，不超出约束条件。</p><p>例如，默认情况下：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将nameRef Text的约束改成下面代码</span></span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称是否是否所发生的方法是否是否"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>通过效果图看到，Text文本过长时不仅超过了<code>ConstraintLayout</code>，还超出了屏幕。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228101824.png" alt="image-20210228101817679"></p><p>将代码改成如下：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称是否是否所发生的方法是否是否"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            end.linkTo(parent.end,<span class="number">12.</span>dp)</span><br><span class="line">            width=Dimension.fillToConstraints</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228102243.png" alt="image-20210228102243362"></p><p><code>Dimension</code>取值如下：</p><ul><li><p><strong><code>fillToConstraints</code></strong> 填充约束条件下所剩的可用空间，如上面例子。</p></li><li><p><strong><code>preferredWrapContent</code></strong> 内容自适应，但受约束条件影响，也就是说，当宽小于约束条件下可用的宽时，则view的宽就是自身的宽，但大于的时候，则受约束条件影响。高也是如此。</p><p>例如：小于约束所剩宽时：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称负少测试赛"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            width=Dimension.preferredWrapContent</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图:</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228103814.png" alt="image-20210228103814863"></p><p>增加文本内容，增加右边与<code>parent</code>对齐。通过效果图，可见文本换行处理。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    text = <span class="string">"名称负少发发发发发发付付付付付付测试赛"</span>,</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .constrainAs(nameRef) {</span><br><span class="line">            top.linkTo(imageRef.top, <span class="number">2.</span>dp)</span><br><span class="line">            start.linkTo(imageRef.end, <span class="number">12.</span>dp)</span><br><span class="line">            end.linkTo(parent.end)</span><br><span class="line">            width=Dimension.preferredWrapContent</span><br><span class="line">        },</span><br><span class="line">    fontSize = <span class="number">18.</span>sp,</span><br><span class="line">    textAlign = TextAlign.Left,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228104214.png" alt="image-20210228104214386"></p></li><li><p><strong><code>wrapContent</code></strong> 内容自适应，不受约束条件影响。</p></li><li><p><strong><code>preferredValue</code></strong> 指定固定值大小，受约束条件影响。</p></li><li><p><strong><code>value</code></strong> 指定固定值大小，不受约束条件影响。</p></li></ul><h3 id="居中对齐"><a class="markdownIt-Anchor" href="#居中对齐"></a> 居中对齐</h3><p>当然，<code>Compose ConstraintLayout</code>也提供居中对齐，<code>centerTo</code>、<code>centerHorizontallyTo</code>、<code>centerVerticallyTo</code>。</p><p>例如：再增加两个Text,使其水平居中对齐。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Text(text = <span class="string">"年龄"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(ageRef) {</span><br><span class="line">        top.linkTo(descRef.bottom, <span class="number">5.</span>dp)</span><br><span class="line">        start.linkTo(nameRef.start)</span><br><span class="line"></span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Text(text = <span class="string">"颜色"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(colorRef) {</span><br><span class="line">        start.linkTo(ageRef.end,<span class="number">10.</span>dp)</span><br><span class="line">        centerVerticallyTo(ageRef)</span><br><span class="line">        width = Dimension.fillToConstraints</span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228110133.png" alt="image-20210228110133202"></p><h3 id="引导-栅栏与链"><a class="markdownIt-Anchor" href="#引导-栅栏与链"></a> 引导、栅栏与链</h3><p>由于年龄和颜色有时为了突出显示，设置不同的大小和颜色，而时间Text想根据两者的底部处于最下的来对齐。此时就需要<strong>栅栏</strong>。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bottomBarrier=createBottomBarrier(ageRef,colorRef,margin = <span class="number">5.</span>dp)</span><br><span class="line"></span><br><span class="line">Text(text = <span class="string">"2021-02-28"</span>, modifier = Modifier</span><br><span class="line">    .constrainAs(timeRef) {</span><br><span class="line">        start.linkTo(nameRef.start)</span><br><span class="line">        top.linkTo(bottomBarrier)</span><br><span class="line">    },</span><br><span class="line">    maxLines = <span class="number">1</span>,</span><br><span class="line">    overflow = TextOverflow.Ellipsis,</span><br><span class="line">    style = TextStyle(color = color999999, fontSize = <span class="number">13.</span>sp)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228111617.png" alt="image-20210228111617491"></p><p>当然，可以通过<code>createStartBarrier()</code>、<code>createTopBarrier()</code>、<code>createEndBarrier()</code>创建不同方向的栅栏。</p><p>随着右侧文本的增加，可恶的项目经理有时要求垂直方向中间压缩，有时要求平均整个<code>Constraintlayout</code>的高度。这时候就需要<strong>链</strong>出场了。通过<code>createVerticalChain</code>和<code>createHorizontalChain</code>创建垂直和水平方向的链。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createVerticalChain(nameRef,descRef,ageRef,timeRef,chainStyle = ChainStyle.Spread)</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228112727.png" alt="image-20210228112727041"></p><p>**<code>ChainStyle</code>**的取值：</p><ul><li><p><strong><code>Packed</code></strong>： 压缩</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228113247.png" alt="image-20210228113247668"></p></li><li><p><strong><code>Spread</code></strong>：平分</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228112727.png" alt="image-20210228112727041"></p></li><li><p><strong><code>SpreadInside</code></strong> 上下两边留View，中间View平分</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228113747.png" alt="image-20210228113747133"></p><p>从效果图<code>SpreadInside</code>可以看到并不是很理想，这是因为一些上下相互约束条件没有设置好。例如调整后：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228114104.png" alt="image-20210228114104764"></p><p>也可以通过<code>createGuidelineFromBottom</code>,一起相关类似的<code>api</code>来创建<strong>引导线</strong>。引导线是不可见，起到<code>View</code>的对齐参考作用。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>其实，整体使用下来的感受，<code>Compose ConstraintLayout</code>约束条件的使用和<code>View</code>系统的<code>ConStraintLayout</code>是一致，简单熟悉一下API基本可以上手。如果不熟悉<code>View</code>系统的<code>ConStraintLayout</code>,建议先阅读<a href="https://juejin.cn/post/6854573221312725000">Constraintlayout 2.0：你们要的更新来了</a>。如果对一些API不存在或报错，建议查找<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#9">官方文档</a>，查看版本是否更新或者API更换或废弃。</p><p>另外：由于<code>Compose</code>已经优化深层布局嵌套，所以也就不存在使用<code>Compose ConstraintLayout</code>比多层嵌套使用<code>Column</code>和<code>Row</code>等等布局存在性能优势问题。只是更方便我们开发复杂布局，对齐边缘等。</p><h2 id="constraintset"><a class="markdownIt-Anchor" href="#constraintset"></a> <code>ConstraintSet</code></h2><p><code>ConstraintSet</code>主要说来做动画处理，一个<code>ConstraintSet</code>保存一个布局的约束状态，通过约束状态的切换，来实现同个布局状态切换效果。</p><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210228141826.gif" alt="1"></p><p>代码实现：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">learnConstraintSet</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> orientation = remember { mutableStateOf(<span class="number">1</span>)}</span><br><span class="line">    </span><br><span class="line">    ConstraintLayout(</span><br><span class="line">        getConstraintLayout(orientation),</span><br><span class="line">        Modifier</span><br><span class="line">            .padding(<span class="number">16.</span>dp, <span class="number">0.</span>dp, <span class="number">16.</span>dp, <span class="number">0.</span>dp)</span><br><span class="line">            .background(color = colorEFEFEF, shape = RoundedCornerShape(<span class="number">5.</span>dp))</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .padding(<span class="number">12.</span>dp, <span class="number">12.</span>dp, <span class="number">12.</span>dp, <span class="number">12.</span>dp)</span><br><span class="line">    ) {</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.mipmap.dog_avatar),</span><br><span class="line">            contentDescription = <span class="string">"效果图片"</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .layoutId(<span class="string">"imageRef"</span>)</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .clickable {</span><br><span class="line">                    <span class="keyword">if</span> (orientation.value==<span class="number">0</span>){</span><br><span class="line">                        orientation.value=<span class="number">1</span></span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        orientation.value=<span class="number">0</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                .clip(shape = RoundedCornerShape(<span class="number">5</span>)),</span><br><span class="line">            contentScale = ContentScale.FillWidth</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">"泰迪犬其实是贵宾犬的一种。根据体型大小被分为四类，最受欢迎的是体型较小的品种：迷你贵宾犬和玩具贵宾犬。其中玩具贵宾犬是体型最小的一种，个性好动、欢快、非常机警、聪明、喜欢外出、性格脾气好、适应力强。贵宾犬不脱毛，是极好的宠物犬。如果红色玩具贵宾犬不剃胡须和嘴边的毛可以长成动漫画里面泰迪熊的模样，所以红色（褐色）玩具贵宾犬又叫“泰迪"</span>,</span><br><span class="line">            modifier = Modifier.layoutId(<span class="string">"titleRef"</span>),</span><br><span class="line">            fontSize = <span class="number">18.</span>sp,</span><br><span class="line">            textAlign = TextAlign.Left,</span><br><span class="line">            overflow = TextOverflow.Ellipsis,</span><br><span class="line">            maxLines =<span class="keyword">if</span> (orientation.value==<span class="number">0</span>) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> <span class="number">4</span>,)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getConstraintLayout</span><span class="params">(orientation:<span class="type">MutableState</span>&lt;<span class="type">Int</span>&gt;)</span></span>:ConstraintSet{</span><br><span class="line">    <span class="keyword">return</span> ConstraintSet {</span><br><span class="line">        <span class="keyword">val</span> imageRef= createRefFor(<span class="string">"imageRef"</span>)</span><br><span class="line">        <span class="keyword">val</span> titleRef= createRefFor(<span class="string">"titleRef"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (orientation.value==<span class="number">0</span>){</span><br><span class="line">            constrain(imageRef){</span><br><span class="line">                start.linkTo(parent.start)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                top.linkTo(parent.top)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            constrain(titleRef){</span><br><span class="line">                start.linkTo(imageRef.start)</span><br><span class="line">                end.linkTo(imageRef.end)</span><br><span class="line">                top.linkTo(imageRef.bottom,<span class="number">16.</span>dp)</span><br><span class="line">                width= Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            constrain(imageRef){</span><br><span class="line">                start.linkTo(parent.start)</span><br><span class="line">                top.linkTo(parent.top)</span><br><span class="line">                width=Dimension.value(<span class="number">100.</span>dp)</span><br><span class="line">                height=Dimension.value(<span class="number">100.</span>dp)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            constrain(titleRef){</span><br><span class="line">                start.linkTo(imageRef.end,<span class="number">8.</span>dp)</span><br><span class="line">                top.linkTo(imageRef.top,<span class="number">2.</span>dp)</span><br><span class="line">                end.linkTo(parent.end)</span><br><span class="line">                bottom.linkTo(imageRef.bottom,<span class="number">8.</span>dp)</span><br><span class="line">                width= Dimension.fillToConstraints</span><br><span class="line">                height= Dimension.fillToConstraints</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>本文所有代码<a href="https://github.com/xxm-sz/ComposeDemo">仓库地址</a></p><p>欢迎<strong>点赞+关注+评论三连击</strong></p><p>【<a href="https://github.com/xxm-sz">Github</a>】【<a href="https://juejin.cn/user/888061125471917/posts">掘金</a>】【<a href="https://xxm-sz.github.io/">博客</a>】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介与依赖&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介与依赖&quot;&gt;&lt;/a&gt; 简介与依赖&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose ConstraintLayout&lt;/code&gt;约束布局主要应用在构建复杂布局，避免使用&lt;code&gt;</summary>
      
    
    
    
    <category term="Jetpack" scheme="http://example.com/categories/Jetpack/"/>
    
    
    <category term="Jetpack Compose" scheme="http://example.com/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>运输层的TCP与UDP</title>
    <link href="http://example.com/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/"/>
    <id>http://example.com/2021/02/23/%E8%BF%90%E8%BE%93%E5%B1%82TCP%E4%B8%8EUDP/</id>
    <published>2021-02-22T16:00:00.000Z</published>
    <updated>2021-02-23T03:43:09.041Z</updated>
    
    <content type="html"><![CDATA[<p>运输层提供了端与端系统之间的逻辑通信（主机内部），而运输层提供了主机之间的逻辑通信，也就意味着运输层不存在中间路由器中。运输层在应用层与网络层之间至少提供最基础的多路复用和多路分解的服务，通过socket将应用层多个进程的数据收集交付网络层；或将网络层数据交付到不同的端口号的socket，提供给应用层的进程。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>不可靠，面向无连接，首部字段少（8个字段）。UDP中只有源端口和目的端口，从网络层到达数据，只要目的端口一样，不管源端口是否一致，都会将数据提供给同个socket。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210221100950.png" alt="image-20210221100943848"></p><p>校验和：检验报文段在传输到目的端口前，32比特是否发生了改变。</p><p>​    发生方：会将源端口，目的端口，长度三个16位的比特分别相加，如果发生溢出，则末位加1。然后将结果取反，作为检验和的内容。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>面向连接，可靠的运输层传输控制协议。</p><h4 id="一、TCP报文段格式"><a href="#一、TCP报文段格式" class="headerlink" title="一、TCP报文段格式"></a>一、TCP报文段格式</h4><p>虽然TCP面向字节流，但TCP传输的数据单元却是报文段。TCP报文段分为TCP首部和数据部分，TCP报文段首部的前20个字节是固定的，后面有4*n字节根据需要动态添加的选项，最大长度为40字节。<br><img src="https://user-gold-cdn.xitu.io/2019/7/13/16bea56ed5a68bb6?w=615&amp;h=400&amp;f=png&amp;s=88136"></p><ul><li><strong>源端口和目的端口</strong> 各占两个字节，TCP的分用功能也是通过端口实现的。</li><li><strong>序号</strong> 占4个字节，范围是[0,2<sup>32</sup>],TCP是面向字节流的，每个字节都是按顺序编号。例如一个报文段，序号字段是201，携带数据长度是100，那么第一个数据的序号就是201，最后一个就是300。当达到最大范围，又从0开始。</li><li><strong>确认号</strong> 占4个字节，是期望收到对方下一个报文段的第一个字节的序号。若确认号=N,则表示序号N前所有的数据已经正确收到了。</li><li><strong>数据偏移</strong> 占4位，表示报文段的数据部分的起始位置，距离整个报文段的起始位置的距离。间接的指出首部的长度。</li><li><strong>保留</strong> 占6位，保留使用，目前为0.</li><li><strong>URG（紧急）</strong> 当URG=1,表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。</li><li><strong>ACK(确认)</strong> 仅当ACK=1时，确认号才有效，连接建立后，所有的报文段ACK都为1。</li><li><strong>PSH(推送)</strong> 接收方接收到PSH=1的报文段，会尽快交付接收应用经常，不再等待整个缓存填满再交付。实际较少使用。</li><li><strong>RST(复位)</strong> RST=1时，表明TCP连接中出现严重差错，必须是否连接，再重连。</li><li><strong>SYN(同步)</strong> 在建立连接时用来同步序号。当SYN=1,ACK=0，则表明是一个连接请求报文段。SYN=1,ACK=1则表示对方同意连接。TCP建立连接用到。</li><li><strong>FIN(终止)</strong> 用来释放一个连接窗口。当FIN=1时，表明此报文段的发送方不再发送数据，请求释放单向连接。TCP断开连接用到。</li><li><strong>窗口</strong> 占2个字节，表示发送方自己的接收窗口，窗口值用来告诉对方允许发送的数据量。</li><li><strong>校验和</strong> 占2字节，检验和字段查验范围包括首部和数据部分。</li><li><strong>紧急指针</strong> 占2字节，URG=1时，紧急指针指出本报文段中的紧急数据的字节数（紧急字节数结束后为普通字节）。</li><li><strong>选项</strong> 长度可变，最长可达40字节。例如最大报文段长度MSS。MSS指的是数据部分的长度而不是整个TCP报文段长度，MSS默认为536字节长。窗口扩大，时间戳选项等。</li></ul><h4 id="二、丢包情况"><a href="#二、丢包情况" class="headerlink" title="二、丢包情况"></a>二、丢包情况</h4><p>由于网络层的丢包并不会显式告知运输层，TCP推断丢包主要通过超时和三次冗余ACK报文段两种方式来推断网络出现丢包。</p><p><strong>超时/重传机制解决报文段丢失问题</strong> 。超时时长需要大于发送方发送报文段到接收该报文段的确认的往返时间RTT。而RTT在不同时刻会有较大的波动，需要在某个时刻测量报文段的往返时间，称之为样本往返时间<code>SampleRTT</code>。</p><p><code>SampleRTT</code>并不能反映一段时间内RTT的波动情况，因此需要求个均值：<br>$$<br>EstimatedRTT=(1-a)<em>EstimatedRTT+a</em>SampleRTT<br>$$</p><p>a的参考值为0.125。</p><p>$$<br>EstimatedRTT=0.875<em>EstimatedRTT+0.125</em>SampleRTT<br>$$</p><p>测量<code>SampleRTT</code>的偏差情况也是有帮助的：</p><p>$$<br>DevRTT=（1-a)<em>DevRTT+a</em>|SmapleRTT-EstimatedRTT|<br>$$</p><p>a的推荐之为0.25</p><p>在上述相关时间的确定下，TCP超时时隔的设置：<br>$$<br>EstimatedRTT+4*DevRTT<br>$$</p><h4 id="三、连接管理"><a href="#三、连接管理" class="headerlink" title="三、连接管理"></a>三、连接管理</h4><h5 id="1、连接建立：三次握手"><a href="#1、连接建立：三次握手" class="headerlink" title="1、连接建立：三次握手"></a><strong>1、连接建立：三次握手</strong></h5><p>三次握手图例如下,与文字解释配合使用效果更佳。</p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112735.png"><br><strong>第一次</strong>：客户端发送连接请求报文给服务端，其中SYN=1,seq=x。发送完毕后进入SYN_END状态。</p><p><strong>第二次</strong>：服务端接收到报文后，发回确认报文，其中ACK=1,ack=x+1，因为需要客户端确认，所以报文中也有SYN=1,seq=y的信息。发送完后进入SYN_RCVD状态。</p><p><strong>第三次</strong>:客户端接收到报文后,发送确认报文，其中ACK=1,ack=y+1。发送完客户端进入<code>ESTABLISHED</code>状态，服务端接收到报文后，进入<code>ESTABLISHED</code>状态。到此，连接建立完成。</p><p><strong>三次握手原因</strong></p><p>避免资源被浪费掉。如果在第二步握手时，由于网络延迟导致确认包不能及时到达客户端，那么客户端会认为第一次握手失败，再次发送连接请求，服务端收到后再次发送确认包。在这种情况下，服务端已经创建了两次连接，等待两个客户端发送数据，而实际却只有一个客户端发送数据。</p><h5 id="2、连接断开：四次挥手"><a href="#2、连接断开：四次挥手" class="headerlink" title="2、连接断开：四次挥手"></a><strong>2、连接断开：四次挥手</strong></h5><p>四次挥手指客户端和服务端各发送一次请求终止连接的报文，同时双方响应彼此的请求。<br>四次挥手图例如下，请配置文字解释使用哦。<br><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112847.png" alt="四次挥手图例"><br><strong>第一次挥手</strong>：客户端发送FIN=1，seq=x的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭。发送完后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次挥手</strong>：服务端收到请求包后，发回ACK=1,ack=x+1的确认包，表示确认断开连接。服务端进<code>入CLOSE_WAIT</code>状态。客户端收到该包后，进入<code>FIN_WAIT_2</code>状态。此时客户端到服务端的数据连接已断开。</p><p><strong>第三次挥手</strong>：服务端发送FIN=1,seq=y的包给客户端，表示自己没有数据要给客户端了。发送完后进入<code>LAST_ACK</code>状态，等待客户端的确认包。</p><p><strong>第四次挥手</strong>：客户端收到请求包后，发送ACK=1,ack=y+1的确认包给服务端，并进入<code>TIME_WAIT</code>状态，有可能要重传确认包。服务端收到确认包后，进入<code>CLOSED</code>状态，服务端到客户端的连接已断开。客户端等到一段时间后也会进入<code>CLOSED</code>状态。</p><p><strong>四次挥手原因</strong><br>由于TCP的连接是全双工，双方都可以主动传输数据，一方的断开需要告知对方，让对方可以相关操作，负责任的表现。</p><h4 id="四、流量控制"><a href="#四、流量控制" class="headerlink" title="四、流量控制"></a>四、流量控制</h4><p> 原因：解决由于发送方发送数据速率与接收方接收数据数据不一致问题。</p><p>接收方接收窗口大小等于接收缓存大小减去已接收未被Socket读取的字节大小。<br>$$<br>rwnd=receiverBuff-unReadByte<br>$$<br>而发送方的发送窗口大小受限于<strong>拥塞窗口</strong>和<strong>接收窗口</strong>大小,即取两者最小值：<br>$$<br>swnd=min(rwnd,cwnd)<br>$$<br>流量控制主要采用了滑动窗口协议进行控制：</p><p>对于发送方接收缓存数据存在三种状态：</p><p><strong>发送已确认</strong> 、<strong>发送未确认</strong>、<strong>未发送</strong></p><p>而发送方接收缓存中数据存在两种状态：</p><p><strong>已接收和确认但未被上层读取</strong>、<strong>接收未确认</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112138.png"></p><h4 id="五、拥塞机制"><a href="#五、拥塞机制" class="headerlink" title="五、拥塞机制"></a>五、拥塞机制</h4><p>网络拥塞会导致路由器缓存溢出，而造成丢包，导致数据不可靠传输。而拥塞机制也正是解决该问题，告知TCP发送方如何调整发送速率，以将适量的数据交付到网络中，避免不要丢包，或者在丢包后，发送方应该如何调整速率。</p><p><strong>网络拥塞带来的代价</strong>：</p><ul><li>当分组到达速率接近链路容量时，分组会经历巨大的时延；</li><li>发送方必须执行重传已补偿因为缓存溢出而丢弃（丢失）的分组；</li><li>发送方遇到大时延所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组；</li><li>当一个分组沿一条路被丢弃时，每个上游路由器用于转发改分组到丢弃该分组而使用的传输容量被浪费掉；</li></ul><p>由于运输层无法显式从网络层获取到网络拥塞相关反馈，所有TCP只能借用超时和三个冗余ACK两种丢包情况来推断网络出现拥塞，从而进行端到端的拥塞控制。</p><p><strong>TCP拥塞控制算法</strong></p><p>分为三步骤：慢启动，拥塞避免，快速恢复</p><ul><li><p>1、慢启动</p><p>拥塞窗口cwnd以一个MSS开始，每收到一个ACK报文段，则增1个MSS，即数据成指数增长。</p><p>以下三种情况会结束慢启动状态：</p><ul><li><p><strong>超时丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</p></li><li><p><strong>三次冗余ACK</strong>:此时判断网络出现拥塞而丢包，执行快速重传，进入快速恢复状态；</p></li><li><p><strong>到达阈值</strong>：结束慢启动，进入拥塞避免；</p></li></ul></li><li><p>2、拥塞避免</p><p>到达拥塞避免阶段，拥塞窗口在每个RTT内以1个MSS增长，成线性增长。</p><ul><li><strong>超时丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</li><li><strong>三次冗余ACK</strong>:此时判断网络出现拥塞而丢包，将拥塞窗口减少一半，进入快速恢复状态；</li></ul></li><li><p>3、快速恢复</p><p>此时<code>ssthresh=cwnd/2</code>，</p><p>在Reno版本，如果接收到对丢包的报文段的冗余ACK报文段，拥塞窗口则增加一个MSS。拥塞窗口<code>cwnd=cwnd/2+3MSS(3次冗余ACK确认增加)</code>,然后线性增加。（拥塞避免）</p><p>在Tahoe版本，拥塞窗口<code>cwnd=1MSS</code>，指数增长，达到<code>ssthresh</code>进入线性增长。（慢启动操作，目前已弃用）</p><ul><li><strong>丢包</strong>：将cwnd置为1个MSS,慢启动阈值 <code>ssthresh=cwnd/2</code>,重新开始慢启动；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223111340.png"></p><p>​    </p></li></ul><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>  1、TCP判断可能出现丢包两种情况：</p><ul><li><p>定时器超时</p></li><li><p>接收到三次冗余ACK(即对一个报文段接收到4次ACK报文段)</p><p>2、流量控制和拥塞控制都是为了让TCP能进行可靠数据传输，流量控制是为了解决接收方接收速率与发送方速率不一致问题，通过接收窗口大小告知发生方还能接收多大字节流。而拥塞控制是为了解决网络拥塞导致丢包问题，通过拥塞窗口扼制发送方发送过多分组到网络中。发送方的发送窗口大小受限于接收窗口和拥塞窗口的最小值。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xxm-sz/dio@main/img/20210223112241.png"></p><h4 id="七、相关连接"><a href="#七、相关连接" class="headerlink" title="七、相关连接"></a>七、相关连接</h4><p><a href="https://juejin.cn/post/6844903889146216456">个人往期文章总结：TCP与UDP</a></p><p>参考数据：《计算机网络 自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运输层提供了端与端系统之间的逻辑通信（主机内部），而运输层提供了主机之间的逻辑通信，也就意味着运输层不存在中间路由器中。运输层在应用层与网络层之间至少提供最基础的多路复用和多路分解的服务，通过socket将应用层多个进程的数据收集交付网络层；或将网络层数据交付到不同的端口号</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://example.com/2020/12/20/Threadlocal/"/>
    <id>http://example.com/2020/12/20/Threadlocal/</id>
    <published>2020-12-20T04:12:57.000Z</published>
    <updated>2021-02-05T08:43:51.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是ThreadLocal"><a href="#一、什么是ThreadLocal" class="headerlink" title="一、什么是ThreadLocal"></a>一、什么是ThreadLocal</h3><p>ThreadLocal用于保存线程全局变量，以方便调用。即，当前线程独有，不与其他线程共享；可在当前线程任何地方获取到该变量。</p><h3 id="二、ThreadLocal的使用"><a href="#二、ThreadLocal的使用" class="headerlink" title="二、ThreadLocal的使用"></a>二、ThreadLocal的使用</h3><h4 id="1、如何保存内容"><a href="#1、如何保存内容" class="headerlink" title="1、如何保存内容"></a>1、如何保存内容</h4><p>创<code>ThreadLocal</code>实例，并调用<code>set</code>函数，保存<code>中国</code>字符串，分别在当前线程和<code>new-thread</code>线程获取该值。通过打印结果可以看到，虽然引用的是同个对象，但<code>new-thread</code>线程获取到的值却是<code>null</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115104823.png" alt="use"></p><p>运行结果:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main 中国</span><br><span class="line">MainActivity: new-thread null</span><br></pre></td></tr></tbody></table></figure><p>这是什么情况呢？</p><p>在<code>ThreadLocal</code>的<code>set</code>函数中，获取当前线程的<code>ThreadLocalMap</code>实例，如何当前线程第一次使用<code>ThreadLocal</code>,则需要创建<code>ThreadLocalMap</code>实例，否则直接通过<code>ThreadLocalMap</code>实例的<code>set</code>函数进行保存。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115103657.png" alt="set"></p><h4 id="2、如何获取内容"><a href="#2、如何获取内容" class="headerlink" title="2、如何获取内容"></a>2、如何获取内容</h4><p>由于<code>main</code>线程前面<code>set</code>函数将内容保存到<code>ThreadLocalMap</code>实例中，已经可以获取到<code>中国</code>字符串。而在<code>new-thread</code>线程中，由于是第一次使用<code>ThreadLocalMap</code>，所以此时<code>map</code>是<code>null</code>，并调用<code>setInitialValue</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115111259.png" alt="get"></p><p>在<code>setInitialValue</code>函数中,调用了<code>initialValue</code>函数，该函数直接返回了<code>null</code>，这就是为什么在<code>new-thread</code>线程获取的值是<code>null</code>。因此<code>setInitialValue</code>函数主要为当前线程创建<code>ThreadLocalMap</code>对象。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115112648.png" alt="setInitialValue"></p><h4 id="3、ThreadLocalMap"><a href="#3、ThreadLocalMap" class="headerlink" title="3、ThreadLocalMap"></a>3、ThreadLocalMap</h4><p><code>ThreadLocalMap</code>内部持有一个数组<code>table</code>，用于保存<code>Entry</code>元素。<code>Entry</code>继承至<code>WeakReference</code>,并以<code>ThreadLcoal</code>实例作为<code>key</code>，和保存内容 T作为<code>value</code>。当发生GC时，<code>key</code>就会被回收,从而导致该Entry过期。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118144659.png" alt="Entry"></p><p>每一个线程都持有一个<code>ThreadLocalMap</code>局部变量<code>threadLocas</code>，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118113312.png" alt="image-20210118113312896"></p><h5 id="3-1-ThreadLocalMap的创建"><a href="#3-1-ThreadLocalMap的创建" class="headerlink" title="3.1 ThreadLocalMap的创建"></a>3.1 ThreadLocalMap的创建</h5><p>ThreadLocalMap对象的创建，也就是ThreadLocal 对象调用了自身的<code>createMap</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115114648.png" alt="createMap"></p><p>ThreadLocalMap的构造函数，创建了一个保存Entry对象的table数组，默认大小16。并通过<code>threadLocal</code>的<code>threadLocalHashCode</code>属性计算出Entry在数组的小标，进行保存，并计算出阈值<code>INITIAL_CAPACITY</code>的2/3。</p><p><code>threadLocalHashCode</code>属性在ThreaLocal对象创建时会自动计算得出.</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210115145913.png" alt="threadLocalHashCode"></p><p><code>threadLocalHashCode</code>作为ThreadLocal的唯一实例变量，在不同的实例中是不同的，通过<code>nextHashCode.getAndAdd</code>已经定义了下一个ThreadLcoal的实例的<code>threadLocalHashCode</code>值，而第一个ThreadLocal的<code>threadLocalHashCode</code>值则是从0开始，与下一个<code>threadLocalHashCode</code>间隔<code>HASH_INCREMENT</code>。</p><p>通过<code>threadLocalHashCode &amp; (len-1)</code>计算出来的数组下标，分发很均匀，减少冲突。但是呢，冲突时还是会出现，如果发生冲突，则将新增的Entry放到后侧<code>entry=null</code>的地方。</p><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><h4 id="1、ThreadLocalMap的set函数"><a href="#1、ThreadLocalMap的set函数" class="headerlink" title="1、ThreadLocalMap的set函数"></a>1、ThreadLocalMap的set函数</h4><p>在上一节中，分析了<code>ThreadLocal</code>实例的<code>set</code>函数，最终是调用了<code>ThreadLocalMap</code>实例的<code>set</code>函数进行保存。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116153208.png" alt="mapset"></p><p>通过代码分析可知，<code>ThreadLocalMap</code>的<code>set</code>函数主要分为三个主要步骤：</p><ol><li><p>计算出当前<code>ThreadLocal</code>在<code>table</code>数组的位置，然后向后遍历，直到遍历到的<code>Entry</code>为<code>null</code>则停止，遍历到<code>Entry</code>的<code>key</code>与当前<code>threadLocal</code>实例的相等，直接更替value；</p></li><li><p>如果遍历到<code>Entry</code>已过期（<code>Entry</code>的<code>key</code>为<code>null</code>），则调用<code>replaceStaleEntry</code>函数进行替换。</p></li><li><p>在遍历结束后，未出现1和2两种情况，则直接创建新的<code>Entry</code>，保存到数组最后侧没有Entry的位置。</p></li></ol><p>在第2步骤和最后都会清理过期的<code>Entry</code>，这个稍后分析，先看看第2步骤，在检测到过期的Entry，会调用<code>replaceStaleEntry</code>函数进行替换。</p><p>   <img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116152455.png" alt="replaceStaleEntry"></p><p><code>replaceStaleEntry</code>函数，主要分为两次遍历，以当前过期的Entry为分割线，一次向前遍历，一次向后遍历。</p><p>在向前遍历过程，如果发现有过期的<code>Entry</code>，则保留其位置<code>slotToExpunge</code>，直到有<code>Entry</code>为<code>null</code>为止。这里只是判断<code>staleSlot</code>前方是否有过期的<code>Entry</code>，然后方便后面进行清理。</p><p>在向后遍历过程，如果发现有<code>key</code>相同的<code>Entry</code>，直接与<code>staleSlot</code>位置的<code>Entry</code>交换<code>value</code>（上图注释有问题）。如果没有碰到相同的<code>key</code>，则创建新的<code>Entry</code>保存到<code>staleSlot</code>位置。与此同时，如果向前遍历没有发现过期Entry，而在向后遍历发现过期的<code>ntry</code>，则需要更新过期位置<code>slotToExpunge</code>，因为后面的清除内容是需要<code>slotToExpunge</code>。</p><h4 id="2、ThreadLocalMap清除过期Entry"><a href="#2、ThreadLocalMap清除过期Entry" class="headerlink" title="2、ThreadLocalMap清除过期Entry"></a>2、ThreadLocalMap清除过期Entry</h4><p>在上一小节中，会通过<code>expungeStaleEntry</code>函数和<code>cleanSomeSlots</code>函数清理过期的Entry，它们又是如何实现呢？</p><p><code>expungeStaleEntry</code>函数清理过期<code>Entry</code>过程被称为：<strong>探测式清理</strong>。函数传递进来的参数是过期的<code>Entry</code>的位置，工作过程是先将该位置置为<code>null</code>，然后遍历数组后侧所有位置的Entry，如果遍历到有<code>Entry</code>过期,则直接置<code>null</code>，否则将它移到合适的位置：<code>hash</code>计算出来的位置或离该<code>hash</code>位置最近的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116165619.png" alt="expungeStaleEntry"></p><p>经过这么一次经历，<code>staleSlot</code>位置到后侧最近<code>entry=null</code>的位置就不存在过期的<code>entry</code>，而每个<code>entry</code>要么在原有<code>hash</code>位置，要么离原有<code>hash</code>位置最近。</p><p><code>expungeStaleEntry</code>函数的工作范围：</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116174219.png" alt="expungeStaleEntry (1)"></p><p><code>expungeStaleEntry</code>函数一开始会将起点，即数组第3的位置设置为<code>null</code>。然后开始遍历数组后侧元素，4和5位置无论是否在它的<code>hash</code>位置，在这里都保持不变。遍历到第6时，发现<code>entry</code>已过期，将第6设置为<code>null</code>。此时3和6位置变成白色了。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116175944.png" alt="image-20210116175944199"></p><p>A、遍历到第7的时候，假设<code>h != i</code>成立，那么第7位置的<code>entry</code>将被移到第6位置，空出第7位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210116180006.png" alt="image-20210116180006575"></p><p>B、接着遍历到第8位置，假设<code>h != i</code>不成立，则第8的<code>entry</code>的位置不变。</p><p>接着继续遍历后侧元素，重复着A和B步骤，直到碰到entry为null，退出遍历。例如这里的第10位置，entry=null。</p><p>由于探测性清理，碰到<code>entry=null</code>的情况就会结束。而通过<code>cleanSomeSlots</code>函数进行<strong>启发式清理</strong>，碰到<code>entry=null</code>不停止，而是由控制条件n决定，而在这个过程中，碰到过期<code>entry</code>，n又恢复到数组长度,加大清理范围。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118101626.png" alt="clean"></p><p>在启发式清理过程，如果碰到过期<code>Entry</code>，会导致控制条件<code>n</code>恢复到数组长度<code>len</code>，从而导致循环次数增加，则往后<code>nextIndex</code>次数增加，从而增加清理范围。这种方式也不一定能完整清理后面所有过期元素，例如在控制<code>n</code>右移所有过程中，没有碰到过期的<code>entry</code>，就结束了。</p><h4 id="3、ThreadLocalMap的扩容机制"><a href="#3、ThreadLocalMap的扩容机制" class="headerlink" title="3、ThreadLocalMap的扩容机制"></a>3、ThreadLocalMap的扩容机制</h4><p>在第1节，调用<code>ThreadLocalMap</code>的<code>set</code>函数最后，会调用<code>reHash</code>函数进行扩容。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118110300.png" alt="rehash"></p><p>在外层进行启发式清理后，如果<code>size&gt;threshold</code>则会进行rehash，而在<code>rehash</code>中，会清理整个数组的过期<code>Entry</code>，如果清理后，数组长度还大于<code>3/4*threshod</code>，则进行扩容<code>resize</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118111623.png" alt="resize"></p><p><code>resize</code>函数直接创建新的数组，长度为旧数组的两倍。然后重新计算旧数组元素在新数组的位置，复制。</p><h3 id="四、内存泄露"><a href="#四、内存泄露" class="headerlink" title="四、内存泄露"></a>四、内存泄露</h3><p>正常情况下，用完ThreadLocal实例,将其置为null，在发生GC时，ThreadLocal对象就会被回收。但是此时如果线程还存活(例如线程池线程的复用)，就会导致Entry的value对象得不到释放，会造成内存泄露。所以，在使用完ThreadLocal实例后，调用<code>remove</code>函数清除一下。</p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>发生GC的时候，Key会被回收么，还能获取到值么？</p><p>正常情况下，如果ThreadLocal实例同时被强引用，所以在发生GC的时候，是不会回收的，也就是此时<code>WeakReference.get</code>是有返回值的，不会被回收。</p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118174100.png" alt="gc"></p><p><img src="https://cdn.jsdelivr.net/gh/Android-XXM/dio@main/img/20210118175757.png" alt="image-20210118175757028"></p><p><a href="https://zhuanlan.zhihu.com/p/58931565?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1182794502313586688">推荐阅读：Java引用与ThreadLocal</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、什么是ThreadLocal&quot;&gt;&lt;a href=&quot;#一、什么是ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ThreadLocal&quot;&gt;&lt;/a&gt;一、什么是ThreadLocal&lt;/h3&gt;&lt;p&gt;ThreadLocal用于保</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
</feed>
